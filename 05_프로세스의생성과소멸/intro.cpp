/*
MS에서 Windows 3.1은 멀티 프로세스기능이 지원되지 않았던 운영체제.
Windows는 도스를 사용하지 못하는 사람들을 위한 운영체제 정도.
3.1은 기본적으로 DOS를 설치한 다음에 설치해야 되서 운영체제라기보다는 하나의 프로그램.
IBM의 OS2는 멀티 프로세스 기능을 가지고 있었다.

01 Process의 이해
멀티 프로세스 운영체제는 프로세스라는 것이 여러 개 존재할 수 있는 운영체제.

프로세스란 무엇인가?
프로세스란 실행 중에 있는 프로그램.
.exe은 보통 프로그램이고, 더블클릭을 하면 클릭한 프로그램의 실행을 위해 메모리 할당이 이뤄지고,
이 메모리 공간으로 바이너리 코드가 올라가게 된다. 이 순간부터 프로그램은 프로세스라고 불리게 된다.
즉 프로세스란 실행 중에 있는 프로그램을 의미.
익스플로러 창도 프로세스.
둘 이상의 익스플로러를 실행시킨다면, 둘 이상의 프로세스를 생성한 셈.

프로세스를 구성하는 요소
1)Execution of "C" Program
기본적으로 전역변수나 static 변수의 할당을 위해 존재하는 Data영역, 지역변수 할당과 함수 호출 시 전달되는
인자값들의 저장을 위해 존재하는 Stack영역, 그리고 동적 할당을 위해 존재하는 Heap영역으로 구성된다.
프로그램을 실행시키면, 실행파일 내에 존재하는 명령어들이 메모리상에 순차적으로 실행된다.
이렇게 실행파일을 구성하는 명령어들이 올라가는 메모리 영역을 Code영역이라고 한다.
|명령어(Instruction Code)|↕Code 영역
|전역변수 static변수     |↕Data 영역
|프로그래머 할당         |↓Heap 영역
|지역변수 전달인자 정보  |↑Stack 영역
위 그림은 프로세스 생성 시 만들어지는 메모리 구조이고 프로세스이다.
왜냐하면 프로그램 실행을 위해서 명령어들이 메모리 공간에 올라와 있는 상태이고, 프로그램 실행을 위해서
필요한 메모리 공간이 할당되어 있는 상태이기 때문이다.
메모리 구조는 실행되고 있는 프로세스 개수만큼 생성된다.

2)Register Set
프로그램 실행을 위해서는 레지스터들이 절대적으로 필요하다.
block.exe를 실행 중에 있다면, CPU를 구성하는 레지스터들은 block.exe의 실행을 위해 필요한 데이터로 채워짐.
이렇듯 CPU내에 존재하는 레지스터들은 현재 실행 중인 프로그램을 위한 데이터들로 채워진다.
따라서, 레지스터들의 상태까지도 프로세스의 일부로 포함시켜 말할 수 있다.
이것은 Context Switching을 이해하는데 필요하다.

메인 메모리는 보통 RAM을 의미하는데, RAM은 그 크기가 상당히 제한적이다.
RAM의 크기를 넘어서도 프로세스를 만들 수 있다.
만약에 RAM의 크기가 허용하는 만큼만 프로세스 생성이 허용된다면, 하나의 프로세스도 제대로 생성하지 못한다.
메모리 관리부분에서 답을 얻을 수 있다.

02 프로세스의 스케줄링과 상태 변화
CPU는 기본적으로 한 순간에 하나의 프로그램만 실행 가능하다.

프로세스의 스케줄링(Scheduling)
동시에 실행되어야 할 프로세스가 여러개면 하나의 CPU가 여러 개의 프로세스를 번갈아 가면서 실행해야 한다.
CPU는 아주 빠르기 때문에 하나의 CPU가 여러 프로세스를 고속으로 번갈아 가며 실행시킬 경우, 프로그램 사용자들은
CPU가 동시에 여러 개의 프로그램을 실행시킨다고 느끼게 된다.
결국 멀티 프로세스 운영체제에서 여러 개의 프로세스가 실행되는 것처럼 보이는 이유는 여러 개의 프로세스들이
CPU할당 시간을 나누기 때문이다.

스케줄링의 기본 원리
생각해볼 것은 프로세스들에게 CPU를 할당하는 기준이다.
가장 쉽게 생각해 볼 수 있는 것은, 공평하게 순서대로 돌아가면서 정해진 시간만큼만 CPU를 할당받는 것.
프로세스의 CPU할당 순서 및 방법을 결정짓는 일을 스케줄링(Scheduling)이라고 하며 이 때 사용되는 알고리즘을
스케줄링 알고리즘(Schedulig Algorithm)이라고 한다.
또한 스케줄링 알고리즘을 적용해서 실제로 프로세스를 관리하는 운영체제 요소를 가리켜 스케줄러(Scheduler)라 한다.
스케줄러는 소프트웨어적으로 구현되어 있는 요소로서, 운영체제를 구성하는 중요한 요소.
       ┌─── 스케줄러에 의한 프로세스 관리 ────────────────┐
CPU ─────> Running 상태 프로세스 <──> Ready 상태 프로세스 │
   실행│              Process A ───>                    │
	   │      		            <─── Process B          │
       └────────────────────────────────────────────────┘

멀티 프로세스는 CPU를 바쁘게 한다.
1)고전적인 방식
A프로세스를 먼저 실행시킨다.
A프로세스가 완전히 종료되고 나면, B프로세스를 실행시킨다.
B프로세스도 완전히 종료된다.
그리고 나서야 C프로세스를 실행시킨다.
즉 실행해야 할 일을 순차적으로 실행시키는 것.
2)동시에 실행되는 형태
A, B, C프로세스를 모두 실행시킨 후 멀티 프로세스 운영체제의 스케줄러에 의해서 프로세스들이 관리되도록 한다.
즉 정해진 순서에 의해서 CPU의 실행시간을 나눠서 할당받아 실행하는 형태.
일반적으로, 프로그램이 실행되는 과정에서 많은 시간을 I/O에 할당한다.
I/O는 데이터의 입출력을 말하는 것인데 파일 입출력만을 뜻하는 것이 아닌 호스트와 데이터 송수신도 해당.
인터넷 익스플로러의 경우에도 프로그램 실행의 상당 시간을 I/O가 차지한다.
주소를 입력하면 서버로부터 웹페이지를 전송받게 되는데, 이러한 전송과정이 I/O에 해당.
서버나 인터넷에 많은 부하가 걸려있으면 웹페이지를 보기 위해서 오래 기다려야 한다.
입력 및 출력에 관련된 일을 할 경우 상당 시간 CPU는 아무 일도 하지 않고 대기하게 된다. 다른 일을 시키지 않으면.
I/O측면만 고려한다면 멀티 프로세스 기반으로 프로세스들을 처리하는 것이 훨씬 더 효율적이다.
고전적인 방식이면 A프로세스가 I/O에 관련된 일을 하고 있으면 CPU는 아무 일도 하지 못하고 쉬게 된다.
멀티라면 A프로세스가 I/O에 관련된 일을 할 경우, 운영체제는 스케줄러를 통해서 다른 프로세스가 실행되도록 스케줄링.
결국 실행되어야 할 프로세스가 다수 존재하는 상황이라면, CPU에게 쉴 틈이 주어지지 않는 셈.

프로세스의 상태 변화
멀티 프로세스 운영체제에서는 프로세스 하나가 계속해서 실행되는 것이 아니고, 여러 개의 프로세스들이 돌아가면서
실행되기 때문에, 프로세스 각각의 상태는 시간 흐름에 따라 변화한다.
S ─────> Ready ─────> Running ─────> Blocked ─────> E
    1      ↑     2      │       4       │      6
 	       └────────────┘               │
		   ↑     3                      │
           └────────────────────────────┘
				          5
1 : S(Start)에서 Ready 상태로의 전이를 보여준다.
S는 프로세스가 생성되었음을 의미한다. 프로세스는 생성과 동시에 Ready상태로 들어간다.
Ready상태에 있는 프로세스는 CPU에 의해 실행되기를 희망하는 상태이다.
바로 실행할 수 없는 이유는 멀티 프로세스 운영체제이기 때문에, 현재 CPU에 의해서 임의의 프로세스가 실행 중 일 수도.
2 : Ready 상태에서 Running 상태로의 전이를 보여준다.
Ready상태에 있는 프로세스들은 스케줄러에 의해서 관리되는 프로세스들이다.
스케줄러는 Ready상태에 있는 프로세스 중 하나를 선택해서 CPU에 의해 실행될 수 있도록 한다.
물론 스케줄링 알고리즘에 기반을 둔다.
결국 Ready상태에 있는 프로세스 중 스케줄러에 의해 선택된 프로세스는 Running상태가 되어 실행되는 것.
3 : Running 상태에서 Ready 상태로의 전이를 보여준다.
프로세스들은 생성 시 중요도에 따라서 우선순위(Priority)라는 것이 매겨진다.
예를 들어 프로세스 A의 우선순위가 프로세스 B의 우선순위보다 높도록 프로그램이 되어 있다고 가정.
그리고 현재 프로세스 B는 실행중.
그런데 갑자기 프로세스 B보다 우선순위가 높은 프로세스 A가 생성되었고, A프로세스는 Ready상태가 되었다.
이러한 경우 일반적으로 스케줄러는 프로세스 B의 실행을 멈추고, 우선순위가 높은 프로세스 A를 실행.
이때 프로세스 B는 Ready상태가 되고 프로세스 A가 종료되기만을 기다린다.
	   ┌────────────────────────────────────────────────┐
CPU ─────> Running 상태 프로세스 <──> Ready 상태 프로세스 │
   실행│              Process B                         │
	   │              Process B      Process A          │<─── Process A생성
	   │      		  Process A      Process B          │
	   └────────────────────────────────────────────────┘
Process A > Process B
4 : Running 상태에서 Blocked 상태로의 전이를 보여준다.
실행 중에 있는 프로세스가 실행을 멈추는 상태(Blocked)로 들어가는 것이다.
일반적으로 데이터 입출력에 관련된 일을 하는 경우에 발생한다.
프로그램 실행의 상당 시간을 데이터 입출력에 소모하고 CPU에 의해 더 이상 실행될 수 없다.
따라서 데이터 입출력을 진행 중인 프로세스는 잠시 내려오게 하고(Blocked) Ready상태에 있는 프로세스 중 하나를
대신 실행시키는 것이 CPU를 효율적으로 사용하는 것.
CPU ─────> Running 상태 프로세스 ────────────────────> Blocked 상태 프로세스 ─────> Ready 상태 프로세스
    실행       Process A        파일 I/O작업으로 인해        Process A                  Process A
	                                                    (파일 I/O진행 중)            (파일 I/O완료)
실행 중인 프로세스 A가 파일 출력을 해야만 하는 상황을 만나게 되었고, Blocked상태가 되어 파일 출력을 진행.
프로세스 A가 Blocked상태로 들어감과 동시에, Ready상태에 있는 프로세스 중 하나는 Running상태가 될 것.
5 : Blocked 상태에서 Ready 상태로의 전이를 보여준다.
Blocked상태는 스케줄러에 의해서 선택될 수 없는 상태를 의미한다.
Ready상태는 스케줄러에 의해 선택되어 지금 당장이라도 실행 가능한 상태이고, Blocked상태는 스케줄러에 의해서
선택될 수 없는 상태이다.
(추가로 프로세스를 종료시킬 경우 Blocked 상태를 거쳐서 E(Exit)상태로 갈 수도 있다)
입출력이 완료된 Blocked 상태에 있는 프로세스는 다시 Ready상태가 되어서 스케줄러에 의해 선택되길 기다린다.

혼란의 최소화!
Running상태에서 Ready상태로 전이되는 상황은 아직도 해야할 일이 있음에도 불구하고 어쩔수 없이 다른 프로세스에게
실행을 양보하는 상황이다.
예를 들어 우선순위가 높은 프로세스가 있다면 양보해야만하고 다시 실행되기를 기다려야 한다.
또는 시간을 나눠가며 실행되어야하기 때문에 다른 프로세스가 실행되도록 양보하고 난 다음에도 Ready상태로 들어감.
따라서 Ready상태에 있는 프로세스는 상황에 따라서 언제든지 다시 실행될 수 있다.
반면에 Blocked 상태는 스케줄러 관심 밖에 있는 상태이다.
예를 들어 프로세스가 I/O관련 작업에 열중하고 있다.
어차피 I/O관련 작업은 CPU연산을 필요로 하지 않으므로, 다른 프로세스에게 CPU양보를 위해 Blocked상태로 들어간다.
따라서 I/O작업이 끝날 때까지 다시 실행되어서는 안되기 때문에 Blocked상태라는 것을 둬서 스케줄러에 의해 선택되지
않는 상태가 되게 한다.
I/O작업이 끝난 다음에 Ready상태로 들어가서 스케줄러에게 선택되기를 기다리는 것이 현명한 선택.

프로세스의 상태변화, 시나리오로 다시 이해하기
예를 들어 MS워드를 실행하려 하고 사용하고 있는 컴퓨터는 회사에서 메일 서버로 사용되는 컴퓨터이다.
즉, 현재 이 컴퓨터는 아무런 일을 시키지 않아도 할 일이 있는 것이다.
이 컴퓨터는 직원들에게 들어오는 메일을 적절히 분리해서 저장해야 하고, 그 과정에서 스팸메일도 확인해야 한다.
또한 회사 직원이 보내는 메일을 외부로 전송해 줘야만 한다.
가정을 해서 MS워드가 메일 서버보다 프로세스 우선순위가 높고, 매일 서버는 계속 실행되는 프로세스고,
MS워드와 메일 서버 이외에 다른 프로세스는 하나도 존재하지 않다고 하자.
그리고 MS워드를 실행시켰다.
메일 서버가 실행 중에 있었지만, MS워드가 우선순위가 높은 관계로 메일 서버는 Ready가 되고, MS는 Running.
그러나 계속해서 워드 작업을 할 수는 없다. 키보드의 입력을 잠시 멈출 수도 있다.
또한, 계속 입력을 해도 CPU가 일을 처리하는 속도에 비해서 타이핑 속도가 상대적으로 느리다.
따라서 MS워드를 작업하는 중간 중간에도 메일 서버는 일할 기회를 얻을 확률이 높다.
그러니 메일 수신에 대해서는 걱정하지 않아도 된다.
지금까지 작업한 파일을 저장하려는데 그림파일도 있어 시간이 제법 걸릴 듯하다.
저장이 끝나야 계속해서 일을 진행할 수 있다.
결국 일정 시간 데이터의 입력은 이뤄지지 않고, 운영체제가 판단하기에 짧은 시간에라도 다른 프로세스를 실행
시키는 것이 효율적이라고 판단해서 MS워드를 Blocked상태로 변경하고, 메일 서버를 다시 Running상태로 둔다.
저장이 끝난 후에 다시 작업을 시작하면 MS워드는 Ready상태로 이동하고 메일 서버는 여전히 실행 중에 있다.
스케줄러가 작동해서 우선순위가 높은 MS워드를 실행시킨다.

03 Context Switching
CPU실행시간을 나누는 방식으로 동시 실행되는 효과를 얻었고 프로그램 실행의 상당 시간을 I/O에 소모하기 때문에
둘 이상의 프로세스 실행은 CPU의 활용도를 높여 성능 향상까지 가져온다는 결론도 내렸다.
사실 실행 중인 프로세스(Running)의 변경은 시스템에 많은 부하를 가져다 주기도 한다.
"CPU내에 존재하는 레지스터들은 현재 실행 중에 있는 프로세스 관련 데이터들로 채워진다."
실행 중인 프로세스가 변경되면 CPU내에 존재하는 레지스터들의 값들이 변경된다.
예를 들어 프로세스 A가 실행 중이고 일정 시간이 지나서, 이제 프로세스 B를 실행해야 한다.
프로세스 A도 다시 실행되어야 하기 때문에 B가 실행되기 전에 현재 레지스터들의 데이터를 저장해야 한다.
B가 이전에 실행될 때 레지스터들이 지니고 있던 데이터들을 다시 레지스터에 복원시켜줘야만 한다.
그래야 작업이 멈춰진 부분에서부터 이어질 수 있다.
CPU                             메모리
ALU ↔ Process A를 위한 데이터    Process B를 위한 데이터
Running상태 프로세스:Process A
Ready상태 프로세스:Process B
프로세스 A가 실행 중이고 레지스터 안에는 A와 관련된 정보들로 채워져 있다.
반면 B는 현재 Ready상태이고 B와 관련된 레지스터 정보가 메모리에 저장(Backup)되어 있다.
프로세스 B가 다시 Running상태가 될 경우, 이 데이터들로 채워져야만 마지막 실행 이후를 이어서 실행하게 된다.
일정 시간이 지나면 B가 다시 Running상태로 돌아가고, A는 Ready상태로 빠져 나와야 한다.
CPU                             메모리
ALU ↔ Process A를 위한 데이터    Process B를 위한 데이터
                         <────────> 
                      Context Switching
프로세스 A관련 레지스터 정보는 메모리에 저장되고, 프로세스 B관련 레지스터 정보는 CPU의 레지스터에 복원.
"실행되는 프로세스의 변경과정에서 발생하는 컨텍스트 스위칭은 시스템에 많은 부담을 준다."
이는 레지스터 개수가 많은 시스템일수록, 프로세스별로 관리되어야 할 데이터 종류가 많을수록 나쁘다.
이런 멀티 프로세스 운영체제의 단점을 위해 부담을 최소화하기 위해 노력해야 한다.
즉, 프로그램 실행과정에서 발생하는 I/O를 고려해보면, 멀티 프로세스 기반의 프로그램 실행은 많은 부분 성능
향상에 도움이 되지만 컨텍스트 스위칭이 미치는 영향을 고려하면 오히려 성능에 저하를 가져올 수도 있다.
답은 구현하는 프로그램 성격에 따라 다르고 감각을 키워나가야 한다.

04 프로세스의 생성
Windows시스템의 프로세스 생성과 소멸을 정확히 이해하기 위해서는 쓰레드, 커널 오브젝트 및 핸들에 대한 지식 필요.

프로세스의 생성
"프로그램 실행 중에 또 하나의 프로세스 생성" 시스템 프로그래머의 관점.
구현한 프로그램도 실행이 되면 하나의 프로세스가 되지만 실행 중인 프로세스가 또 하나의 프로세스를 생성하는 것.
사칙연산이 가능한 간단한 계산기를 프로그래밍하고 이외의 것을 요구하면 Windows보조프로그램의 계산기 실행.

CreateProcess 함수의 이해
Windows는 프로세스 생성을 돕기 위해서 CreateProcess함수를 제공하고 있다.
CreateProcess함수를 호출하는 프로세스를 Parent Process, 호출에 의해 생성된 프로세스를 Child Process.
즉 생성하는 프로세스와 생성되는 프로세스 간에는 부모 자식 간의 관계가 형성되는 것.
만약 자식프로세스가 CreateProcess함수호출해서 또 다시 자식 프로세스를 생성해도 부모 자식관계 형성.
Bool CreateProcess(
	LPCTSTR lpApplicationName, 1)
	LPTSTR lpCommandLine, 2)
	LPSECURITY_ATTRIBUTES lpProcessAttributes, 3)
	LPSECURITY_ATTRIBUTES lpThreadAttributes, 4)
	BOOL bInheritHandles, 5)
	DWORD dwCreationFlags, 6)
	LPVOID lpEnvironment, 7)
	LPCTSTR lpCurrentDirectory, 8)
	LPSTARTUPINFO lpStartupInfo, 9)
	LPPROCESS_INFORMATION lpProcessInformation 10)
);
If the function fails, the return value is zero.
1)lpApplicationName:생성할 프로세스의 실행파일 이름을 인자로 전달한다. 경로명을 추가로 지정할 수 있으며,
경로명을 지정하지 않을 경우 프로그램의 현재 디렉터리에서 실행파일을 찾게 된다.
2)lpCommandLine:새로 생성하는 프로세스에 인자를 전달할 때 사용. 그리고 lpApplicationName에 NULL을 전달하고,
이 인자에 실행파일의 이름을 더불어 전달할 수도 있다. 이런 경우 실행파일의 이름은 표준 검색경로를 기준을 찾음.
3)lpProcessAttributes:프로세스의 보안 속성을 지정할 때 사용. 보통은 NULL로 전달. 그러면 기본적인 보안 속성.
4)lpThreadAttributes:쓰레드의 보안 속성을 지정할 때 사용한다. NULL을 전달할 경우 디폴트 보안 속성.
5)hInheritHandle:전달인자가 TRUE이면 생성되는 자식 프로세스는 부모 프로세스가 소유하는 핸들 중 
일부(상속 가능한 핸들)를 상속한다.
6)dwCreationFlags:생성하는 프로세스의 특성(특히 우선순위)를 결정지을 때 사용되는 옵션.
특별히 설정할 필요가 없을 경우에는 0을 전달한다.
7)lpEnvironment:프로세스마다 Environment Block이라는 메모리 블록을 관리한다. 이 블록을 통해서 프로세스가
실행에 필요로 하는 문자열을 저장할 수 있다. 이 인자를 통해 생성하는 프로세스의 Environment Block을 지정.
NULL이 전달되면, 자식 프로세스는 부모 프로세스의 환경 블록에 저장되어 있는 문자열을 복사하게 된다.
8)lpCurrentDirectory:생성하는 프로세스의 현재 디렉터리를 설정하는 인자이다. 전달인자는 디렉터리 정보를
포함하는 완전경로 형태로 구성되어야 하며, NULL이 전달될 경우 부모 프로세스의 현재 디렉터리가 새로 생성하는
자식 프로세스의 현재 디렉터리가 된다. 일반적으로 NULL이 전달.
9)lpStartupInfo:STARTUPINFO구조체 변수를 초기화한 다음에 이 변수의 포인터를 인자로 전달한다.
STARTUPINFO구조체 변수는 생성하는 프로세스의 속성을 지정할 때 사용된다.
10)lpProcessInformation:생성하는 프로세스 정보를 얻기 위해 사용되는 인자이다. PROCESS_INFORMATION구조체
변수의 주소값을 인자로 전달한다. 그러면 전달된 주소값이 가리키는 변수에 프로세스 정보가 채워진다.

자료형 BOOL은 <windef.h>에 typedef int BOOL;이라고 선언되어 있다.
<windef.h>는 <Windows.h>에 포함된다.

예제를 통한 CreateProcess 함수의 이해
5_1.cpp AdderProcess.cpp
#ifdef _UNICODE
	#define _ttoi _wtoi
	#define _gettchar getwchar
#else
	#define _ttoi atoi
	#define _gettchar getchar
#endif
하루 빨리 MSDN을 참조하는 습관을 기르자.
5_2.cpp CreateProcess.cpp
프로세스 생성 1단계 : STARTUPINFO 구조체 변수의 생성 및 초기화
typedef struct _STARTUPINFO
{
	DWORD cb; //구조체 변수의 크기
	LPTSTR lpReserved;
	LPTSTR lpDesktop;
	LPTSTR lpTitle; //콘솔 윈도우의 타이틀 바 제목
	DWORD dwX; //프로세스 윈도우의 x좌표
	DWORD dwY; //프로세스 윈도우의 y좌표
	DWORD dwXSize; //프로세스 윈도우의 가로길이
	DWORD dwYSize; //프로세스 윈도우의 세로길이
	DWORD dwXCountChars;
	DWORD dwYCountChars;
	DWORD dwFillAttribute;
	DWORD dwFlags; //설정된 멤버의 정보
	WORD wShowWindow;
	WORD cbReseved2;
	LPBYTE lpReserved2;
	HANDLE hStdInput;
	HANDLE hStdOutput;
	HANDLE hStdError;
} STARTUPINFO, *LPSTARTUPINFO;
프로세스 생성 2단계 : 현재 디렉터리의 설정
현재 디렉터리는 특정 파일을 찾을 경우에 기본이 되는 디렉터리이다.
만약에 완전경로를 전달하지 않고 파일을 생성 및 개발할 경우 현재 디렉터리를 기준으로 작업.
일반적으로 프로세스가 생성되면 프로세스의 현재 디렉터리는 프로세스의 실행파일이 존재하는 디렉터리로 설정.
DWORD GetCurrentDirectory(
	DWORD nBufferLength,
	LPTSTR lpBuffer
);
If the function fails, the return value is zero.
lpBuffer는 현재 디렉터리 정보가 저장될 메모리 버퍼의 포인터.
nBufferLength는 현재 디렉터리 정보가 저장될 메모리 버퍼의 크기로서 저장 가능한 문자열 길이 정보가 전달해야 한다.
MAX_PATH라는 상수가 <windef.h>에 있는데 Windows에서 허용하는 완전경로의 최대 길이다.
프로세스의 현재 디렉터리는 변경도 가능하다.
BOOL SetCurrentDirectory(
	LPCTSTR lpPathName
);
If the function fails, the return value is zero.
함수 호출 시 유일한 전달인자 lpPathName을 통해서 변경하고자 하는 경로명을 전달.
프로세스 생성 3단계 : CreateProcess 함수의 호출
유니코드 버전에서는 다음과 같은 호출은 불가능하다.
CreateProcess( //프로세스 생성
	NULL,
	_T("AdderProcess.exe 10 20"),
	NULL, ..
);
CreateProcess함수는 내부적으로 두 번째 인자로 전달된 문자열에 변경을 가한다.
함수 호출이 끝날 때 변경된 문자열을 다시 원상태로 되돌려 놓기 때문에 인식하기는 어렵다.
따라서 전달인자의 문자열은 변수 형태여야 한다.
두 번째 전달인자에 해당하는 문자열을 상수 형태로 구성해서 전달하고 있다.
떄문에 컴파일타임에는 오류가 발생하지 않지만, 런타임에는 메모리 참조 오류가 발생한다.
그래서 배열을 이용한 변수 형태로 문자열을 선언해서 두 번째 인자로 전달해야 한다.
CreateProcess의 첫 번째 전달인자를 통해서 실행파일 이름을 전달할 경우, 현재 디렉터리를 기준으로 실행파일을
찾게 되지만, 두 번째 전달인자를 통해서 실행파일 이름을 전달할 경우에는 표준 검색경로 순서대로.
1)표준 검색경로:실행 중인 프로세스의 실행파일이 존재하는 디렉터리
2)표준 검색경로:실행 중인 프로세스의 현재 디렉터리
3)표준 검색경로:Windows의 시스템 디렉터리
4)표준 검색경로:Windows 디렉터리
5)표준 검색경로:환경변수 PATH에 의해 지정되어 있는 디렉터리
이렇게 다양한 위치에서 실행파일을 찾고 있어 보통 두 번째 전달인자를 통해 실행파일 이름을 전달.
5_3.cpp WinSysDir.cpp

실습을 위한 환경의 구성 및 실행
실행방법 1 : '2)표준 검색경로'의 활용
변경하는 디렉터리 이름의 디렉터리를 만들고 실행파일을 그 안으로 이동시킨다.
CreateProcess.exe는 어디에 존재하든 상관없다.
프로그램이 실행되면서 현재 디렉터리를 변경하기 때문이다.
실행방법 2 : '1)표준 검색경로'의 활용
"실행 중인 프로세스의 실행파일이 존재하는 디렉터리"
따라서 AddProcess.exe와 CreateProcess.exe를 하나의 디렉터리에 같이 넣어두기만 하면 어디서든 실행가능.

05 프로세스 생성과 관련된 예제 그리고 문제점
5_4.cpp Calculator.cpp
VOID ZeroMemory(
	PVOID Destination, //초기화할 메모리 블록의 포인터
	SIZE_T Length //초기화할 메모리 블록의 크기
);
typedef void* PVOID;
typedef ULONG_PTR SIZE_T, *PSIZE_T;

Windows프로그래머들에게 프로세스 생성이 많이 사용되는 기술은 아니다.
그러나 프로세스를 이해하는 것은 운영체제를 이해하는 데 아주 중요한 요소이며, 아주 유용할 수도 있다.
하지만 위의 예제는 치명적인 단점이 있는데 다음 장에서 보자.

_tprintf함수 호출하면 매크로 _UNICODE의 정의 유무에 따라서 printf나 wprintf함수가 호출된다.
CreateProcess함수도 실제 호출되는 함수의 이름은 CreateProcessA이거나 CreateProcessW이다.
다른 시스템 함수들 역시 이러한 형태로 Unicode를 지원한다.

이것만은 알고 갑시다
1. 프로세스에 대한 이해
실행 중에 있는 프로그램을 프로세스.
Windows는 멀티 프로세스 운영체제로 동시에 둘 이상의 프로세스를 생성할 수 있다.
2. 프로세스의 상태
프로세스가 생성되어 소멸되기까지 겪는 상태의 변화.
3. Context Switching
실행 중인 프로세스가 변경될 때 컨텍스트 스위칭이라는 과정.
현재 실행 중인 프로세스 레지스터 정보를 메모리에 저장하고, 실행하고자 하는 프로세스의 정보를 레지스터에
복원하는 작업을 포함해서, 프로세스별로 관리되어야 하는 데이터의 종류에 따라 그 범위가 결정된다.
시스템에 많은 부담을 주는 작업이다.
4. 프로세스를 생성하는 방법
CreateProcess
				 
*/   