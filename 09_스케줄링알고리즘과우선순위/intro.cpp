/*
CPU에 코어가 여러 개 들어가면 예제를 테스트하기는 더 어려워진다.
보고자 하는 현상을 확인하기가 어려워진다.
운영체제와 시스템 프로그래밍을 공부하기에는 싱글 코어 CPU가 좋다.
코어는 하나인데 실행시킬 프로세스의 수는 둘 이상인 경우가 첫 번째 관심사.

01 프로세스의 Scheduling
대부분의 운영체제는 멀티 프로세스 기반 운영체제이다.
결과적으로 둘 이상의 프로세스 생성을 위한 시스템 함수를 제공한다.
프로세스란 실행되는 하나의 프로그램을 의미하고, 하나의 프로그램이 실행되기 위해서는 하나의 CPU가 필요.
프로세스 수만큼 CPU가 존재할 수 있다면 가장 이상적.
실행 중인 모든 프로세스들에게 골고루 CPU를 할당하는 일이 필요한데, 이 일은 멀티 프로세스를 지원하는
운영체제에서 담당하는 일이다.
운영체제 일부분에 해당하는 스케줄러가 담당하는 일.

일반 OS와 Real Time OS의 차이점
RTOS와 일반 OS의 차이는 응답성(응답속도)에 있다.
RTOS는 응답성이 Windows와 같은 일반 OS보다 좋다.
따라서 우리가 명령하는 일들을 신속히 처리한다.
일반 OS는 범용적인 사용을 위해서 디자인되어 있다.
즉 Windows나 Linux는 특수한 목적이 정해져 있는 OS가 아니다.
그러다 보니 사용자가 시키는 것 이외에도 하는 일이 많다.
반면 RTOS는 사용하는 영역이 제한적이다.
범용적인 OS보다 하는 일이 적다.
프로그래머가 시키지 않으면 일을 하지 않는다.
예를 들어 핸드폰에 들어가는 RTOS는 키를 입력하거나 수신되는 데이터가 없으면 하는 일이 거의 없다.
전력 소모를 줄이기 위해 내부 프로세스의 전력 소모량을 최소화시키기도 한다.(내부 ARM코어에 전달되는 클럭을 차단)
멀티미디어 관련 기능들도 RTOS에서 라이브러리 수준으로 제공하지만, 처리할 수 있는 일은 상당히 제한적이다.
때문에 RTOS는 핸드폰 환경에서 최고의 응답성을 보인다.
즉 사용되는 목적이 구체적이고 제한적이다 보니, 단순하게 디자인되어 있고 일반 OS에 비해 훨씬 가볍다.
따라서 응답성이 좋을 뿐이다.

Embedded Linux는 ROTS가 아니다. 리얼타임의 성격을 지니는 Linux는 상용으로 별도 존재하며, 리얼타임의 성격을
부여하기 위해서 Linux커널을 패치(Patch)하기도 하는데, 결과적으로 Enbedded Linux를 무겁게 하는 결과.

Soft RTOS vs Hard RTOS
위의 RTOS를 가리켜 Soft RTOS라 하고 대부분의 RTOS이다.
그러나 전통적으로 말하는 RTOS는 Hard RTOS를 의미한다.
Hard RTOS에서 중요시하는 것은 단순히 개선된 응답성이 아니라 데드라인(Dead Line)이다.
데드라인은 정말로 시간에 Critical한 상황에서 발생한다.
데드라인이 중요한 시스템에서 이를 충족시킬 수 있는 능력을 지니는 RTOS를 가리켜 Hard RTOS라 한다.
단순히 CPU의 속도가 빠르다고 만족되는 것이 아니며 전혀 다른 알고리즘으로 스케줄러가 디자인된다.

선점형(Preemptive) OS와 비선점형(Non-Preemptive) OS
프로세스의 실행을 다른 프로세스로 넘기는 방식에 따라서 선점형 OS와 비선점형 OS를 구분한다.

비선점형 OS
비선점형 OS는 현재 실행 중인 프로세스보다 높은 우선순위의 프로세스가 등장한다고 해서 실행의 대상을 바로
변경하지 않는다.
새로 등장한, 보다 높은 우선순위의 프로세스가 실행되기 위해서는 현재 실행 중인 프로세스가 명시적으로 CPU를
양보할 때까지, 혹은 I/O작업 등으로 블로킹 상태에 놓일 때까지 기다려야만 한다.
이러한 비선점형 OS의 경우에는 Interactive한 프로그램 구현 시 프로그래머 의존도가 높아지는 문제점.
프로그래머는 자신이 개발한 프로그램이 주구장창 CPU를 독차지하지 않도록 신경을 써서 프로그래밍해야 한다.
과거 Windows 3.x시리즈가 비선점형 OS였다.

오늘날 대부분의 OS는 키보드나 마우스 입력에 민감하게 반응해야 한다.
즉 대화를 계속하면서 그 결과에 따라서 프로그램을 구동하는 것이다.
이러한 시스템을 가리켜 Interactive 시스템이라 한다.

선점형 OS
선점형 OS는 현재 실행 중인 프로세스보다 높은 우선순위의 프로세스가 등장하면 스케줄러에 의한 실행순서 조정이
가해진다.
물론 우선순위가 높은 프로세스가 실행된다.
비선점형 OS에 비해 스케줄러가 하는 일이 많다.
이러한 특성은 둘 이상의 프로세스를 동작시키는 멀티 프로세스 기반 OS에 적합하다.
왜냐하면 스케줄러에 의해 실행순서가 적절히 조절되다 보니 프로그래머가 신경을 쓸 일이 거의 없어진다.
우선순위가 동일한 두 개의 프로세스가 실행 중일 때 스케줄러는 적절히 시간을 나눠서 최대한 동시에 실행되는
효과를 내도록 실행순서를 조절할 것이다.
대부분의 모든 OS는 선점형 OS라 볼 수 있다.
RTOS도 선점형 OS에 포함된다.
Windows에서 채택하고 있는 대표적인 선점형 스케줄링 알고리즘 두 가지를 소개한다.

Priority 스케줄링 알고리즘
각각의 프로세스마다 우선순위를 부여해서 우선순위가 높은 프로세스를 먼저 실행시키는 방식이다.
우선순위가 7인 프로세스와 우선순위가 2인 프로세스를 동시에 실행시키면?
알고리즘이라는 것이 다양하게 디자인 가능하지만 보편적인 운영체제에서 2인 프로세스는 결코 실행되지 않는다.
이러한 상황을 가리켜 Starvation상태라 하는데, 우선순위가 2인 프로세스는 기아 상태에 빠지게 된다.
우선순위가 높은 프로세스가 작업을 마쳐야 그 다음 우선순위의 프로세스가 실행된다.
이러한 관점에서는 우선순위 2인 프로세스는 실행되지 않는다.
하지만 다른 우선순위를 갖는 두 개의 프로세스를 생성해서 특정 메시지를 출력하면 높은 우선순위 프로세스가
I/O관련 작업을 하는 과정에서, 낮은 우선순위 프로세스가 실행 기회를 얻을 수도 있다.
메시지를 출력하는 일도 I/O작업이다.
메시지 출력회수, 메시지 길이 등 환경적인 요인에 따라서 결과는 다양해진다.
의외로 아주 쉽게 낮은 우선순위 프로세스가 실행 기회를 얻을 수도 있다.
대부분의 프로그램이 상당 시간을 I/O에 할애하게끔 되어 있다.
우선순위가 낮은 프로세스도 적은 시간이나마 실행될 확률이 높다.
낮은 우선순위의 프로세스가 Starvation상태에 빠지는 것은 생각보다 드문일이 된다.

Round-Robin 스케줄링 알고리즘
같은 우선순위의 프로세스들간 형평성 유지를 위해, 정해진 시간 간격만큼만 실행을 하고 우선순위가 동일한 다른
프로세스에게 CPU의 할당을 넘기는 방식을 제공한다.
실행의 최소 단위 시간 간격을 퀀텀(Quantum)혹은 타임 슬라이스(Time Slice)라 하는데, 동일한 우선순위의
모든 프로세스들은 이 타임 슬라이스를 기준으로 CPU의 할당을 넘기게 된다.
타임 슬라이스를 어느 정도로 두느냐에 따라 운영체제의 성격이 달리짐.
타임 슬라이스를 길게 하면 인터렉티브한 시스템에서 문제가 될 수 있다.
타임 슬라이스를 너무 짧게 하면 컨텍스트 스위칭이 자주 발생해 성능에 저하를 가져다 준다.
Priority 9 Queue                          |
Priority 8 Queue ──────────> 라운드 로빈   |
Priority 7 Queue ㅁ ㅁ ㅁ ㅁ               |
Priority 6 Queue                          |
Priority 5 Queue ㅁ ㅁ ㅁ ㅁ               |
Priority 4 Queue                          |
Priority 3 Queue                          |
Priority 2 Queue ㅁ ㅁ                     |
Priority 1 Queue                          |우선순위
Priority 0 Queue                          ↓
Windows는 우선순위 기반과 라운드 로빈 기반 알고리즘을 적절히 혼용하여 선점형 운영체제 특성을 나타냄.

스케줄링 알고리즘에 의해서 스케줄링이 진행되는 시점
스케줄러가 언제 동작하는지를 이해하는 것도 중요하다.
1)라운드 로빈 방식의 스케줄링 알고리즘 적용에 대한 관점
정해진 시간이 지나면 다음 프로세스에게 실행순서를 넘겨야 한다. 그런데 실행순서를 넘기기 위해서는 스케줄러가
동작해야 한다. 프로세스의 실행시간 간격에 해당하는 매 타임 슬라이스마다 스케줄러는 동작해야 한다.
2)우선순위 방식의 스케줄링 알고리즘 적용에 대한 관점
우선순위가 높은 프로세스는 무조건 먼저 실행되어야 한다. 따라서 새로운 프로세스가 등장할 때마다 스케줄러는
현재 실행중인 프로세스와 새로운 프로세스를 비교해야 한다. 프로세스가 생성될 때마다 스케줄러는 동작해야 한다.
반대로 현재 실행 중인 프로세스가 종료된다면 다른 프로세스를 실행시켜야 하므로 이 경우에도 스케줄러가 동작.
3)블로킹 상황
현재 실행 중인 프로세스가 블로킹 상태가 되면 다른 프로세스가 대신 실행된다. 따라서 현재 실행 중인 프로세스가
블로킹 상태에 놓이면, 다음 실행될 프로세스 선정을 위해서 스케줄러가 동작한다.
정리해보면
1)매 타임 슬라이스마다 스케줄러 동작
2)프로세스가 생성 및 소멸될 때마다 스케줄러 동작
3)현재 실행 중인 프로세스가 블로킹 상태에 놓일 때마다 스케줄러 동작

Priority Inversion
프로세스의 우선순위가 뒤 바뀌는 현상이다.
A>B>C의 우선순위를 가진 프로세스가 있다고 하자.
프로세스A가 실행중에 갑자기 프로세스 A가 멈췄다.
왜냐하면 프로세스C가 주기로 한 값이 도착하지 않았기 때문.
그래서 프로세스 C가 실행될 수 있도록 A는 Blocked상태에 들어가고 C에게 기회를 준다.
그런데 B가 우선순위가 높아 C를 밀치고 자신이 CPU를 차지한다.
이러지도 저러지도 못하는 상황이되버린다.
해결책은 프로세스A가 프로세스C에게 우선순위를 잠시 위임하고 Blocked상태로 빠지면 B는 넘보지 못할 것이다.
다양한 운영체제가 존재하고, 운영체제별로도 다양한 버전이 존재한다.
제시하는 Priority Inversion해결방법도 다양하다.

02 Windows 프로세스 우선순위
Windows는 6단계의 우선순위 계층을 제공한다.
숫자가 높을 수록 높은 우선순위를 지닌다.
IDLE_PRIORITY_CLASS            기준 우선순위 4
NORMAL_PRIORITY_CLASS          기준 우선순위 9
HIGH_PRIORITY_CLASS            기준 우선순위 13
REALTIME_PRIRITY_CLASS         기준 우선순위 24
ABOVE_NORMAL_PRIORITY_CLASS    NORMAL_PRIORITY_CLASS보다 높고 HIGH_PRIORITY_CLASS보다 낮은 우선순위.
                               단, Windows NT와 Me 이하에서는 지원되지 않는 우선순위.
BELOW_NORMAL_PRIORITY_CLASS    IDLE_PRIORITY_CLAS보다 높고 NORMAL_PRIORITY_CLASS보다 낮은 우선순위.
                               단, Windows NT와 Me 이하에서는 지원되지 않는 우선순위.
프로그램 개발 과정에서 프로세스 우선순위를 조절해야만 하는 상황에 놓이게 되면, 다양한 우선순위를 적용해
봄으로써 가장 적합한 우선순위를 결정하게 된다.
9_1.cpp ABOVE_NORMAL_PRIORITY_CLASS.cpp
Sleep함수는 프로세스의 실행을 멈추는 함수가 아니라 쓰레드의 실행을 멈추는 함수이다.
전달되는 인자의 시간만큼 실행 중인 프로세스를 Blocked상태에 두어 실행을 멈추는 함수.
9_2.cpp NORMAL_PRIORITY_CLASS.cpp
9_3.cpp BELOW_NORMAL_PRIORITY_CLASS.cpp
주의할 것은 우선순위 계층 중에서 ABOVE_NORMAL_PRIORITY_CLASS와 BELOW_NORMAL_PRIORITY_CLASS는 XP이상에서만 지원.
그리고 mp3 파일 하나를 재생시켜 다른 프로세스를 띄어 이 프로세스에 미치는 영향을 소리로 확인해보자.
원래는 우선순위가 가장 높은 프로세스만 실행되어야 하고, 미디어 플레이어도 영향을 받고 있을 것.
우선순위가 가장 높은 프로세스 이외에는 전혀 실행되지 않고 있다는 것이다.
가장 높은 프로세스가 실행되어야 하는 것은 정상이나 실행속도를 위해 Busy Waiting 방식을 취하는 것이 문제다.
실행속도의 조절이 목적이라면 Sleep함수의 호출을 통해 Blocked상태로 만드는 것이 훨씬 좋은 방법이다.
잠시이긴 하지만 자신보다 우선순위가 낮거나 같은 프로세스에게 기회를 넘겨주기 때문이다.
이러한 방식으로 프로그래밍을 해야만 CPU를 보다 효율적으로 사용할 수 있게 된다.
busy waiting코드를 주석처리하고 Sleep함수를 실행해보자.
다양한 우선순위의 프로세스가 골고루 실행될 것이다.

이것만은 알고 갑시다
1. 응답성 관점에서 RTOS와 일반 OS의 구분
속도와는 별도로 응답성의 관점에서 둘을 구분해야 한다. 응답성이 좋다는 것은 새로운 일의 실행을 지시했을 때
그 일을 시작하기까지 걸리는 시간이 아주 적음을 의미한다. 응답성이 좋으면 RTOS다. 그런데 일반적으로 응답성이
좋으면 둘 이상의 일을 동시에 처리하는 멀티 프로세스의 성격이 약하다.
2. 선점형 OS와 비선점형 OS의 특징
프로세스의 실행을 다른 프로세스로 넘기는 방식에 따라 나뉜다. 선점형 OS는 현재 실행 중인 프로세스보다 높은
우선순위의 프로세스가 등장하면 그 순간 바로 실행 중인 프로세스를 변경해 버린다.
그러나 비선점형 OS는 우선 순위가 높은 프로세스가 등장하더라도 현재 실행 중인 프로세스가 일을 넘기지 않으면
프로세스의 실행이 이동하지 않는다.
3. 스케줄러가 동작하는 세 가지 시기
1)매 타임 슬라이스(Time Slice)마다
2)프로세스가 생성 및 소멸될 때마다
3)현재 실행 중인 프로세스가 블로킹 상태에 놓일 때마다

*/