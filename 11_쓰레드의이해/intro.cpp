/*
쓰레드를 말할 땐 최대한 겸손해지자.
"개발자로서 프로그래밍에 재미를 느낄 때는 쓰레드 기반으로 기막히게 놓은 프로그램이 별문제 없이 돌아갈 떄이고,
회의를 느낄 때는 멀티 쓰레드 기반 코드를 디버깅 할 때."
"반드시 멀티 쓰레드 기반으로 가야만 할 이유가 없어 보이는데요?"

01 쓰레드란 무엇인가?
멀티 프로세스 기반 프로그램
둘 이상의 서로 다른 프로그램 실행을 위해서 둘 이상의 프로세스를 생성하는 것은 지극히 당연한 일이다.
그러나 하나의 프로그램이 두 가지 이상의 일을 동시에 처리하기 위해서도 둘 이상의 프로세스가 필요하다.
서버란 서비스 제공을 위해 동작하는 프로그램.
일반 사용자는 서버 접속용 클라이언트 프로그램을 이용해서 서버에 접속하고, 특정 서비스를 요구한다.
서버는 이러한 요구를 처리하기 위해서 요청이 있을 때마다 자식 프로세스를 생성한다.
동시에 둘 이상의 접속자에게 원활한 서비스를 제공해주기 위함.
하나의 프로그램 내에서 여러 개의 실행 흐름을 찾을 수 있다.
프로그램 내 실행 흐름을 다양화하기 위해서, 하나의 프로그램에서 둘 이상의 프로세스를 생성하는 일은 빈번해졌다.

멀티 프로세스 운영체제 기반 프로그램의 문제점과 새로운 제안
두 가지 이상의 일을 동시에 처리학 위해서나 둘 이상의 실행 흐름이 필요해서 추가적으로 프로세스를 생성하는 작업은
상당히 부담스럽다.
하나의 프로그램이 둘 이상의 프로세스 생성을 요구한다면 정말 부담스럽다.
많은 수의 프로세스 생성은 빈번한 Context Switching으로 이어져 성능에 영향을 미치기 때문이다.
컨텍스트 스위칭은 프로세스의 상태 정보를 저장하고 복원하는 일련의 과정이다.
컨텍스트 스위칭은 성능 저하의 원인이 된다.
이를 위해선 저장하고 복원하는 컨텍스트 정보의 개수를 줄여주면 된다.
컨텍스트 정보란 프로세스의 상태 정보와 관련이 있으므로 결국은 프로세스 상태 정보를 줄여야 한다.
컨텍스트 스위칭이 필요한 가장 근본적인 이유는 프로세스들이 서로 완전히 독립되기 때문이다.
부모 자식 관계가 있더라도 일단 생성되면 완전히 별개의 프로세스이다.
따라서 A프로세스가 실행을 멈추고 B프로세스에게 실행 기회를 주기 위해서는 완전히 자리를 내줘야 한다.
CPU뿐 아니라 메모리까지 B프로세스가 100%사용할 수 있도록 완전히 자리를 내줘야만 한다.
그래서 오래 걸리는 컨텍스트 스위칭이 필요한 것이다.
이를 위해 어느 정도는 공유하는 구조라면 컨텍스트 스위칭도 줄어든다는 생각을 기반으로 쓰레드라는 것이 나옴.

해결책, 쓰레드
완전히 별개의 프로그램을 동시 실행하기 위해서는 어쩔 수 없이 독립된 프로세스 구조가 필요하다.
하지만, 하나의 프로그램 내에서 둘 이상의 실행 흐름을 두기 위해서, 모든 것을 독립시키는 구조로 갈 필욘없다.
프로세스는 완전히 독립된 두 개의 프로그램 실행을 위해서 사용된다.
그러나 쓰레드는 하나의 프로그램 내에서 둘 이상의 프로그램 흐름을 만들어 내기 위해서 디자인된 것.
그리고 프로세스와 달리 쓰레드 간에는 공유하는 생태 정보들이 있다.
이것이 쓰레드의 컨텍스트 스위칭을 빠르게 하는 요인이 된다.
정리해보면
1)쓰레드는 하나의 프로그램 내에서 여러 개의 실행 흐름을 두기 위한 모델이다.
2)쓰레드는 프로세스처럼 완벽히 독립적인 구조가 아니고 쓰레드들 사이에는 공유하는 요소들이 있다.
3)쓰레드는 공유하는 요소가 있는 관계로 컨텍스트 스위칭에 걸리는 시간이 프로세스보다 짧다.

메모리 구조 관점에서 본 프로세스와 쓰레드
프로세스와 쓰레드의 차이점을 이해하는 가장 좋은 방법은 메모리 구조 관점에서 비교하는 것이다.
자식프로세스A <──생성── 부모프로세스 ──생성──> 자식프로세스B
Code                   Code                 Code
Data                   Data                 Data
Heap                   Heap                 Heap
Stack                  Stack                Stack
자식 프로세스가 생성되고 난 다음에는 모든 것이 부모 프로세스와 독립적이다.
물론 부모 프로세스는 자신이 가지고 있는 핸들 테이블을 상속하는 등 부모로서의 역할에 충실하지만,
이것은 생성되는 과정에서 발생하는 일.
메모리 구조상에서 보면 생성 이후에는 아무런 관계가 없다.
이러한 메모리 구조를 지녔기 때문에 프로세스간에 데이터를 주고 받기 위해서 IPC가 필요했던 것.
쓰레드A          부모프로세스           쓰레드B
Code   <──공유── Code        ──공유──> Code
Data   <──공유── Data        ──공유──> Data
Heap   <──공유── Heap        ──공유──> Heap
A thread Stack   Stack                 B thread Stack
쓰레드를 생성할 때마다, 해당 쓰레드만을 위한 스택을 생성할 뿐 그 이외의 영역은 프로세스 영역을 공유하고 있다.

쓰레드의 특성 1 : 쓰레드마다 스택을 독립적으로 할당해 준다.
프로세스와 마찬가지로 쓰레드도 독립적으로 스택을 할당한다.
스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위한 메모리 공간.
즉 함수 호출 시 필요한 메모리 영역이다.
메모리 공간이 독립적이라는 뜻은 추가적인 실행 흐름을 만들 수 있다는 의미.
즉, 실행 흐름의 추가를 위한 최소 조건이 독립된 스택의 제공이다.

쓰레드의 특성 2 : 코드 영역을 공유한다.
프로세스 A는 프로세스 B에 있는 함수를 호출하는 것은 불가능하다.
하지만 쓰레드는 자신을 생성한 프로세스가 가지고 있는 함수를 호출할 수 있다.
왜냐하면 코드 영역을 공유하기 때문.
프로세스 & 쓰레드
main            ┐  
add             │
minus           │code
divide          │
multiple        │
A thread's main │
B thread's main ┘
프로세스이므로 프로그램 흐름의 시작인 main함수가 있다.
그리고 이 영역에 또 다른 실행 흐름을 의미하는 쓰레드의 main함수가 있다.
이 쓰레드 main함수는 코드 영역에 존재하는 모든 함수를 호출할 수 있다.
결과적으로 프로그램의 흐름은 총 세 개가 된다.
그렇다고 시작과 동시에 총 3개의 흐름을 형성하는 것은 아니다.
마치 자식 프로세스를 생성하는 부모 프로세스처럼, 쓰레드 생성을 위해 마련된 함수 호출을 통해서 쓰레드를 생성한다.

쓰레드의 특성 3 : 데이터 영역과 힙을 공유한다.
IPC가 필요없어졌다.
쓰레드간에 힙과 데이터 영역을 공유하기 때문에 쓰레드 A가 접근할 수 있는 힙과 데이터 영역은 쓰레드 B도 접근할 수.
따라서 힙이나 데이터 영역에 메모리 공간을 할당해서 서로 통신하는 것이 가능하다.
즉, 전역변수와 malloc함수를 통해서 동적할당된 메모리 공간은 공유가 가능하다.
main            ┐
add             │
minus           │code
divide          │
multiple        │
A thread's main │
B thread's main ┘
|              | data
|              | heap
|A thread Stack| |프로세스 Stack| |B thread Stack| 

사실 메모리 영역을 공유하다 보면 문제가 발생할수도 있기 때문에 주의해야 한다.

Windows에서의 프로세스와 쓰레드
쓰레드도 CPU의 시간을 할당받아서 실행되기 때문에 쓰레드 스케줄러의 존재도 있다.
내부 커널의 구현 원리에 따라서 나뉘게 된다.
Windows입장에서 프로세스는 단순히 쓰레드를 담는 상자에 지나지 않는다.
때문에 실제 프로그램의 흐름을 형성하는 것은 쓰레드이다.
사실 Windows운영체제에 있어서 프로세스는 상태(Running, Ready, Blocked)를 지니지 않는다.
상태를 지니는 것은 프로세스가 아니라 쓰레드이다.
뿐만아니라, 스케줄러가 실행의 단위로 선택하는 것도 프로세스가 아닌 쓰레드이다.
즉 Windows에 있어서 실행의 중심에 있는 것은 프로세스가 아닌 쓰레드이다.
프로세스A┐
쓰레드   │
쓰레드   │    스케줄러는 다섯 개의 쓰레드가 있다고 생각한다.
쓰레드   ┘
프로세스B┐
쓰레드   │ 
쓰레드   ┘
프로세스 B안에 두 개의 쓰레드가 존재하고 하나의 프로세스 내에 존재하므로 별개의 쓰레드가 아니다.
둘 사이에서 발생하는 컨텍스트 스위칭은 프로세스의 컨텍스트 스위칭에 비교해서 훨씬빠르다.
그러나 프로세스 A의 쓰레드가 실행되는 도중에 프로세스 B의 쓰레드로 실행을 옮기는 과정에서 발생하는
컨텍스트 스위칭은 프로세스 컨텍스트 스위칭과 다를 바가 없다.
자신이 속해있는 프로세스 영역이 다르면 공유하는 영역이 있을 수 없기 때문.
보통 Windows에서도 프로세스 컨텍스트 스위칭이 존재한다고 얘기한다.
서로 다른 프로세스 내에 존재하는 쓰레드들 사이에서 발생하는 컨텍스트 스위칭을 의미하는 것.
프로세스간 컨텍스트 스위칭과 동일한 부담을 시스템에 안겨 준다.
Windows에서는 쓰레드가 존재하지 않는 프로세스란 있을 수 없다.
프로세스 생성과 동시에 main함수를 호출해 줄 쓰레드를 생성한다.
프로세스 내에서 기본적으로 생성되는 쓰레드에 의해서 main함수가 호출되었던 것.
이러한 쓰레드를 가리켜 main쓰레드라고 부르며 일반적으로 프로그래머에 의해 직접적으로 생성되는
쓰레드와 구분지어 말한다.

컨텍스트 스위칭이 빨라진 쓰레드
하나의 프로세스 내에 존재하는 쓰레드들 사이에서는 상당한 영역을 공유하게 되고, 따라서 컨텍스트 스위칭 시간이
빨라진다고 했다.
모든 운영체제마다 컨텍스트 스위칭 대상이 100%일치하는 것도 아니고 새로운 버전 계속 나오고 있다.
프로세스 컨텍스트 스위칭의 경우라면 sp, fp, pc값을 저장 및 복원해야 한다.
pc는 프로그램의 실행 흐름과 관련이 있다.
쓰레들 별로 main함수를 독립적으로 가지고 있고, 또 함수의 호출도 독립적으로 진행되기 때문에 쓰레드별로
main함수를 독립적으로 가지고 있고, 또 함수의 호출도 독립적으로 진행되기 때문에 쓰레드별로 현재 pc가 가져야
할 값은 다르기 마련이다.
코드 영역을 공유함으로 인해 호출할 수 있는 함수들을 공유하게 되는 것이지, pc정보까지 공유하지 않는다.
쓰레드라 하더라도 fp와 sp레지스터 정보들 공유가 불가능하다.
스택은 어차피 쓰레드별로 독립적이다.
따라서 스택의 정보를 저장하는데 사용되는 fp와 sp가 공유하지 않는다.
범용 레지스터들은 연산을 위해서 임시적으로 사용되는 것이 보통이다.
연산결과를 저장하거나 메모리에 저장된 데이터를 이동시키거나 할 때 사용되는 것이 범용 레지스터들.
연산도 프로그램의 흐름에 따라 진행되는 것이므로 공유하기는 쉽지 않다. 가능성은 존재한다.
범용레지스터가 많고, 이들 중 일부는 전역으로 선언된 변수를 위해 할당하기로 결정했다면, 쓰레드의 컨텍스트
스위칭 시 전혀 영향을 받지 않을 것이다.
왜냐하면 데이터 영역은 공유되기 때문.
그러나 시스템을 어떻게 디자인 하느냐에 따라 달라지므로 일반적으로 언급하기 어렵다.
빨라지는 것을 레지스터에서만 답을 찾으면 곤란하고 메모리 관리 측면에서 봐보자.
캐쉬는 CPU엣 한 번 이상 읽어 들인 메인 메모리의 데이터를 저장하고 있다가 CPU가 다시 그 메모리에 저장된
데이터를 요구할 때, 메인 메모리를 통하지 않고 바로 값을 전달해주는 용도이다.
개념적으로는 캐쉬는 CPU와 메인 메모리 사이에 존재.
캐쉬가 성능에 미치는 영향은 크다.
캐쉬 메모리는 용량도 중요하지만 캐쉬 메모리를 운영하는 데 필요한 알고리즘도 중요하다.
프로세스 컨텍스트 스위칭이 일어나면 캐쉬가 지금껏 저장해 놓은 데이터들은 한 순간에 무너지고 새로운 기준으로
다시금 캐쉬 정보를 쌓아 올려야만 한다.
왜나하면 프로세스 사이에서 공유하는 메모리가 하나도 없기 때문이다.
이것이 프로세스 컨텍스트 스위칭에 부담이 되는 요소 중 하나이다.
반면 쓰레드라면 캐쉬를 비울 필요가 없다.
A쓰레드가 요구하는 0x1300번지의 데이터는 B쓰레드가 요구하는 0x1300번지 데이터와 동일하다.
즉 A쓰레드 실행 시 저장된 캐쉬 데이터를 B쓰레드 입장에서도 의미를 지닌다.

진작에 그렇게 이야기하지
쓰레드가 입출력에 관련된 연산을 할 경우 Blocked상태에 놓이게 된다.
입출력 관련된 연산이 끝나면서 Ready상태가 되고, 그 다음 스케줄러에 의해서 선택이 되면 Running상태가 된다.
Windows의 경우 실제 우선순위나 라운드로빈 알고리즘을 적용하는 대상은 프로세스가 아닌 쓰레드이다.

02 쓰레드 구현 모델에 따른 구분
Kernel Level 쓰레드와 User Level 쓰레드
쓰레드를 생성해 주는 대상은 커널일 수 있다.
이러한 경우 운영체제가 제공하는 시스템 함수 호출을 통해 쓰레드 생성을 요구해야 한다.
그러면 운영체제는 해당 쓰레드를 생성 및 관리하면서 새로운 흐름을 형성하도록 도와준다.
우리가 알고 있는 쓰레드를 커널에 의해 제공되는 쓰레드 모델이다.
이렇듯 프로그래머 요청에 따라 쓰레드를 생성 및 스케줄링하는 주체가 커널인 경우, Kernel Level쓰레드라 한다.
커널 레벨에서 쓰레드가 지원된다는 뜻.
유저 영역──────────────────┐
│프로세스────────┐프로세스─┐│
││쓰레드A 쓰레드B│ │쓰레드C││
│└──────────────┘ └──────┘│
└─────────────────────────┘
커널 영역──────────────┐
│스케줄러 ↔ 쓰레드A정보 │  스케줄러 → 쓰레드A
│           쓰레드B정보│           → 쓰레드B
│           쓰레드C정보│           → 쓰레드C
│    		...       │
└─────────────────────┘
유저영역은 사용자에 의해서 할당되는 메모리 공간을 의미한다.
이중에서 일부는 프로그램 코드를 올리는 데 사용되고, 또 일부는 실행하는 과정에서 변수 선언이나 메모리의
동적 할당 등의 용도로 사용된다.
이렇게 프로그램이 동작하기 위해 사용되는 메모리 공간은 가리켜 유저영역이라 한다.
즉 코드 영역, 데이터 영역, 스택 및 영역을 가리켜 유저영역이라 한다.
하나의 프로세스에게 할당된 총 메모리 공간 중에서 유저 영역을 제외한 나머지 영역을 커널 영역이라 한다.
운영체제가 실행되기 위해서는 운영체제도 메모리에 올라가야 하고, 또 일반 프로그램처럼 실행되는 과정에서 변수 
선언도 하고 메모리를 동적 할당하기도 한다.
이렇게 운영체제라는 하나의 소프트웨어를 실행시키기 위해서 필요한 메모리 공간을 커널 영역이라 한다.
일반 프로그램을 실행시키기 위해서 필요한 메모리 공간과 운영체제의 실행을 위한 메모리 공간을 분리시켜 놓지 않으면
관리하는 측면에서 곤란을 겪을 수 있다.
과거 32비트 Windows운영체제에서는 총 4G메모리(가상메모리) 영역 중에서 2G를 유저 영역으로, 나머지 2G를 커널
영역으로 활용하였다.
오늘날 64비트 운영체제에서는 총 16T메모리를 프로세스에게 할당하고 있으며, 유저영역과 커널은 각각 8T씩 할당.
쓰레드에게 일을 시키기 위한 프로그램 코드는 프로그래머가 개발하므로 쓰레드A,B,C의 실행코드는 유저 영역.
그러나 스케줄러와 쓰레드 정보(스케줄링을 하는데 필요한 쓰레드 정보)는 커널 영역에 존재한다.
이것이 바로 커널 레벨 쓰레드의 유형이다.
오늘날 대부분의 운영체제는 커널 레벨 쓰레드를 기반으로 쓰레드 모델을 지원한다.

두 번째 경우로, 유저 레벨 쓰레드 모델이다.
멀티 프로세스 운영체제라고 해서 커널이 기본적으로 쓰레드를 지원하는 것은 아니다.
과거 UNIX에서는 비록 멀티 프로세스 운영체제이긴 하나 쓰레드를 지원하지 않았다.
유저 레벨 쓰레드가 과거의 모델로 생각하면 안되고 각각 장단점이 있다.
이렇듯 커널에서 쓰레드 기능을 지원하지 않을 때 생각해 볼 수 있는 것이 유저 레벨 쓰레드이다.
커널이 쓰레드 모델을 제공하지 않을 경우(혹은 커널이 제공하는 쓰레드 모델이 마음에 들지 않은 경우), 커널에
의존적이지 않은 형태로 쓰레드의 기능을 제공하는 라이브러리를 활용할 수 있는데, 이러한 방식으로 제공되는
쓰레드가 유저 레벨 쓰레드이다.
커널에서 제공하는 기능이 아니므로 당연히 실행 시 유저 영역에서 실행된다.
유저 레벨 쓰레드와 커널 레벨 쓰레드는 기능의 제공 주체가 누구냐에 달려 있다.
유저 영역─────────────────────────────────┐
│프로세스A──────────┐ 프로세스B───────────┐│
││쓰레드A 쓰레드A정보│ │쓰레드C 쓰레드C정보││
││쓰레드B 쓰레드B정보│ │                  ││
│└─────────────────┘  └─────────────────┘│
└────────────────────────────────────────┘
커널 영역────────────────┐
│스케줄러 ↔ 프로세스A정보 │  스케줄러 → 프로세스A
│           프로세스B정보│           → 프로세스B
│           프로세스C정보│          
│    		...         │
└───────────────────────┘
쓰레드를 지원하지 않기 때문에 스케줄러가 스케줄링하는 대상은 프로세스이다.
그리고 쓰레드를 스케줄링하는 스케줄러는 유저 영역에서 실행된다.
커널에는 쓰레드에 대한 아무런 정보도 존재하지 않는다.
운영체제는 쓰레드의 존재를 알지도 확인하지도 못한다.

Hybrid쓰레드 모델이라는 것도 있다. 이는 유저레벨 쓰레드와 커널레벨 쓰레드의 중간 정도에 해당하는 모델로서
각각의 장점만을 모아서 디자인된 쓰레드 모델이다.

커널 영역
CPU입장에서 보면 운영체제 역시 메모리에 올라가 실행되는 프로그램에 지나지 않는다.
운영체제는 일부 CPU에 종속적인 부분을 제외하고는 C언어로 구현되어 있다. 그러므로 함수가 존재한다.
함수가 있으므로 호출 시 전달되는 인자와 함수 내에서 선언한 지역변수는 스택에 저장된다.
코드 영역과 전역변수 선언도 당연히 존재한다.
|유저 영역| 프로그램 실행 시 사용하게 되는 메모리    ┐
|커널 영역| 운영체제가 내부적으로 사용하게 되는 메모리┘프로세스에 할당되는 총 메모리.
프로그램 구현 시 커널 영역이 아닌 유저 영역에 메모리를 할당하기 위해서 고민할 필요가 없다.
기본적으로 선언하는 변수나 동적으로 할당하는 메모리도 유저 영역에 할당된다.
그러나 C언어는 메모리 접근이 용이하다보니 잘못사용하면 커널 영역의 주소값을 가지고 메모리에 접근하는 실수도 있다.
이런 일이 발생하면 정말 큰일이 일어나고, 대혼란을 막기 위해 Windows는 유저모드와 커널모드라는 두 가지 모드를
제안하게 된다.

Kernel Mode와 User Mode
Windows는 동작할 때 커널 모드와 유저 모드 중 한가지 모드로 동작한다.
"메모리는 활용 대상에 따라서 유저 영역과 커널 영역으로 나뉜다. 유저 영역은 사용자가 구현한 프로그램 동작 시
사용하게 되는 메모리 영역이고, 커널 영역은 운영체제 동작 시 사용하게 되는 메모리 영역이다. 그리고 커널이
쓰레드를 지원할 경우 쓰레드 관리가 커널 영역에서 이뤄지기 때문에 커널 레벨 쓰레드 모델이라 하고, 커널이 지원하지
않을 경우에 라이브러리를 통해 제공받아야 하는데 이런 경우에는 유저 영역에서 쓰레드의 관리가 이뤄지기 때문에
유저 레벨 쓰레드 모델이라 한다."
커널 영역은 유저 영역에 비해 상대적으로 중요하다.
유저 영역에서 메모리 참조 오류가 발생하면 프로그램에만 영향을 미치지만 커널 영역은 커널의 코드가 실행되는
영역이므로 시스템 전체에 문제를 일으킬 수도 있는 일이다.
C언어의 특성상 메모리 참조가 용이하기 때문에 C언어로 프로그램을 구현할 경우 이에 대한 보장을 할 수 없게 된다.
안전성 제공 측면에서 등장한 것이 커널모드와 유저 모드이다.
일반적인 프로그램은 기본적으로 유저 모드에서 동작한다.
그러다가 Windows커널이 실행되어야 하는 경우에는 커널 모드로의 전환이 일어난다.
커널 영역에서 실행이 이뤄져야 할 경우에는 커널 모드로의 전환이 일어나는 것이다.
여러 개의 프로세스들이 실행 중에 있을 때 정해진 타임 슬라이스가 지나 스케줄러가 동작하려 할 때 커널 모드로의
전환이 일어난다.
왜냐하면 스케줄러는 커널의 일부에 해당하기 때문이다.
이러한 스케줄러가 동작하려면 커널 모드로의 전환이 필수이다.
프로세스가 유저 모드에서 동작할 때에는 커널 영역으로의 접근이 금지된다.
즉 뜻하지 않게 유저 모드에서 시행 중인 프로그램이 커널 영역으로 접근을 시도하면 시스템에서 오류가 발생했음을
알리고 접근을 원천적으로 봉쇄한다.
반면에 커널 모드에서 동작할 때에는 모든 영역의 접근이 허용된다.
|유저 영역| 유저 모드에서 접근 가능 ┐
|커널 영역| 유저 모드에서 접근 불가 ┘커널 모드에서 전부 접근 가능.
Windows에서 운영체제 차원에서 제공하는 시스템 함수들 중 일부는 호출 시 커널 모드로 동작할 수 있다.
시스템 함수들 중 상당수가 커널의 구동을 필요로 한다.
따라서 이러한 함수들을 호출할 때마다 모드의 전환이 발생하는데, 이러한 모드의 전환은 시스템에 부담을 주는
일이므로 상황에 따른 적절한 반영이 요구된다.
"모드의 전환(커널 모드 유저 모드)은 시스템에 부담을 주는 일이다"
유저모드와 커널모드를 제공하는 것은 Process이다.
메모리 보호 기능은 CPU에 달려있다.

커널 레벨 쓰레드와 유저 레벨 쓰레드의 장점 및 단점
커널 레벨 쓰레드의 장점 및 단점
장점:커널에서 직접 제공해 주기 때문에 안전성과 다양한 기능성이 제공된다.
단점:커널에서 제공해 주는 기능이기 때문에 유저 모드에서 커널 모드로의 전환이 빈번하게 일어난다.
이는 성능의 저하로 이어진다.
유저 레벨 쓰레드의 장점 및 단점
장점:커널은 쓰레드의 존재조차 모른다. 오로지 유저 모드로 동작하기 때문에 유저모드에서 커널 모드로의 전환이
필요없다. 그래서 성능이 좋다.
단점:하나의 프로세스 내에 총 3개의 쓰레드 A,B,C가 있다고하면 A쓰레드가 시스템 함수를 호출했는데 커널에 의해서
블로킹 되었다고 하자. 그러면 B,C도 실행되지 않는다. 운영체제는 프로세스의 존재만 알지 쓰레드의 존재를 모른다. 
때문에 A쓰레드가 속해 있는 프로세스 전부가 블로킹되는 문제를 안고 있다. 이를 해결하기 위한 방법이 여러개가 있지만
결국은 프로그래밍이 어려워지고 커널 레벨 쓰레드에 비해 결과 예측이 어렵게 된다.

분명 속도 향상이라는 유저레벨 쓰레드의 장점이 있다.
때문에 Windows개발자들과 달리 Linux개발자들은 라이브러리를 통한 유저 레벨 쓰레드를 활용한다.

이것만은 알고 갑시다
1. 프로세스와 쓰레드의 차이점
프로세스는 메모리를 공유하지 않지만, 프로세스 내에 존재하는 둘 이상의 쓰레드들은 스택을 제외한 나머지
메모리 공간을 공유한다.
2. 커널 영역 vs 유저 영역
메모리 공간은 커널 영역과 유저 영역으로 나뉜다. 커널 영역은 커널이 올라가 있으며, 커널의 실행을 위한 메모리
영역이고, 유저 영역은 운영체제 이외의 프로그램이 올라가 있으며, 이 프로그램들의 실행을 위한 메모리 영역이다.
3. 커널 모드 vs 유저 모드
커널 영역의 보호를 위해 커널 모드와 유저모드라는 것을 정의한다. 일반적인 응용 프로그램이 실행될 때 시스템은
유저 모드 상태에 있다. 이 경우 제한된 영역의 메모리 접근만 허용한다. 커널 영역을 보호하기 위해서.
그러나 커널 모드에서는 메모리 전 영역의 접근을 허용한다. 따라서 커널은 커널모드에서 동작한다.
4. 커널 레벨 쓰레드 vs 유저 레벨 쓰레드
쓰레드를 지원하는 운영체제의 기능을 통해 생성된 쓰레드를 가리켜 커널 레벨 쓰레드라 하고, 라이브러리 형태로
제공되는 기능을 통해서 생성된 쓰레드를 가리켜 유저 레벨 쓰레드라 한다.

*/