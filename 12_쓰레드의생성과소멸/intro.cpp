/*
01 Windows에서의 쓰레드 생성과 소멸
쓰레드의 생성
Windows에서 사용할 수 있는 가장 기본적인 쓰레드 생성 함수는 CreateThread이다.
HANDLE CreateThread(
	LPSECURITY_ATTRIBUTES lpThreadAttributes, 1)
	SIZE_T dwStackSize, 2)
	LPTHREAD_START_ROUTINE lpStartAddress, 3)
	LPVOID lpParameter, 4)
	DWORD dwCreationFlags, 5)
	LPDWROD lpThreadId 6)
);
Ifthe function fails, the return value is NULL. 7)
1)lpThreadAttributes:이 매개변수를 통해 핸들의 상속 여부를 결정하였다. NULL이 전달되면 생성되는 핸들은
자식 프로세스 생성 시 상속 대상에서 제외된ㄷ.
2)dwStackSize:생성되는 쓰레드의 스택 크기를 지정하기 위한 매개변수. 0이면 디폴트 스택크기인 1MB가 적용.
3)lpStartAddress:쓰레드로 동작하기 위한 함수로 쓰레드의 main역할을 하는 함수를 지정하는 전달인자이다.
typedef DWORD (WINAPI *PTHREAD_START_ROUTINE)(LPVOID lpThreadParameter);
typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;
따라서 반환 타입이 DWORD이고 매개변수 타입은 LPVOID(void*)형태로 함수가 정의되어야 한다.
4)lpParameter:쓰레드 함수에 전달할 인자를 지정하는 용도로 사용된다. 매개변수 lpStartAddress가 가리키는 함수
호출 시 전달할 인자를 지정하는 것. main함수에서 argv로 문자열이 전달되는 것과 유사하다.
5)dwCreationFlags:쓰레드의 생성 및 실행을 조절하기 위해 사용되는 전달인자이다.
인자로 CREATE_SUSPENDED가 전달되면, 쓰레드는 생성과 동시에 Blocked상태에 놓이게 된다. 그러나 함수 ResumeThread가
호출되면 실행을 시작한다. 그리고 XP이상에서는 인자로 STACK_SIZE_PARAM_IS_A_RESERVATION을 전달할 수 있는데,
dwStackSize를 통해 전달되는 값의 크기는 reserve메모리 크기를 의미하게 되고,그렇지 않으면 commit메모리 크기를
의미하게 된다.
6)lpThreadId:쓰레드 ID를 전달받기 위한 변수의 주소값을 전달한다. 필요없다면 NULL사용. ME이하 버전에서는
NULL을 전달할 수 없어서 범용적인 사용을 위해서라도 주소값을 전달하는 것이 일반적이다.
7)함수 호출이 성공하면 생성된 쓰레드의 핸들이 반환된다.

쓰레드의 개수는 메모리가 허용하는 만큼 만들 수 있다.
쓰레드가 생성될 때마다 독립된 스택을 할당해 줘야만 한다.
즉 스택을 할당할 수 있을 때까지 쓰레드의 생성을 허용한다.
12_1.cpp CountThread.cpp

쓰레드의 생성과 흐름의 진행과정
         ┌───────────스케줄러──────────────┐
프로세스─────────────────────────────────────────┐
│        │              ↓                 │     │
│   ┌────┘         main thread            │     │
│   │                   │CreateThread     ↓     │
│   ↓       CreateThread│─────────────> thead A │
│thread B <─────────────│                 │     │
│   │                   │                 │     │
│   │                   │                 │     │
│return 0            return 0         return 0  │
│쓰레드 종료        프로세스 종료       쓰레드 종료│
└───────────────────────────────────────────────┘
main쓰레드나 main쓰레드가 생성한 쓰레드나 동일하지만 main쓰레드의 return은 다른 의미를 지닌다.
main쓰레드는 프로세슷 전체를 대표한다.
따라서 main쓰레드의 return문은 프로세스 종료로 이어진다.
쓰레드를 담고 있는 프로세스가 사라지면 그 안에 쓰레드들도 작업을 마치기도 전에 사라져 버리고 만다.
생성된 쓰레드의 return문은 return을 실행한 쓰레드의 종료를 의미한다.
여러 가지 쓰레드 종료방법이 있지만 return을 통한 쓰레드의 종료가 가장 권장하는 방법이다.

만약 MAXIMUM THREAD SIZE:2024결과가 나오면 쓰레드 개수가 2024개인 것이다.
그러면 시스템의 User영역 크기가 2G정도된다.
printf함수와 쓰레드생성 중 어느 것이 먼저 호출될지는 아무도 알 수 없다.
확률적으로 쓰레드 생성이 시스템 리소스를 더 많이 필요해서 printf가 먼저 호출될 것으로 예측정도 할 수 있다.
쓰레드의 흐름을 예측한다는 것은 불가능하다.
시스템의 당시 상황에 따라서 다르게 동작하기 때문에 예측 자체가 의미가 없다.
스택사이즈를 늘리면 쓰레드 개수가 줄어들 것이다.
디폴트 스택 크기는 쓰레드에서 필요로 하는 최소한의 스택 크기로 생각해 볼 수 있다.
너무 작은 스택 크기를 요구할 경우 무조건 1M바이트로 사이즈를 지정해버린다.
운영체제는 프로그래머에게 모든 것을 맡기지 않는다.
요구사항이 불합리하거나 시스템이 가지고 있는 제한사항 때문에 문제가 될 경우 적절한 수위로 조절을 한다.
VOID Sleep(
	DWORD dwMilliseconds 1)
);
1)dwMilliseconds:쓰레드의 실행을 멈추기 위한 시간 정보를 ms단위로 지정한다. 0을 인자로 전달할 경우
자신에게 현재 할당된 타임 슬라이스를 포기하고 우선순위가 같은 다른 쓰레드에게 실행의 기회를 양보한다.
만약에 우선순위가 같은 쓰레드가 존재하지 않는다면 바로 이어서 실행을 재개한다.

쓰레드의 소멸
쓰레드 함수 내에서 return 문을 통해 종료 및 소멸시키는 방법이 가장 이상적이다.
그래도 최선의 방법은 존재하지 않아 return이외의 방법이 더 적절한 상황도 있을 수 있다.
가능한 다양한 방법에 대해서 이해하고 필요한 상황에 대한 시나리오를 머리 속에 넣어두는 것이 필요하다.

case 1 : 쓰레드 종료 시 return을 이용하면 좋은 경우(거의 대부분의 경우)
예를 들어 1부터 10까지 더하는 작업이 있다.
그리고 이 일은 외부로부터 입출력 작업이 아주 많이 요구되서 Blocked상태에 자주 놓이게 된다.
따라서 이 작업을 조금이라도 빨리 끝내기 위해 총 세 개의 쓰레드를 생성해 일의 부담을 나눈다고 하자.
이러면 정해진 시간 동안에 CPU에게 보다 많은 일을 시킬 수 있고, Blocked상태에 놓이는 상황도 세 개의
쓰레드가 나눠서 감당하기 때문에 속도가 높아질 확률이 높다.
          main thread
       6↗     ↑22     ↖27
thread A   thread B   thread C
1~3합      4~7합      7~10합
쓰레드가 할 일은 두 개의 숫자를 전달해주면 그 사이에 있는 값들의 합을 계산해주면 된다.
12_2 12_3.cpp ThreadAdderOne.cpp
BOOL GetExitCodeThread(
	HANDLE hThread, 1)
	LPDWORD lpExitCode 2)
);
If the function fails, the return value is zero.
1)hThread:종료코드를 얻기 위한 쓰레드의 핸들을 인자로 전달한다.
2)lpExitCode:얻게 되는 종료코드를 저장할 메모리의 주소값을 전달한다.
쓰레드 기반으로 처리하는 것이 속도적인 측면에서는 훨씬 유리하다.

case 2 : 쓰레드 종료 시 ExitThread함수 호출이 유용한 경우(특정 위치에서 쓰레드의 실행을 종료시키고자 하는 경우)
ExitThread함수는 현재 실행 중인 쓰레드를 종료하고자 할 때 호출하는 함수이며 return방식만큼 선호된다.
VOID ExitThread(
	DWORD dwExitCode 1)
);
1)dwExitCode:커널 오브젝트에 등록되는 쓰레드 종료코드를 지정한다.
종료코드는 GetExitCodeThread함수를 통해 얻을 수 있다.
이 함수의 장점은 언제 어디서나 쓰레드를 종료시킬 수 있다.
보는 관점에 따라 return문을 보는 것보다 코드를 이해하기 좋을 수도 있다.
Thread Stack                                      Thread Stack
 |   C function  |↓                                |   C function  | - ExitThread에 의한 종료시점
↑|   B function  |↓                               ↑|   B function  | - ExitThread에 의한 종료시점
↑|   A function  |↓                               ↑|   A function  | - ExitThread에 의한 종료시점
↑|thread function| - return 문에 의한 종료시점     ↑|thread function| - ExitThread에 의한 종료시점

쓰레드 기반으로 프로그램이을 한다 하더라도 쓰레드 함수 내에서 모든 것을 처리할 수는 없다.
C함수가 호출된 상황에서 쓰레드를 종료해야만 한다면, ExitThread함수를 호출하는 것이 더 간결하다.
return에 의한 종료를 하고자 한다면 thread function까지 return을 해야만 종료가 가능해진다.
하지만 주의해야 할 것이 있는데 C함수에서 ExitThread가 호출되도 A,B함수의 스택 프레임에 존재하는 객체의 소멸자는
호출되지 않는다.
따라서 메모리 유출 현상이 발생할 수도 있다.
그렇기 때문에 C,C++구분 없이 가장 좋은 방법은 return문에 의한 쓰레드 종료이다.

case 3 : 쓰레드 종료 시 TerminateThread함수 호출이 유용한 경우(외부에서 쓰레드를 종료시키고자 하는 경우)
main 함수 내에서 쓰레드를 생성할 경우 쓰레드의 핸들을 얻게 된다.
이 핸들을 이용해서 쓰레드를 강제 종료시킬 수 있다.
순전히 외부에 의한 강제 종료이다.
쓰레드 스스로가 종료시점을 결정짓는 상황이 아니다.
BOOL TerminateThread(
	HANDLE hThread, //handle to thread 1)
	DWORD dwExitCode //exit code 2)
);
If the function fails, the return value is zero.
1)hThread:강제 종료할 쓰레드의 핸들.
2)dwExitCode:종료할 쓰레드의 종료코드를 인자로 전달한다. 이 종료코드는 해당 쓰레드의 커널 오브젝트에 등록된다.
이 함수의 문제점은 강제종료라는 점.
다시 말해 종료의 대상이 되는 쓰레드는 종료가 되는 시점까지도 자신이 종료된다는 사실을 인식하지 못한다.
따라서 종료에 필요한 여러가지 일들(리소스 해제)을 처리하지 못하고 바로 종료된다.
간혹 외부에서 쓰레드를 직접적으로 컨트롤하는 경우에 사용되기도 하지만, 이 함수의 호출이 존재하는 프로그램 코드는
문제가 있다고 생각하는 것이 보통이다.

02 쓰레드의 성격과 특성
힙, 데이터 영역, 그리고 코드 영역의 공유에 대한 검증
쓰레드는 메모리를 공유한다.
특히 전역변수가 할당되는 데이터 영역과 메모리가 동적으로 할당되는 힙 영역을 공유한다.
따라서 불필요하게 복잡한 구조로 프로그램을 구현할 필요가 없다.
전역변수 total(data영역)	───────────────────> main thread
	                     최종결과 참조    1,3↙     ↓4,7   ↘8,9전달
	                                thread A   thread B   thread C
	                            total+=1,2,3 total+=4,5,6,7 total+=8,9,10
total이라는 변수를 전역변수로 선언하고 있다.
떄문에 생성된 모든 쓰레드는 공유하는 total을 가지고 덧셈 연산을 진행한다.
그리고 그 최종결과를 main쓰레드가 참조하는 형태로 전개된다.
시스템 함수를 호출하는 횟수도 줄어들고 코드도 줄어든다.
또한 쓰레드의 return은 종료 상태를 나타내기 위한 용도로 활용이 가능.
12_4.cpp ThreadAdderTwo.cpp
사실 문제점이 있다.
전역 변수로의 접근 횟수가 많진 않기 때문에 목격하기는 쉽지 않다.

동시접근에 있어서의 문제점
위의 예제는 아무런 안전장치없이 전역변수 total에 둘 이상의 쓰레드가 동시접근한다는데 있다.
쓰레드는 돌아가면서 실행된다.
그래도 문제가 될 수 있다.
CPU───────────────┐단계1
│ALU(덧셈) ← |r0|←│─────|total = 10| data영역
│  └────────↗  └──│────↗ 
│     단계2       │단계3
└────────────────┘
단계1:레지스터로 데이터 이동
단계2:ALU에 의해 덧셈
단계3:증가된 결과값 메모리 저장
연산이 이뤄지기 위해서는 메모리에 저장된 데이터를 레지스터로 이동해야 한다.
그리고 ALU에 의해 실질적인 덧셈 연산이 진행되고, 그 결과가 다시 메모리에 저장되는 구조로 진행이 된다.
만약 total의 값이 10이고 두 개의 쓰레드가 각각 6과 9를 더하는 상황이라고 해보자.
total에 저장된 값을 레지스터로 이동한 다음 정수 6에 대한 덧셈까지 끝이 난 상황이라고 해보자.
CPU───────────────┐
│ALU(덧셈) ←──────│─────|total = 10| data영역
│  └───────→|r0| │
│     16         │
└────────────────┘
그리고 남은 일은 이 결과값을 메모리에 저장하는 것이다.
그런데 이 찰나에 스케줄러에 의해서 실행의 대상이 9를 더하는 쓰레드로 이동하였다.
그러면 현재까지의 상황을 메모리에 저장해야 하고 저장한 후에 9를 더하는 쓰레드는 연산을 시작한다.
CPU───────────────┐단계2
│ALU(덧셈) ←──────│─────|total = 10| data영역
│           |r0|─│─────→|    16   | heap&stacks
│                │단계1
└────────────────┘
단계1:6더하는 쓰레드연산 임시저장
단계2:9더하는 쓰레드연산
6을 더하던 쓰레드의 연산결과가 사용되지 않고, 기존에 존재하던 값이 다시 한번 ALU로 들어간다.
정수 9를 더하는 쓰레드는 모든 연산을 마치고 total값을 19로 증가시킨다.
CPU───────────────┐10
│ALU(덧셈) ←──────│─────|total = 19| data영역
│   └────────────│────↗ |    16   | heap&stacks
│        19      │
└────────────────┘
9를 더하는 쓰레드가 종료한 후에는 기회는 다시 6을 더하는 쓰레드로 이동한다.
기존에 저장된 데이터를 복원하고 진행하지 못했던 나머지 절차를 진행한다.
CPU───────────────┐쓰레드연산
│ALU(덧셈)  16┌───│────→|total = 16| data영역
│           |r0|←│──────|    16   | heap&stacks
│                │
└────────────────┘
각각 6과 9를 증가시켜 최종값은 25가되어야 하는데 결과는 16이 된다.
잘못 생각하는 것이 실행 중인 쓰레드의 변경이 프로그램 라인 단위로 이뤄진다는 생각이다.
하지만 printf, scanf뿐 아니라 1증가 및 감소를 실행하는 중간에도 실행 중인 쓰레드의 변경에 의해서
컨텍스트 스위칭은 빈번하게 발생한다.
때문에 둘 이상의 쓰레드가 같은 메모리 영역을 동시에 참조하는 것은 문제를 일으킬 가능성이 매우 높다.

프로세스로부터의 쓰레드 분리
핸들 테이블은 프로세스 소유이다.
즉 하나의 프로세스에 하나의 핸들 테이블이 존재할 뿐이다.
핸들값은 핸들 테이블에 정보가 등록된 이후에, 이 핸들 테이블의 소유자에 해당하는 프로세스에게만 의미를 지닌다.
프로세스A가 특정 리소스C(파이프, 메일슬롯 등등)을 생성하면서 얻은 핸들값이 204라고 가정하자.
프로세스A의 핸들 테이블에 핸들 204에 대한 정보가 등록되어 있고, 이 정보를 통해서 커널 오브젝트와 리소스C에
접근이 가능하다.
그러나 프로세스B의 핸들 테이블에는 핸들 204에 대한 정보가 존재하지 않아 접근이 불가능하다.
그럼 프로세스 A내에서 생성된 쓰레드들에게는 핸들 204가 의미를 지닐까?
지닌다 왜냐하면 프로세스 내에서 생성된 모든 쓰레드들은 스택이외의 모든 것을 공유하기 때문이다.
즉, 핸들 테이블까지도 공유를 한다.
Usage Count는 커널 오브젝트의 소멸 타이밍을 결정하기 위해서 필요하다.
자식 프로세스의 경우 생성과 동시에 Usage Count는 2가 된다.
그래서 하나는 자식 프로세스가 종료될 때 감소하고, 또 하나는 부모 프로세스가 자식 프로세스의 핸들을 인자로
CloseHandle함수를 호출할 때 감소한다.
쓰레드도 마찬가지로 생성과 동시에 UsageCount는 2가 된다.
하나는 쓰레드 종료 시 감소하고, 나머지 하나는 쓰레드 핸들을 인자로 CloseHandle함수가 호출될 때 감소한다.
따라서 이전에 자식 프로세스의 커널 오브젝트 소멸과 관련된 문제가 동일하게 쓰레드에서도 발생할 수 있다.
이런 실수를 막기위해 쓰레드 생성 시 반환된 핸들값을 인자로 전달하면서 CloseHandle함수를 곧바로 호출한다.
그러면 쓰레드의 Usage Count는 1이되고, 쓰레드가 종료함과 동시에 0이되어 모든 메모리를 반환하게 된다.
CloseHandle함수 호출을 가리켜 "프로세스로부터 쓰레드를 분리한다"고 한다.

ANSI 표준 C라이브러리와 쓰레드
대부분의 프로그램에서는 표준 C 라이브러리를 활용하고 특히 문자열 처리와 입출력에 관련해서는 표준 C라이브러리
의존도가 높은 편.
문제는 초기에 표준 C라이브러리가 구현될 당시에 쓰레드에 대한 고려가 없었다.
따라서 멀티 쓰레드 기반으로 프로그램을 구현하게 되면, 동일한 메모리 영역을 동시에 접근하는 불상사가 발생할 수 있다.
12_5.cpp strtok.cpp
함수가 호출되면서 처음에 등록된 문자열을 어딘가에 저장되어야 첫 번째 인자로 NULL을 전달하면서 strtok함수가
다시 호출되는 상황에서 다음 번 토큰을 반환할 수 있다.
즉 전역이나 static으로 선언된 배열에 문자열이 저장되어 있음을 예측할 수 있다.
즉 멀티 쓰레드 기반으로 프로그램 구현 시 ANSI표준 함수의 호출은 메모리의 동시 참조 문제가 발생할 수 있는 것.
해결책은 MS에서는 멀티 쓰레드에 안전한 ANSI표준 라이브러리를 제공하고 있다.
따라서 이 라이브러리를 사용해서 빌드하도록 링크를 변경해야 한다.
Alt + F7을 눌러 프로젝트 설청창을 열어 "Configuration Properties"을 선택하고 "C/C++"에서 "Code Generation".
"Runtime Library"는 빌드 시 사용할 ANSI표준 라이브러리를 지정해 주는 부분이다.
Multi_threaded라는 이름으로 시작하면 쓰레드에 안전한 라이브러리가 링크되어 있는 상태다.
설정 가능한 라이브러리의 종류는 개발환경의 버전에 따라 차이를 보인다.
또한 쓰레드를 생성할 때, CreateThread대신 _beginethreadex함수를 사용해야 한다.
_beginthreadex함수도 내부적으로는 쓰레드 생성을 위해서 CreateThread함수를 호출한다.
다만 쓰레드를 생성하기에 앞서 쓰레드를 위해, 독립적인 메모리 블록을 할당한다는 차이점.
"Multi-"로 시작하는 이름의 표준 C라이브러리 함수는 이렇게 할당된 쓰레드 각각의 메모리 블록을 기반으로 연산.
이로써 멀티 쓰레드 기반에서 안정성이 확보되는 것.
_tprintf함수는 표준 C 라이브러리 함수이고 멀티 쓰레드 기반에서 문제를 일으키지 않으려면 쓰레드에 안전한
런타임 라이브러리를 선택하고, _beginthreadex함수를 사용해야만 한다.

사실 ANSI 표준 함수 중에서 일부만 멀티 쓰레드 기반에서 문제를 일으킨다.

uintptr_t _beginthreadex(
	void* security,
	unsigned stack_size,
	usngiend (*start_address)(void*),
	void* arglist,
	unsigned initflag,
	unsigned *thrdaddr
);
전달인자의 순서와 의미가 CreateThread함수와 동일하다.
다만 선언된 매개변수 자료형과 반환형에 차이가 있어 쓰레드 함수 선언에 변경이 조금 필요하고 약간의 형변환이 요구됨.
12_6.cpp CountThreadMultiThread.cpp
멀티 쓰레드 기반 프로그래밍을 가정하에 _beginthreadex함수를 사용한다.
주의할 점은 쓰레드를 종료하는 방법에 대한 부분이다.
가장 좋은 방법은 쓰레드 함수에서 return문을 이용하는 것이다.
만약에 ExitThread함수를 활용하고자 할 경우는 _endthreadex를 호출하자.
void _endthreadex(unsigned retval);
함수 자체가 지니는 의미나 매개변수의 의미는 ExitThread함수와 동일하다.
_beginthreadex함수 호출 시 각각의 쓰레드를 위해 메모리를 할당한다.
따라서 쓰레드 종료 시에는 할당한 메모리를 반환해야만 한다.
이 역할을 하는 함수가 _endthreadex이다.
이 함수는 내부적으로 쓰레드에 할당된 메모리를 해제하고 ExitThread함수를 호출한다.
사실 쓰레드 함수에 return문을 이용할 경우 _endthreadex함수가 자동으로 호출되서 return해도 괜찮다.

_beginthread & _endthread라는 함수가 있는데 이 함수들도 각각 쓰레드를 생성 및 소멸하는 용도의 함수다.
쓰레드 생성을 간겨랗게 하기 위한 용도로 디자인된 함수인데 기능도 제한적이고 쓰레드를 생성하자마자 핸들을
닫아 버리기 때문에 반환되는 핸들도 유효하지 않다.
이러한 문제점들 때문에 많은 전문가들은 가급적 사용하지 말라한다.

03 쓰레드의 상태 컨트롤
쓰레드의 상태는 프로그램이 실행되는 과정에서 수도없이 변경된다.
입력 및 출력 연산을 시작하거나 종료하는 경우에도 변경되고, 새로운 쓰레드의 생성에 의해서도 변경될 수 있다.
이는 상황에 따라서, 운영체제의 관리방법에 따른 것으로 컨트롤할 수 없다.
그러나 경우에 따라서는 쓰레드의 상태를 프로그래머가 임의로 변경시켜야하는 경우도 있다.
특정 쓰레드를 지목하면서 지목한 쓰레드의 실행을 잠시 멈추기 위해서 Blocked상태로 만들거나 다시 실행을
재개시키기위해 Ready상태로 둔다거나 하는 일은 경우에 따라서는 필요하다.

쓰레드의 상태변화
Windows에서는 상태가 변화하는 주체는 프로세스가 아닌 쓰레드이다.
S ─────> Ready ─────> Running ─────> Blocked ─────> E
	1      ↑     2      │       4       │      6
		   └────────────┘               │
		   ↑     3                      │
		   └────────────────────────────┘
						  5
1&2:생성하자마자 Ready상태로 놓이게 된다. 그 다음 스케줄러에 의해서 선택될 경우 Running상태가 되면서
실제 실행이 이뤄진다. 따라서 Ready상태에 놓이는 쓰레드는 여럿이 될 수 있지만, Running상태에 놓이는
쓰레드는 하나밖에 될 수 없다.
3:실행 중인 쓰레드에게 할당된 타임 슬라이스가 모두 소비되어서, 다른 쓰레드에게 실행의 기회를 넘겨야 할 때,
Running상태에서 Ready상태로의 이동이 이뤄진다. 실행의 기회를 넘겼다 하더라도 언제든지 다시 실행되어야 하기
때문에 Ready상태로 이동하는 것이다.
4&5:Running상태에 있는 쓰레드가 입출력 연산을 하거나 Sleep함수 호출로 인해 잠시 실행이 중단된 경우
Blocked상태로 이동을 하면서 다른 쓰레드의 실행을 도모하게 된다. Blocked상태로 이동시킨 원인이 해결되면
다시 Ready상태로 돌아가서 실행되기를 기다린다.

Suspend & Resume
특정 쓰레드를 지목해서 그 쓰레드를 Blocked상태로 이동시킬 수 있고, 또 다시 Ready상태로 옮길 수 있다.
DWORD SuspendThread(
	HANDLE hThread 1)
);
If the function succeeds, the return value is the thread's previous suspend count otherwise,
it is (DWORD) -1.
1)hThread:Blocked상태에 두고자 하는 쓰레드의 핸들을 인자로 전달한다.
DWORD ResumeThread(
	HANDLE hThread 1)
);
If the function succeeds, the return value is the thread's previous suspend count.
If the function fails, the return value is (DWORD) -1.
1)hThread:Ready상태에 두고자 하는 쓰레드의 핸들을 인자로 전달한다.
첫 번째 함수는 쓰레드를 Blocked상태에 두는 함수이고, 두 번째 함수는 Blocked상태에 있는 함수를 Ready상태로.
그런데 쓰레드의 커널 오브젝트에는 SuspendThread함수의 호출 빈도수를 기록하기 위한 Suspend Count라는 멤버가 있다.
현재 실행 중인 쓰레드의 서스팬드 카운트는 0이다.
그러나 이 쓰레드의 핸들을 인자로 SuspendThread함수가 호출되면 Suspend Count는 1이되고 쓰레드는 Blocked상태.
그리고 다시 SuspendThread함수가 호출되면 카운트는 2가 된다.
즉 SuspendThread함수는 서스팬드 카운트값을 하나 증가시키는 역할을 한다.
서스펜드 카운트가 2인 상황에서는 한번의 ResumeThread호출로 바로 Ready상태가 되지 않는다.
ResumeThread함수의 호출은 서스펜드 카운트를 하나 감소시키는 역할을 한다.
따라서 이러한 상황에서는 두 번 호출되어야 Ready상태에 놓이게 된다.
함수의 반환값을 통해 서스펜드 카운트의 변화를 확인하는 것이 가능하다.
두 함수 모두 함수 호출이 성공하면 변경되기 이전에 저장되었던 서스펜드 카운트를 반환하기 때문.
12_7.cpp SuspendCount.cpp
Running State!라는 문자열 출력 횟수는 차이가 있을 수 있지만 서스팬드 카운트는 완전히 동일해야 한다.

04 쓰레드의 우선순위 컨트롤
Windows에서는 프로세스가 우선순위를 갖는 것이 아니라, 안에서 동작하는 쓰레드가 우선순위를 갖는 것.
프로세스의 기준 우선순위
IDLE_PRIORITY_CLASS     : 기준 우선순위 4
NORMAL_PRIORITY_CLASS   : 기준 우선순위 9(Default)
HIGH_PRIORITY_CLASS     : 기준 우선순위 13
REALTIME_PRIORITY_CLASS : 기준 우선순위 24
쓰레드의 상대적 우선순위
THREAD_PRIORITY_LOWEST       : -2
THREAD_PRIORITY_BELOW_NORMAL : -1
THREAD_PRIORITY_NORMAL       : 0(Default)
THREAD_PRIORITY_ABOVE_NORMAL : +1
THREAD_PRIORITY_HIGHEST      : +2
쓰레드의 우선순위는 프로세스의 기준 우선순위와 쓰레드의 상대적 우선순위의 조합으로 결정된다.
예를 들어 기준 우선순위가 NORMAL_PRIORITY_CLASS(9)인 프로세스 안에 두 개의 쓰레드가 존재하는데 각각
THREAD_PRIORITY_LOWEST(-2), THREAD_PRIORITY_NORMAL(0)이면 7(9-2)과 9(9-0)로 결정된다.
즉 프로세스의 기준 우선순위를 기준으로 해서 상대적 우선순위에 해당하는 값을 더하거나 빼면 쓰레드의
실질적인 우선순위를 계산해 낼 수 있다.
우선순위 상수값은 Windows버전별로 차이가 있다.
프로세스 내에서 생성되는 모든 쓰레드의 상대적 우선순위는 THREAD_PRIORITY_NORMAL이다.
즉 프로세스의 기준 우선순위를 그대로 수용하는 것.
이를 변경하거나 참조할 때에는 함수를 쓴다.
BOOL SetThreadPriority(
	HANDLE hThread,
	int nPriority
);
If the function fails, thre return value is zero.
int GetThreadPriority(
	HANDLE hThread
);
If the function fails, the return value is THREAD_PRIORITY_ERROR_RETURN.
SetThreadPriority함수의 첫 번째 인자는 우선순위를 변경할 쓰레드의 핸들이고, 두 번째는 정의되어 있는 상수값이다.

이것만은 알고 갑시다
1. CreateThread 함수와 _beginthreadex함수의 차이점
_beginthreadex함수를 기반으로 쓰레드를 생성할 경우 쓰레드별로 독립적인 메모리 공간을 할당 받는다.
그리고 이 메모리 공간은 ANSI표준 함수를 호출하는 과정에서 사용한다.
이는 둘 이상의 쓰레드가 하나의 메모리 공간에 동시접근하는 문제점을 막기 위함.
2. 둘 이상의 쓰레드가 동시접근하는 메모리 공간의 문제점
문제점은 함수 단위가 아닌 CPU의 연산 단위에서 이해해야 한다.
3. 쓰레드의 상태 변화
Windows는 실행의 주체가 프로세스가 아닌 쓰레드이다. 따라서 상태를 지니는 실질적인 대상도 쓰레드이다.
쓰레드는 Ready, Blocked, Running 상태를 지니게 되며, 이들 상태간의 이동이 발생하는 시기는 프로세스의
상태 이동이 발생하는 이유와 같다.
4. 프로세스로부터의 쓰레드 분리
분리한다는 것은 프로세스가 소유하는 쓰레드의 핸들을 반환함으로써 쓰레드 Usage Count를 1로 두겠다는 것이다.
이는 쓰레드가 종료되는 시점에 쓰레드의 리소스를 반환하기 위함.

*/