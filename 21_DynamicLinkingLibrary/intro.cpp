/*
01 라이브러리와 printf!
질문
printf함수의 실행가능한 바이너리는 어디에 있을까?
stdio.h안에는 printf 함수의 선언만이 존재한다.
일반적인 선언은 int __cdecl printf(const char*, ...);
즉, printf 함수의 바이너리가 존재하지 않는다.

해답은 라이브러리
호출 가능한 printf 함수는 라이브러리 안에 있다.
라이브러리란 여러 프로그램에서 자주 사용하는 함수와 데이터들을 실행이 가능한 바이너리 형태로 묶어놓은 파일.
즉, printf 함수의 선언은 stdio.h 파일에 존재하지만, printf 함수의 정의가 컴파일된 바이너리 코드는 라이브러리에.
이 라이브러리들은 호출 가능한 ANSI 표준 C함수들로 구성되어 있기 때문에 C Runtime Library라 불린다.

C Run-Time Library  Characteristics
Libcmt.lib          Multithreaded, static link
Libcmtd.lib         Multithreaded, static link(debug)
Msvcrt.lib          Multithreaded, dynamic link
Msvcrtd.lib         Multithreaded, dynamic link(debug)

일부는 정적 라이브러리이고, 일부는 동적 연결 라이브러리이다.
라이브러리 이름의 마지막이 'd'로 끝나는 경우는 디버그 모드로 컴파일할 때 사용되는 라이브러리이다.
프로젝트 설정창에서 확인가능하고 변경가능하다.
C/C++ -> Code Generation -> Runtime Library

라이브러리 작성에 대한 동기
21_1.cpp LibSwap.cpp
swap 함수는 두 개의 int형 변수가 지니고 있는 값을 서로 바꿔주는 역할을 한다.
이처럼 유용하고, 여러 프로그램에 의해 사용될 소지가 높은 함수들은 라이브러리로 구성하면 여러모로 좋을 것.

라이브러리 작성
ADM이라는 이름의 디렉터리를 만들고 실습.

프로젝트의 구성
새로운 프로젝트 생성창을 띄우고 Win32Project를 선택하고나서
Name:SwapStaticLib
Location:(디렉터리 구조에 맞게)
<Finish>말고 <Next>를 누르고 Static library를 선택한다.
그러면 정적 라이브러리 생성을 위한 프로젝트 구성이 된다.

라이브러리 함수의 입력
이 프로젝트에 두 개의 파일을 추가한다.
swap.h와 swap.cpp
swap.h에는 swap함수의 선언이 존재하고, swap.cpp에는 swap 함수의 정의가 존재한다.
swap.h
//swap 함수의 선언
void swap(int* v1, int* v2);
여기서는 Pre-compiled header를 사용하도록 체크되어야 한다.
원래는 헤더파일 stdafx.h를 포함시켜야 한다.
swap.cpp
//swap 함수의 정의
void swap(int* v1, int* v2)
{
	int temp = *v1;
	*v1 = *v2;
	*v2 = temp;
}
파일 생성 및 코드 입력까지 완료하면 컴파일.
\ADM\SwapStaticLib\debug 디렉터리에서 만든 라이브러리를 확인할 수 있따.

라이브러리의 활용
라이브러리를 활용하는 Application 작성
21_2.cpp SwapLibTest.cpp
에러 메시지를 접하게 된다.
컴파일러가 아닌 링커의 불만.
error LNK2019:...

SwapStaticLib.lib를 프로젝트에 포함시키기 위한 기본 작업
가장 기본적으로 해야 할 일은 프로젝트 Build 시 SwapStataicLib.lib를 포함시키겠다고 선언하는 것.
프로젝트 속성창에서 Linker의 Input탭을 누르면 화면을 볼 수 있다.
Additional Dependencies를 통해 프로젝트 빌드 시 포함시킬 라이브러리 이름을 지정할 수 있다.
따라서 만든 라이브러리 이름을 입력한다.
또는 속성창이 아닌 문장을 통해 프로그램 코드상에서 포함시킬 라이브러리를 지정할 수도 있다.
#pragma comment(lib, "포함할 라이브러리 이름")

SwapStaticLib.lib의 경로 알려주기1:현재 디렉터리 기반으로
빌드 시 SwapStaticLib.lib를 포함시키겠다고 선언했으니 이 파일을 찾을 수 있도록 도와야 한다.
가장 쉬운 방법은 프로젝트 파일이 있는 위치에 라이브러리 파일을 가져다 놓는 것이다.
헤더파일 swap.h도 이 디렉터리에 갖다 놓는다.
즉 쌍을 이루는 헤더파일과 라이브러리 파일을 프로젝트 파일이 있는 위치에 가져다 놓고 컴파일하면 된다.

SwapStaticLib.lib의 경로 알려주기2:include 디렉터리 추가
프로젝트 속성창에서 파일의 검색 경로를 추가하는 것.
C/C++에서 Additional Include Directories을 통해 라이브러리 파일이 있는 위치를 지정하면, 지정된
디렉터리는 라이브러리 검색 경로에 추가된다.
라이브러리 파일을 옮기는 불편함을 덜 수 있다.

STATIC LIBRARY
SwapStaticLib.lib은 정적 라이브러리라 불린다.

exe 파일의 생성 과정
swap.h ──┬───────────────> SwapStaticLib.lib ┐    링크
swap.cpp ┘       컴파일                       ├──────────> SwapLibTest.exe
swap.h ─────────┬────────> SwapLibTest.obj ──┘
SwapLibTest.cpp ┘컴파일

swap.cpp와 swap.h를 기반으로 라이브러리 SwapStaticLib.lib를 생성하고 SwapLibTest.cpp를 컴파일해서
오브젝트 파일 SwapLibTest.obj를 생성하였는데 swap.h를 필요로 한다.
SwapStaticLib.lib와 SwapLibTest.obj가 하나로 묶여 SwapLibTest.exe라는 이름의 실행파일이 생성된다.
이 과정을 주도하는 것은 Linker이고 링커에 의해서 진되는 작업을 링크라고 한다.
중요한 사실은 라이브러리가 실행파일 안에 포함된다는 것.
이제부터는 뗄래야 뗄 수도 없고, 실행파일이 처음 만들어 질 때부터 아예 하나로 묶여버린 것.
이러한 형태의 라이브러리를 Static Library.

02 또 다른 라이브러리 DLL
DLL(Dynamic Linking Library)에 대한 이해
DLL에 대한 이해는 Windows 프로그래밍에서 필수이다.
링커는 링크과정을 통해 실행파일을 생성해낸다.
확장자로 .exe를 갖는 실행파일을 만들어 내기도 하지만, 확장자로 .dll을 지니는 라이브러리를 만들어내기도 한다.

DLL과 정적 라이브러리의 차이점
정적 라이브러리는 정적인 특성을 지니고, DLL은 동적인 특성을 지닌다.
이는 실행 가능한 프로그램에서 라이브러리를 가져다 쓰는 방법에 따른 차이점이다.

정적 라이브러리의 특성
현재 세 개의 독립된 프로그램이 SwapStaticLib.lib 라이브러리를 필요로 한다고 가정해보자
각각의 프로그램은 AAA.cpp, BBB.cpp, CCC.cpp 라는 이름의 파일로 작성되었다.

정적 링크의 이해
         컴파일             SwapStaticLib.lib     AAA.exe
AAA.cpp ---------> AAA.obj ---------┴----------> SwapStaticLib.lib
		 컴파일            정적링크  │             BBB.exe
BBB.cpp ---------> BBB.obj ---------┴----------> SwapStaticLib.lib
		 컴파일            정적링크  │             CCC.exe
CCC.cpp ---------> CCC.obj ---------┴----------> SwapStaticLib.lib
                           정적링크
컴파일 과정에 필요한 헤더파일 swap.h는 생략.
주목해서 볼 부분은 실행파일 AAA.exe, BBB,exe, CCC.exe이다.
이 파일들은 실행 시 필요로 하는 라이브러리 SwapStaticLib.lib의 바이너리 코드를 완전히 포함하고 있다.
라이브러리 코드를 완전히 포함해서 .exe파일을 생성하는 형태의 링크를 정적 링크라 한다.
뗄레야 뗄 수 없다.
정적 링크의 가장 큰 장점은 실행의 독립성이다.
실행파일만 있으면 언제 어디서든 실행 가능하다.
실행파일 안에 라이브러리도 함께 포함되어있으므로 .lib 파일은 프로그램의 실행을 위해서 더 이상 필요가 없다.
단점은 세 개의 프로그램 AAA.exe, BBB.exe, CCC.exe는 많은 메모리 공간을 차지하게 된다.
프로그램이 실행될 때에도 그렇지만 하드디스크에 저장되어 있는 상태에서도 차지한다.
정적라이브러리               DLL
AAA.exe                     AAA.exe
SwapStaticLib.lib           BBB.exe
BBB.exe                     CCC.exe
SwapStaticLib.lib           SwapStaticLib.lib
CCC.exe
SwapStaticlib.lib
하드디스크에 총 세 개의 실행파일이 저장되어 있으면 모든 실행파일이 동일한 라이브러리를 포함하고 있기 때문에,
메모리 공간을 더 차지하게 된다.
만약 세 개의 실행파일이 동일하게 포함하는 라이브러리를 별도로 저장한 다음, 공유할 수만 있다면, 메모리 절약이 가능.

DLL의 특성
위에는 하드디스크에 저장되어 있는 상황이고 DLL의 특성은 메인 메모리에서 두드러진다.
여기서 AAA.exe를 실행하면
AAA.exe 가상메모리                            AAA.exe 가상메모리     
                정적 라이브러리 영역                            |            |별도의 DLL 파일
                  ┌───────────┐                                     ↓  ↓
| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|              | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|
                      ↓  ↓                                         ↓  ↓
메인 메모리 | 2| 3| 5| 8| 9|                  메인 메모리 | 2| 3| 5| 8| 9|
AAA가 실행 중에 있고, 총 5개의 페이지(2,3,5,8,9)가 메인 메모리에 올라와 있는 상황.
정적라이브러리는 실행파일의 일부로 빌드되었기 때문에 정적 라이브러리를 포함하여 가상 메모리를 구성하게 된다.
DLL은 실행파일의 일부로 포함되지 않고 독립적으로 저장되는 라이브러리이다.
그러나 AAA가 이 라이브러리를 사용하기 때문에 AAA의 가상 메모리 주소에 DLL을 매핑시켜야 한다.
그 다음에야 비로소 DLL이 제공하는 함수를 호출할 수가 있다.
즉 두 개의 파일이(실행파일과 DLL파일) 하나의 가상 메모리를 구성하는 꼴.
하나의 프로세스를 실행시킨 관점에서 보면 정적 라이브러리와 DLL의 차이가 두드러지지 않는다.
그러나 프로세스를 하나 더 실행키기면, 메모리를 활용하는 방식에 있어 큰 차이점을 보이게 된다.
이제 BBB.exe를 실행시킨다.
AAA가 잠시 멈추고 BBB가 실행된다.
그런데 프로세스 BBB도 8번과 9번에 해당하는 페이지를 필요로 한다고 하자.

AAA.exe 가상메모리                            AAA.exe 가상메모리
				정적 라이브러리 영역                           
				  ┌───────────┐                                     
| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|              | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|
					  ↑  ↑반환                                      
메인 메모리 | 2| 3| 5| 8| 9|                  메인 메모리 | 2| 3| 5| 8| 9|요지부동
                      ↑  ↑새로운 로딩                               ↑  ↑
| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|              | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|
BBB.exe 가상메모리 └───────────┘              BBB.exe 가상메모리
                 정적 라이브러리 영역
AAA가 실행을 멈추고 BBB가 실행되는 과정에 있으므로 메인 메모리에는 BBB의 페이지가 올라가게 된다.
페이지 번호 2,3,5는 동일하지만 분명히 BBB의 페이지이다.
뿐만아니라 정적 라이브러리 영역에 해당하는 페이지 8과 9도 BBB의 페이지이다.
한마디로 메인 메모리에 있는 페이지가 완전히 교체되는 것.
DDDL기반에는 메인 메모리에 페이지 2,3,5,8,9가 올라와 있고 페이지 2,3,5는 BBB의 것.
그러나 8과9는 AAA가 사용하던 페이지 그대로이다.
즉 별도의 파일로 존재하는 DLL을 AAA와 BBB가 공유하게 되는 것이 장점.
둘 이상의 프로세스가 동일한 DLL을 공유할 경우, 메인 메모리에서 페이지 단위로 공유가 이뤄진다.
만약 DLL의 다른 페이지를 프로세스 BBB가 필요로 했다면 새로 가져다가 올려야만 한다.
이것은 C/C++ Run-time 라이브러리를 지정하는 모습으로 4개중 2개가 DLL.
이것이 페이지 단위로 공유가 이뤄지는 대표적인 DLL.

DLL 제작1:암묵적 연결(Implicit Linking)
두 가지 방법을 통해 DLL을 사용할 수 있는데 첫 번째 방법은 암묵적연결 방법이고, 두 번째는 명시적연결 방법이다.
상대적으로 암묵적 연결방법이 쉽다.

메모리에 한번 올라가면 안 내려 온다고?
메모리가 가상 메모리를 의미할 때와, 메인 메모리를 의미할 때를 나눠서 생각.
가상 메모리에 올라갔다는 의미는 가상 메모리의 주소에 DLL이 매핑되었음을 의미.
프로세스 AAA의 가상 메모리 주소에 매핑된 DLL은 프로세스 AAA가 소멸되면 함께 소멸된다.
프로세스 AAA의 가상 메모리 공간과 프로세스 BBB의 가상 메모리 공간은 서로 달라 남아있을 수 없다.
메인 메모리일 때 페이지 단위의 교체는 발생한다.
정확히 표현하면 메인 메모리에 끝까지 남아 있을 수 있는 페이지는 존재하지 않는다.
페이지 교체 알고리즘에 의해 빈번한 교체가 발생한다.
허나 DLL은 물리 메모리에 한번 올라가면, 공유하는(메모리에 올라간 DLL을 공유하는) 프로세스가 모두 종료될 때까지
메모리에 존재한다.

DLL 제작에 필요한 파일
SwapDll.h
//swap 함수의 import 선언
__declspec(dllimport)
void seap(int* v1, int* v2);
SwapDll.cpp
//swap 함수의 정의와 export 선언
__declspec(dllexport)
void swap(int* v1, int* v2)
{
	int temp = *v1;
	*v1 = *v2;
	*v2 = temp;
}
__declspec은 외부에 제공할(export), 혹은 제공받을(import)함수 및 변수 선언에 사용된다.
MS에서 제공하는 추가적인 선언문.
__declspec(dllimport)는 DLL로부터 제공받을 함수를 선언할 때 사용된다.
헤더파일에 swap함수의 선언 앞에 이 문장이 들어가 있다.
이는 swap함수를 DLL로부터 제공받겠다는 의미.
__declspec(dllexport)는 외부에 제공할 함수를 선언할 때 사용된다.
swap함수의 선언과 정의 앞에 이 문장을 붙여주고 있는데, 이는 이어서 등장하는 swap함수를 외부에서 사용할 수
있는 형태의 DLL로 라이브러리화 하겠다는 뜻.
DLL을 만드는 데 있어서 필요한 것은 dllimport 선언이 아닌 dllexport 선언, .cpp파일만 있으면 된다.

DLL 만들기
"Win32 Project"를 만들고 name은 SwapDll, location은 \DLL.
다음 화면에서 "DLL"을 선택하고, 추가로 Empty project을 선택한다.
생략하면 자동으로 파일이 하나 생성되고, 부담스러운 코드들이 들어가게 된다.
이제 파일을 하나 생성해서 SwapDLL.cpp의 내용을 입력하고 빌드한다.
그러면 실행파일이 생성되는 위치에 SwapDll.lib, SwapDll.dll이 생성.
이것은 DLL과 정적 라이브러리가 동시에 생성된 것이 아닌, .lib파일은 정적 라이브러리 파일과 성격이 다르다.

.lib 파일과 .dll 파일의 용도
DLL을 생성하는 과정에서 만들어진 .lib파일은 DLL이 제공하고자 하는 함수 정보(이름 정보)를 지닌다.
DllTest.cpp
     ↓컴파일러에 의해
DllTest.obj     SwapDll.lib
     └──────┬────────┘
	        ↓링커에 의해
		DllTest.exe ──────────────→ SwapDll.dll
		             실행 중에 참조
Dlltest.cpp는 DLL이 제공하는 swap함수를 호출하는 코드로 구성된다.
컴파일러에 의해 DllTest.obj를 생성해야 한다.
이 과정에서 선언을 담은 헤더파일이 필요하다.
호출하는 함수의 선언 정보만 있어도 컴파일러는 문제없이 컴파일을 한다.
__declspec(dllimport) void swap(int* v1, int* v2);
컴파일되었으니 링커에 의해 실행파일을 만들 차례다.
컴파일은 호출하고자 하는 함수의 선언부만 있으면 되지만, 실행파일의 생성은 선언에 대한 정의가 완전히 존재해야
만들어지기 때문.
그런데 우리는 DLL을 하나로 묶으려는 것이 아닌 실행시간에 참조하고픈 것.
이러한 문제점을 해결하기 위해 DLL이 만들어질 때 .lib 파일도 함께 만들어진다.
DLL을 생성할 때 함께 만들어지는 .lib파일에는 링커가 실행파일을 만드는 데 필요한 정보가 담겨 있다.
SwapDll.lib 파일은 링커에게 "DllTest.obj에서 호출하는 swap함수는 SwapDll.dll 파일에 잘 정의되어 있어"
링커는 lib파일이 건네주는 정보를 참조해서 실행파일을 만들어 낸다.
물론 실행시간에 해당 DLL을 참조하는 실행파일을 만들게 된다.
.lib 파일은 링크할 때 필요하고, .dll파일은 실행할 때 필요하다.

DLL의 활용
21_3.cpp DllTest.cpp
헤더파일 SwapDll.h를 포함하고 있다.
swap 함수가 외부(DLL)에 존재한다는 선언이 들어 있다.
헤더파일을 포함하지 않고 __declspec(dllinport) void swap(int* v1, int* v2); 해줘도 된다.
정적 라이브러리를 만들고 실행할 때는 참조한 lib 파일 이름을 명시해 주었다.
여기서도 lib파일 이름을 명시해줘야 한다.
프로젝트 속성창에서 설정해줘도 되고 #pragma comment(lib, "SwapDll.lib") 해줘도 된다.
마지막 단계로, 프로젝트가 찾을 수 있는 위치에 .lib 파일을 옮겨야 빌드하는 데 문제가 없다.
프로젝트 속성창이나 프로젝트 파일이 있는 위치에 라이브러리 파일을 가져다 놓으면 된다.
컴파일은 되지만 실행하기 위해선 .dll파일의 위치도 고려해야 한다.
DLL 파일을 찾는 순서는 표준 검색 경로 기준으로 찾게 된다.
1)실행파일이 존재하는 디렉터리
2)프로세스의 현재 디렉터리
3)Windows 시스템 디렉터리
4)Windows 디렉터리
5)PATH 환경변수에 등록되어 있는 모든 디렉터리
위 디렉터리 중 한 곳에 .dll 파일이 존재해야 한다.
가장 쉬운 방법은 실행파일이 존재하는 디렉터리에 가져다 놓는 것.

DLL과 extern 선언
Visual Studio는 확장자가 .c인가 .cpp인가에 따라서 컴파일러를 결정한다.
만약에 확장자가 .c라면 표준 C컴파일러를 통해 바이너리 코드를 생성하고, 확장자가 .cpp라면 표준 C++ 컴파일러를
통해서 바이너리 코드를 생성한다.
DLL 모두 확장자를 .cpp로 두어 동일한 컴파일러를 사용하였다.
만약 DLL을 사용하는 코드의 확장자를 .c로 바꿔 라이브러리를 만들 때 사용한 컴파일러와 라이브러리를 사용하는
사용한 컴파일러가 다르다면 어떻게 될까?
DllTest.cpp의 이름을 DllTest.c로

[테스트 1단계]
빌드 과정에서 LNK2019 에러를 접할 것이다.
C++컴파일러는 컴파일 과정에서 네임 맹글링(Name Mangling:이름을 엉망으로 만든다)이란 작업을 한다.
이는 정의되어 있는 함수의 이름을 정해진 규칙에 의해 바꿔버리는 것.
바뀌는 이유는 C++문법과 관련이 있다.
중요한 사실은 컴파일 완료된 바이너리 코드에서는 이름이 바뀐다.
이름을 바꾸는 규칙은 컴파일러에 따라 다르다.
때문에 C++ 컴파일러가 다르면 호환이 안된다.
A사의 C++컴파일러로 컴파일된 라이브러리는 B사의 C++컴파일러로 컴파일된 프로그램에서 사용하지 못한다.
네임 맹글링 규칙이 다르기 때문.
DLL을 사용하는 코드의 확장자를 .c로 변경하면 표준C컴파일러에 의해 컴파일이 이뤄지며, 네임 맹글링이 발생하지 않는다.
반면에 DLL은 C++컴파일러로 만들어졌기 때문에 네임 맹글링이 발생한다.
DLL에 존재하는 swap함수의 이름은 더 이상 swap이 아니어서 링크 에러 메시지를 전달한 것.
동일한 컴파일러 기반에서 빌드를 하면, 동일한 이름 변환 규칙 때문에 이런 문제는 발생하지 않는다.
그러나 DLL은 라이브러리이고 어디서건 이 라이브러리를 필요로 하면 사용이 가능해야 한다.
그럼 C로 구현된 프로그램에서도 C++로 빌드된 라이브러리를 사용하려면 C++컴파일러가 함수의 이름을 바꾸지
못하도록 막으면 된다.
즉 네임 맹글링을 막는 것.
extern "C"
이 문장은 C++ 문법의 일부분으로, 넹미 맹글링을 막기 위해 제공된다.
함수 정의 앞에 이 문장을 붙이면 이름이 변경되지 않는다.
SwapDll.cpp
...
extern "C" __declspec(dllexport)
void swap...

[테스트 2단계]
SwapDll.h는 그대로 두고 SwapDll.cpp를 변경해서 DLL을 만든다.
DllTest.cpp는 DllTest.c로 변경한 상태에서 테스트한다.

[테스트 3단계]
그리고 확장자를 다시 .cpp로 변경하고 빌드해본다.
이번에도 LNK2019에러가 발생한다.
네임 맹글링은 함수 정의뿐만 아니라 함수 호출 문의 이름에서도 발생한다.
즉 swap 함수 이름이 swap_@#$%4234로 바뀌어 맹글링 되는 것처럼
void swap_@#$%4234(int* v1, int* v2) {}
함수 호출문 swap(&a, &b)도 규칙에 맞춰서 변경된다.
swap_@#$%4234(&a, &b);
즉 DLL의 swap함수는 이름 변경을 막아놓았지만, 이 라이브러리를 활용하는 예제의 swap 호출문은 이름 변경이
발생한 상태.
때문에 호출하고자 하는 함수를 찾지 못해 에러가 발생한 것.
해결책은 함수 호출 문장도 이름 변경을 막는 것.
extern "C"를 붙여주되, 함수의 선언부에 붙여주면 된다.
SwapDll.h
...
extern "C" __declspec(dllimport)
void swap(int* v1, int* v2);

[테스트 4단계]
DLL을 그대로 사용하고 DllTest.cpp에서 포함하는 헤더파일 SwapDll.h를 변경해 extern "C"선언을 포함시킨다.
이제 라이브러리로 제공하는 swap함수도, 이 라이브러리를 사용하는 swap 호출 문장도 이름 변경이 발생하지 않는다.
컴파일러에 상관없이 swap 함수를 호출할 수 있게 된다.

결론적으로
1)DLL을 통해 제공하고자 하는 함수에는
extern "C" __declspec(dllimport)
2)반면에 DLL에 존재하는 함수를 호출하고자 하는 경우에는 
extern "C" __declspec(dllexport)

DLL 제작2:명시적 연결(Explicit Linking)
암묵적 연결과 명시적 연결은 DLL을 참조하는 방식에 따라 구분한다.
소스코드 내에 DLL 연결 코드가 명시적으로 존재한다면 명시적 연결방법.
암묵적 연결방법은 소스코드 내에 DLL 연결에 대한 명시적인 코드가 존재하지 않는다.
명시적 연결에서는 .lib파일이 필요없다.
필요한 DLL이름을 명시적으로 지정하기 때문이다.
따라서 암묵적 연결에서 보여준 .lib 파일에 관련된 일체의 작업들이 명시적 연결에서는 필요 없다.

DLL 명시적 연결 관련 함수
                           DLL
       |void DllFunc(int val)|
	     │               ↑
     LoadLibrary     FreeLibrary
	     ↓               │         프로세스 가상 메모리
|      |void DllFunc(int val)|                      |
                 │
		   GetProcAddress
		         ↓
      DllFunc 함수 포인터 획득
LoadLibrary 함수는 필요한 DLL을 프로세스 가상 메모리에 매핑하는 기능을 제공한다.
그리고 GetProcAddress 함수를 통해 필요한 함수의 포인터를 획득한다.
이렇게 획득한 함수 포인터를 이용해 DLL이 제공하는 함수를 호출할 수 있다.
마지막으로 FreeLibrary 함수를 호출해 DLL을 반환한다.
DLL의 반환은 가상 메모리에서의 반환을 의미할 뿐, 물리 메모리에서의 반환을 의미하지는 않는다.
DLL을 참조하는 프로세스가 하나도 존재하지 않는 시점이 물리 메모리에서 DLL이 반환되는 시점이다.
HMODULE LoadLibrary(LPCTSTR lpFileName);
If the function fails, the return value is NULL.
lpFileName:프로세스 주소 공간으로 매핑시킬 DLL 이름을 지정한다. 경로 정보를 포함하지 않고 파일 이름만 지정하면,
표준 검색 경로를 기준으로 지정된 이름의 파일을 찾는다. 그리고 확장자는 생략할 수 있고, .dll로 인식.

함수 호출 성공 시 DLL 모듈의 핸들을 반환한다.
이 핸들은 이후에 함수 포인터를 얻는데 사용된다.
FARPROC GetProcAddress (
	HMOUDULE hModule, 1)
	LPCSTR lpProcName 2)
);
If the function fails, the return value is NULL.
1)hModule:사용하고자 하는 함수나 변수가 속해 있는 DLL 모듈의 핸들을 인자로 전달한다. 이 핸들은
LoadLibrary 함수 호출을 통해서 얻은 핸들이다.
2)lpProcName:찾고자 하는 함수의 이름을 지정한다.

lpProcName에서 지정한 함수의 함수 포인터를 반환한다.
BOOL FreeLibrary (
	HMODULE hModule 1)
);
If the function fails, the return value is zero.
1)hModule:반환하고자 하는 DLL 모듈의 핸들을 인자로 전달한다. LoadLibrary 함수를 통해 매핑된 DLL 모듈은
반드시 이 함수를 통해 해제되어야 한다.

프로세스는 내부적으로 DLL의 레퍼런스 카운트를 계산한다.
LoadLibrary 함수 호출 시 지정된 DLL의 레퍼런스 카운트는 1씩 증가하고, FreeLibrary 함수 호출 시 지정된
DLL의 레퍼런스 카운트는 1씩 감소한다.
레퍼런스 카운트가 0이 되는 때에 해당 DLL은 프로세스 가상 메모리에서부터 해제된다.
물리 메모리가 아니라 가상 메모리이다.
DLL의 레퍼런스 카운트는 프로세스별로 독립적이다.
공유하는 프로세스 횟수를 나타내기 위한 정보가 아니다.
이러한 레퍼런스 카운트를 두는 이유는 프로그램 실행 중에 DLL을 가상 메모리에 할당 및 해제할 수 있도록 하기 위한 것.
암묵적 연결방법을 사용할 경우에는 이러한 장점을 얻을 수 없다.
명시적 연결에서는 .lib파일이 필요없다.
21_4.cpp ExplicitDll.cpp

명시적 연결방법을 사용할 때 얻게 되는 장점
1)DLL이 필요한 시점에서 로딩하고, 불필요해지면 반환하기 때문에 메모리가 절약된다.
(레퍼런스 카운트가 기반이 되어 제공되는 기능).
2)프로그램 실행 중에 DLL 교체 및 선택이 가능하다. 예를 들어 First.dll과 Second.dll이 있으면 이 두 개의 DLL안에
정의되어 있는 함수 이름은 같지만 기능이 다르다. 사용자 입력 및 선택에 따라서 First.dll 혹은 Second.dll 중
하나를 선택해서 메모리에 로딩하는 것이 가능하다.
3)암묵적 연결방식은 프로그램 실행 전에 필요한 모든 DLL을 메모리에 로딩한다. 때문에 실행까지 걸리는 시간이 
길 수 있다. 반면에 명시적 연결방식은 필요한 순간에 하나씩 DLL을 로딩할 수 있기 때문에 그만큼 실행까지 걸리는 시간이
짧고, DLL 로딩에 걸리는 시간을 분산시킬 수 있다.

그럼에도 암묵적 연결방법을 선호하는 이유는 코드의 간결성 때문이고 사용하기 쉽기 때문이다.

한 번 이상 로드될 수 있는 DLL
DLL은 물리 메모리에 한번 올라가면, 이 DLL을 공유하는 프로세스가 모두 종료될 때까지 물리 메모리에 존재한다.
[단계 1]
프로세스 AAA가 실행된다. 그런데 이 프로세스는 Best.dll을 필요로 한다. 따라서 이 DLL은 가상 메모리 영역에 
매핑되면서 메모리에 올라간다. 메모리에 올라간다는 것은 물리 메모리에 할당되는 것을 의미한다.
[단계 2]
Best.dll을 필요로 하는 또 다른 프로세스 BBB가 실행된다. 그러나 이번에는 Best.dll을 물리 메모리에 올리지 않는다.
이미 한번 올렸기 때문에 올라간 메모리를 그대로 참조할 수 있도록 BBB 프로세스의 가상 메모리 영역에 매핑만할 뿐.
                    물리 메모리에 할당된 Best.dll
                          |...           | ─────────┐
AAA.exe 가상 메모리               ↓메모리 매핑        │메모리 매핑
|                         |              |       |  │
BBB.exe 가상 메모리               ↓──────────────────┘
|                         |              |       |
이런 메커니즘을 Memory Mapping이라 한다. DLL은 이 메커니즘을 기반으로 완성된다.
Best.dll이 할당한 가상 메모리 주소는 모든 프로세스가 동일한 주소에 할당했다.
이것이 DLL 공유가 가능한 이유이다.
두 프로세스가 동일한 DLL을 동일한 가상 주소에 매핑했기 때문에 페이지 단위로 공유가 가능한 것.
[단계 3]
프로세스 AAA가 종료되었다. 그러나 AAA 실행 시 메모리에 올라갔던 Best.dll은 여전히 남아 있다. BBB를 위해
					물리 메모리에 할당된 Best.dll
						  |...           | ─────────┐
                                                    │메모리 매핑
                                                    │
BBB.exe 가상 메모리               ↓──────────────────┘
|                         |              |       |
[단계 4]
마지막으로 프로세스 BBB도 종료되었다. 이번에는 Best.dll을 참조하는 프로세스가 하나도 존재하지 않으므로
Best.dll도 함께 반환된다. 즉 할당된 물리 메모리를 반환하게 된다.
처음 DLL이 빌드될 때 DLL이 할당되어야 할 가상 메모리 주소가 Linker에 의해 결정된다. 만약에 Best.dll을
0x10000000번지에 매핑하기로 결정한다면, 모든 프로세스는 0x10000000번지에 Best.dll의 주소를 매핑시킨다.
DLL 1차 로딩
AAA.exe 가상 메모리
|         |Best.dll|         |
BBB.exe 가상 메모리
|         |Good.dll|         |
DLL 2차 로딩
AAA.exe 가상 메모리
|         |Best.dll|         |
BBB.exe 가상 메모리
|         |Good.dll||Best.dll|프로세스 가상 메모리
DLL 1차 로딩 상태를 보면 프로세스 AAA와 프로세스 BBB는 각각 동일한 주소에 Best.dll과 Good.dll을 올려 놓았다.
이 상황에서 프로세스 BBB가 추가로 Best.dll을 필요하게 되었다. 결국 Best.dll을 올리게 되는데, 프로세스 AAA가
올린 주소에 Good.dll이 로딩되어 있는 관계로 다른 주소의 메모리 영역에 Best.dll을 올리게 된다.
이러한 상황이 발생하면 두 개의 Best.dll이 물리 메모리에 올라가게 된다.
즉 DLL도 물리 메모리에 두 번이상 올라갈 수 있다.

03 도대체 헤더파일을 몇 개나 만들 작정이야!
필요한 헤더파일의 개수는 최소한 세 개
C++ 컴파일러로 빌드된 DLL이 있다.
이 DLL은 C프로그램에서, 그리고 C++ 프로그램에서도 사용된다고 가정하면 필요한 헤더파일의 개수는?
일단 DLL을 만드는 과정도 일반 프로그램 개발과 별차이가 없는 관계로 헤더파일을 필요로 한다.
DLL을 구성하는 파일의 개수가 많아지고, 둘 이상의 함수 호출이 하나의 DLL 인터페이스를 구성한다면
헤더파일은 분명히 필요하다.
그리고 암묵적 연결방식의 DLL 사용자를 위한 헤더파일도 제공해야 한다.
그런데 DLL을 빌드할 때 필요로 하는 함수 선언과 DLL을 참조할 때 필요로 하는 함수 선언이 다르다.
하나는 import 선언을, 다른 하나는 export 선언을 해야만 한다.
이를 위해서 두 개의 헤더파일이 필요하다.
DLL 사용자 관점에서 C++컴파일러의 이름 변환을 막기 위해서 extern "C" 선언이 필요하다.
반대로 C컴파일러 입장에서는 절대 extern "C" 선언이 등장하면 안된다.
이름 변환을 하지 않기 때문에 불필요할 뿐만아니라, C++키워드인 관계로 C컴파일러가 이해하지 못한다.
이 문제를 피하기 위해 C컴파일러용 헤더파일과 C++컴파일러용 헤더파일을 따로 만들어야 한다.
아무 대책 없이 DLL을 개발하고 배포한다면 적어도 세 개의 헤더파일이 필요하다.

하나의 헤더파일로 모두 지원하기
헤더파일의 개수가 둘 이상이면 관리하기 힘들어지고 문제 발생의 소지도 높다.
하나를 변경할 경우, 다른 헤더파일들도 변경해야 하는 문제가 따르기 때문.
따라서 가급적이면 DLL 개발과정에서 등장한 하나의 헤더파일이 모든 상황에 적합하도록 디자인.
21_5.cpp Calculator.h
둘 이상의 함수에 extern "C" 선언을 할 경우에 묶어서 선언하는 것이 가능하다.
extern "C"
{
	int Add(int a, int b);
	int Min(int a, int b);
}
만약에 C컴파일러로 컴파일이 이뤄진다면, extern "C" 선언을 빼야 한다.
그러면 하나의 헤더파일로 모든 컴파일 상황을 처리할 수 있다.

DLL을 만들기 위해 사용되므로 매크로 _COMPLING_DLL_CALCULATOR가 정의
21_6.cpp Calcaultor.cpp
매크로 선언을 헤더파일 선언보다 위에 놓아야 한다.

21_7.cpp UseDll.cpp

이것만은 알고 갑시다
1. 정적 라이브러리와 DLL
정적 라이브러리와 DLL을 만들 수 있어야 한다. 그리고 각각의 특성을 정확히 파악하고 있어야 한다.
2. 정적 라이브러리의 특성
정적 라이브러리의 특성은 실행파일 안에 라이브러리가 하나로 묶인다는 것. 따라서 실행파일의 크기는
커지지만 실행파일만 있으면 언제 어디서든 실행 가능하다는 특징.
3. DLL의 특징
DLL의 가장 큰 특징은 실행파일 안에 포함되지 않고, 프로그램 실행 시에 참조된다는 점. 따라서 실행파일의
크기가 작다. 또한 물리 메모리에 한번 올라간 DLL은 둘 이상의 프로세스가 각각 자신의 가상 메모리에 매핑해서
공유하는 구조를 지니기 때문에 메모리 사용에 대한 효율성이 높다.
4. DLL에서 헤더파일을 정의하는 방법

*/