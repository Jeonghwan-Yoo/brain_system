/*
C,C++과 같은 언어는 함수의 연속된 호출을 통해서 프로그램 흐름을 형성한다.
함수호출이 어떻게 이뤄지는지 그 과정을 이해해야만 함수 호출과 더불어 CPU연산방식을 보다 깊게 이해할 수 있다.
함수가 호출되는 원리와 호출이 될 때마다 할당되는 메모리 관리방식에 대해서.

01 절차적 함수 호출(Proceduce Call) 지원 CPU 모델
함수 호출도 CPU의 도움을 받아야 가능하다.
함수가 호출되는 방식은 CPU에 따라 차이를 보인다.
ARM코어에서는 ATPCS(ARM Procedure Call Standard)라는 것을 정의한다.
이는 함수의 전달인자와 리턴 어드레스(함수 호출이 완료되고 나면 되돌아 갈 주소)를 레지스터에 저장하기로 결정하고,
그 저장방식에 대한 표준을 정의한 것이다.
따라서 이 표준을 고려하여 ARM코어의 레지스터들도 디자인되어 있고, ARM컴파일러도 표준에 맞게 바이너리 코드를
생성하도록 디자인되어 있다.

Stack Frame 구조
함수 내에 선언된 변수가 스택에 할당된다.
int main(void)
{
	int a = 1;           |b = 2| ┐
	int b = 2;           |a = 1| ┘ Stack Frame
	fct1();     ──┐
	...           │
}                 │
void fct1(void) <─┘  
{                        |d = 4|
	int c = 3;           |c = 3|
	int d = 4;           |b = 2|
	fct2();     ──┐      |a = 1|
	...           │
}                 │
void fct2(void) <─┘      |f = 6|
{                        |e = 5|
	int e = 5;           |d = 4|
	int h = 6;           |c = 3|
	...                  |b = 2|
}                        |a = 1|
함수 호출 과정에서 할당되는 메모리 블록(지역변수의 선언으로 인해 할당되는 메모리 블록)을 가리켜 스택프레임.
main 함수 내에 변수 a와 b가 선언되어 있따.
따라서 변수 a와 b가 할당되어 main함수의 스택 프레임을 구성한다.
함수 호출이 완료되면(return 되면) 기존에 선언된 지역변수에 접근이 불가능하다.
이는 할당되었던 메모리가 반환되었음을 의미하는 것.
"fc2 함수가 호출되면서 이 함수 내에 선언된 변수 e와 h가 스택에 할당되는데, 이 메모리 블록을 가리켜 스택 프레임
이라 한다. fc2 함수가 반환되면 이 스택 프레임은 모두 반환된다."

sp 레지스터
지역변수를 위한 메모리 공간을 스택이라하는 이유는 메모리의 구조적 특성 LIFO때문이다.
스택 프레임은 가장 먼저 할당되면, 가장 나중에 반환된다. 
스택에 데이터를 쌓거나 반환하기 위해서는 현재 어느 위치까지 데이터를 저장했는지 기억해야만 한다.
이를 위해서 CPU내에 sp(Stack Pointer)라는 이름의 레지스터가 존재한다.
|r0    | ┌ 최종 sp 위치 ─> |     |  ┐
|r1    | │                |f = 6|  │fct2 반환 후 sp 위치
|r2    | ├ fct2 호출 전 ─> |e = 5| <┘
|r3    | │                |d = 4|  │fct1 반환 후 sp 위치
|r4  ir| ├ fct1 호출 전 ─> |c = 3| <┘
|r5  sp|─┤                |b = 2|  │
|r6  lr| └ 시작 sp 위치 ─> |a = 1| <┘
|r7  pc|    
변수 a, b, c의 순으로 스택에 할당되고 있다.
sp레지스터값은 이렇게 변수가 하나하나씩 할당될 때마다 증가한다.
증가하면서 다음 변수가 할당될 메모리 위치를 가리키게 된다.
호출된 함수가 종료될 경우, 스택 프레임 단위로 sp레지스터값을 이동시켜야 한다.
호출된 함수가 종료될 경우 그 안에서 선언된 변수들을 동시에 모두 반환해야 하기 때문이다.
변수가 선언되면 현재 sp가 가리키는 위치에 할당하기 때문에, sp위치를 아래로 이동시키는 것만으로도
이전에 선언된 변수를 반환할 수 있다.

스택은 주소값이 위로 올라갈수록 증가하는 구조일 수도 있고, 아래로 내려갈수록 증가하는 구조일 수도 있다.
이는 시스템 구성에 따라 달라지는 특성인데, 필자는 위로 갈수록 주소값이 증가하는 구조를 기본.

스택에 메모리를 할당할 때 sp값의 증가분은 계산 가능하다.
할당하려는 순간, 할당하고자 하는 대상 타입에 따라서 sp를 이동시키면 되기 때문.
변수가 4바이트면 sp 값을 4만큼 증가시키면 된다.
그러나 호출이 완료된 함수를 빠져 나오는 시점에서, 함수 내에서 할당된 메모리 공간을 반환하기 위해
스택 프레임 단위로 sp를 아애로 이동시킬 때는 문제가 된다.
얼마만큼 sp를 이동시켜야 할지 알 수가 없기 때문.
CPU는 우리가 시키는 일만 단순하게 처리할 뿐이다.
프로그램 코드를 통해서 우리가 명령하는 것들을 순차적으로 이행만 할 뿐.
따라서 정작 호출이 완료된 함수를 빠져 나오는 시점에서, 앞서 얼마만큼의 메모리 공간을 할당했는지 모른다.
때문에 이를 위한 특별한 장치나 방법이 추가적으로 필요하다. 프레임 포인터 레지스터.

Frame Pointer 레지스터
레지스터 하나를 추가로 할당하는 방법을 고려해 볼 수 있다.
새로운 함수가 호출될 때마다 이 레지스터값을 0으로 초기화한다.
그리고 변수가 선언될 때마다 그 크기만큼 값을 증가시키는 방식.
이 방법은 변수를 선언할 때마다 덧셈 연산을 해야한다는 단점이 있다.
이는 스택 연산에 드는 비용을 상당히 늘리는 결과를 초래한다.
다만 되돌아갈 sp위치만 저장해 놓아도 된다.
이 역할을 하는 레지스터를 가리켜 fp레지스터라 한다.
함수 fct1 호출 시
|r3    |            |     | 12
|r4  ir|  ┌───────> |     | 8 <── fp register
|r5  sp| ─┘         |b = 2| 4
|r6  lr|            |a = 1| 0
|r7  pc|
함수 fct1 반환 이후
|r2    |  ┌-------> |     |
|r3    |  │         |d = 4| 12 fct1 스택 프레임 반환.
|r4  ir|  ┌───────> |c = 3| 8 <── fp register
|r5  sp| ─┘         |b = 2| 4
|r6  lr|            |a = 1| 0
|r7  pc|
"함수 fct1 호출 시"는 fct1함수를 호출하는 과정에서 sp레지스터에 저장된 값을 fp레지스터에 저장하는 상황.
fct함수 내에서 아무리 많은 변수를 선언해도 fp 레지스터에 저장된 값을 참조해서 fct1 함수 호출 이전 위치로
sp를 이동시킬 수 있다.
"함수 fct1 반환 이후"에서는 fct1 함수 호출이 끝난 상황이다.
fct1함수 호출 시 fp레지스터에 저장했던 sp레지스터값을 다시금 sp 레지스터에 되돌린다.
그러나 함수 호출로 함수 호출이 중첩된다면 심각한 문제가 발생한다.
함수 fct1 호출시
sp = 8 ,fp = 8 
함수 fct2 호출시
sp = 16, fp = 16
잠시 후에 fct1함수는 fct2함수를 호출한다.
fct2함수의 스택 프레임 반환을 위한 주소 정보를 fp레지스터에 저장하는 과정에서 fct1함수의 스택 프레임 반환을
위해 저장해 놓은 주소값을 덮어 써버리고 만다.
fct2 함수를 반환하는 과정에서는 fp레지스터에 저장된 값을 sp 레지스터에 대입한다.
따라서 sp레지스터는 fct2함수 호출 이전 위치를 가리키게 될 것이고, 이는 fct2함수 스택 프레임을 반환하는 결과.
fct1함수를 반환할 때 다시 한번 fp 레지스터값을 참조할 수 없게 된다.
왜냐하면 fct1함수를 호출할 때 저장해 놓은 fp레지스터값을 fct2함수를 호출하면서 덮어써버렸기 때문.
그래서 기존 위치에 대한 정보는 어디에도 없다.

스택에 저장하자, Frame Pointer
덮어쓰는 문제가 발생하기 전에, fp에 저장된 값을 어딘가에 저장해 두면 된다.
즉 함수 호출이 일어날 때마다 fp레지스터에 저장되어 있는 값을 스택에 저장하는 것.
그리고나서 새로운 값으로 fp레지스터를 채운다.
|f = 6| 28
|e = 5| 24
|8번지| 20
|d = 4| 16
|c = 3| 12
|0번지| 8
|b = 2| 4
|a = 1| 0
fp:0 -> 8 -> 20
sp 레지스터에 저장된 갑승ㄹ fp레지스터에 옮기기 전에, fp레지스터에 저장된 값을 스택에 쌓아두면,
모든 택프렘임의 경계정보를 저장할 수 있다.
[1단계]
fct2함수가 호출되기 직전에 sp레지스터에는 주소값 20이 들어가 있다. 현재 스택 주소를 가리키는 것.
[2단계]
fct2함수가 호출되기 직전에 fp레지스터에는 주소값 8이 들어가 있다. main함수와 fct1함수의 경계에 해당하는 주소정보.
[3단계]
fct2함수가 호출되면서 fp레지스터에 저장된 값(8)을 현재 sp레지스터가 가리키는 위치 20번지에 먼저 저장한다.
그 다음 fp레지스터에 sp레지스터값 20을 저장한다.
이 값은 fct1스택과 fct2스택의 경계가 된다.
[4단계]
이후 fct2함수 호출이 완료되어 반환하고자 한다면, fp레지스터에 저장된 값을 참조해서 sp레지스터값을 20으로 변경.
이는 fct2함수의 스택 프레임을 날리는 효과.
[5단계]
현재 sp가 가리키는 위치(20)에 저장되어 있는 값을 fp에 옮겨다 놓는다. 이로써 fct1함수 호출이 완료되는 상황에서
sp의 위치를 8번지에 가져다 놓을 수 있게 되었다. 이는 main스택과 fct1스택의 경계가 된다.

02 함수 호출 인자의 전달과 PUSH & POP 명령어 디자인
어셈블리도 잘 정의된 명령어를 제공함으로써 레지스터를 직접 컨트롤하는 수고를 덜어준다.
입력에 대한 출력이 반환값으로 존재하면 함수 호출이라 하고, 출력에 해당하는 반환값 없이 모듈화해 놓은
서브 루틴의 실행을 위한 호출을 가리켜 프로시저 호출이라 한다.

함수 호출 인자의 전달방식
함수 호출 시 전달되는 인자를 어디에다 둘 것이냐에 대한 해답도 CPU마다, 혹은 제조사의 표준마다 다르다.
모든 전달 인자들이 반드시 스택에 할당되는 것은 아니다.
성능 향상을 위해서 일부 전달인자들은 레지스터를 할당해서 이곳에 저장하도록 제품의 표준을 정의하기도 한다.
레지스터는 항상 여유가 있어야 한다.
그래서 일단 함수 호출 시 전달되는 인자들은 모두 스택에 저장하자.
호출된 함수 내부에서 선언되는 지역변수 이외에도, 호출 시 전달되는 인자값과 스택 프레임의 경계 정보까지
스택에 저장되는 구조라고 할 수 있다.
지역변수가 스택에 할당되는 방식과 동일하다.
void function (int a, int b)
{
	int c= 9;
	...
}
function(7, 8);         
|...|
| 8 |
| 7 |
|...|
function이 호출되면서 두 개의 숫자 7과 8이 전달되고 있다.
따라서 현재 sp가 가리키는 위치에 7을 저장하면서 sp값을 증가시킨 다음, 다시 8을 저장하면서 sp값을 증가.

PUSH & POP명령어 디자인
"sp가 가리키는 현재 위치에 전달되는 인자값을 저장하고 나서, sp를 증가시켜 다음 메모리 주소를 가리키게 한다."
명령어를 구상해보자
STORE명령어를 이용해 첫 번째 전달인자인 숫자 7을 현재 sp레지스터가 가리키는 메모리 영역에 저장하고자 한다.
STORE 7, sp(불가)
"STORE명령어의 첫 번째 피연산자로 숫자 7이 등장한다. 그러나 이 위치에는 레지스터 정보가 와야 한다."
"STORE명령어의 두 번째 피연산자로 레지스터 정보 sp가 왔다. 그러나 이 위치에는 주소 정보가 와야 한다."
첫 번째 문제는 숫자 7을 임의의 레지스터에 저장하면 숫자 7을 대신해서 레지스터 이름을 피연산자로 둘 수 있다.
ADD r1, 7, 0
일반적으로 어셈블리에는 MOV명령어나 유사한 기능의 명령어가 있어 대입 연산이 가능하다.
즉 레지스터 간에 대입, 레지스터에 숫자 대입을 용이하게 하기 위한 MOV라는 명령어를 제공한다.
STORE r1, sp
두 번째 문제는 Indirect모드의 도움을 받아야 한다.
Indirect모드 연산을 위해 sp가 지니고 있는 값을 0x40번지(다른 주소도 가능)에 저장한다.
STORE sp, 0x40
이제 Indirect모드로 0x40번지를 참조해서 데이터를 저장하는 것이 가능하다.
STORE r1, [0x40]
|r1    |<──── 1)ADD r1, 7, 0         ...
|r2    |  └── 3)STORE r1, [0x40] ──>|  7 | 0x80
|r3    |                            |    |
|r4  ir|(sp가 현재 0x80이라고 가정)   |    |
|r5  sp|───── 2)STORE sp, 0x40 ────>|0x80| 0x40
|r6  lr|                             ...
|r7  pc|
스택에 데이터를 저장한 다음에는 다음에 들어오는 데이터를 저장하기 위해 반드시 sp레지스터값을 증가시켜야 한다.
ADD sp, sp, 4
최종적으로
ADD r1, 7, 0
STORE sp, 0x40
STORE r1, [0x40]
ADD sp, sp ,4

	          |    |<──sp
PUSH 0x02 ──> |0x02|<--
	          |0x01|
데이터를 스택에 넣고자 하는 경우
PUSH 0x02 or PUSH r1
현재 sp값을 참조해서 해당 위치에 데이터 0x02혹은 레지스터 r1의 값을 저장하고 sp의 값 또한 자동으로 증가.
	    |    |<--
POP ──> |    |<──sp
	    |0x01|
POP은 스택에 가장 마지막에 들어간 데이터를 꺼낸다는 의미하고 메모리에서 삭제한다는 것을 의미한다.
때문에 실질적인 일은 sp레지스터에 저장된 값을 감소시키는 것이다.
POP을 4바이트 단위로 제한해 버리면 피연산자가 불필요한 명령어가 된다.
POP //ADD sp, sp, -4 or SUB sp, sp, 4
명령어의 바이너리 구조는 중복되지 않게만 정의하면 된다.

void function(int a, int b)
{
	int c = 9;
	...
}
function(7, 8);
function 함수 호출 이전의 상황
|    | 0x80 <── sp
|... |
|0x20| 0x40 <── fp
function 함수 호출 이후의 상황
PUSH fp
ADD fp, sp, -4
PUSH 7
PUSH 8
|    | 0x8c <── sp
|  8 |
|  7 |
|    | 0x80 <── fp
|... |
|0x20| 0x40 
함수가 호출되면, 현재 fp에 저장된 주소 정보를 스택에 쌓는 일이 제일 먼저 진행된다.
sp에 저장된 값을 fp에 저장해야 하기 때문에 fp를 비워야한다.
PUSH fp
fp 레지스터에 저장된 값을 스택으로 옮겨 놓았으면, sp의 값을 fp에 저장할 차례이다.
레지스터간 데이터 이동에 관련된 명령어를 만들지 않았으므로
ADD fp, sp, -4
fp의 값을 PUSH했기 떄문에 sp값이 4만큼 증가한 상황이었다.
때문에 sp의 값에서 4만큼 뺀 값을 fp에 저장해야만 결과를 얻을 수 있다.
만약에 4만큼을 뺴지 않는다면, fp는 숫자 7이 저장된 위치를 가리키게 된다.
전달인자를 스택에 쌓으면
PUSH 7
PUSH 8

03 함수호출(Proceduce Call)에 의한 실행의 이동
다시 살펴보는 메모리 구조와 Program Counter
 Code↕ |     명령어   | <── PC register
 Data↕┌|   전역변수   |
     │└|  static 변수 | 
 Heap↓ |프로그래머 할당|
Stack↑┌|    지역변수  |
     │└| 전달인자 정보 | <── SP register
메모리 구조에서 관심을 가질 영역은 "코드 영역"이다.
코드 영역은 프로그램이 동작하기 위한 프로그램 코드(컴파일된 명령어들의 집합)가 올라가는 위치이다.
프로그램을 실행시키면 위와 같은 메모리 구조가 형성되고 코드 영역에, 실행되어야 할 명령어들이 올라가서
순차적인 실행이 이뤄지게 된다.
첫 번째 단계가 명령어를 CPU내부로 가져오는 Fetch단계인데, 이때 명령어를 가져오게 되는 위치는 코드영역이다.
따라서 컴파일된 프로그램 코드가 코드 영역에 올라간 다음부터 명령어는 순서대로 Fetch, Decode되고 Execution.
명령어의 길이가 4바이트라고 하고 실행 중인 프로그램이 현재 1036번지에 있는 명령어라면, 다음 번에는
1040번지에 있는 명령어가 Fetch되어야 한다.
어느 위치에 있는 명령어까지 가져와 실행했는지 기억하고 있어야만 다음 번에 실행할 명령어를 가져올 수 있다.
명령어를 순차적으로 fetch하기 위해서 프로그램 카운터라고 불리는 PC 레지스터를 둔다.
CPU는 Fetch, Decode, Execution과정을 계속해서 진행하도록 구현되어 있기 때문에, Fetch연산이 일어날 때마다
자동적으로 pc값이 증가한다.
따라서 직접 pc값을 컨트롤하지 않아도 된다.
CPU내부──────┐fetch     
│IR Register │<───|Command1|┐ 
│PC Register │───>|Command2|│code 영역
└────────────┘    |...     |┘
fetch가 일어나면 Command1에서 Command2로 이동.
ir은 명령어를 가져오기 위해서 사용되는 레지스터.
필요에 따라서는 프로그램상에서 pc값을 직접 조절해야만 하는 경우도 발생한다.

필자의 학창 시절 오해
폰 노이만이 정의한 컴퓨터 구조는 모든 명령어가 컴퓨터의 메모리에 저장이 되어 순차적으로 실행되는 구조.
컴퓨터는 여전히 순차적인 명령어의 실행을 위해서 명령어 크기만큼 pc값을 증가시켜 가며 명령어를 Fetch, Decode,
Execution하고 있다.

함수 호출과 함수 종료
"함수 호출 시 실행위치의 이동은 어떻게 이뤄지는가?"
"함수 호출 시 전달하는 인자들은 어떻게 함수 내부로 전달되는가?"
"함수 호출이 끝나고 나면 어떻게 이전에 실행하던 위치로 복귀하는가?"
함수 호출이 가능하기 위해서는 순차적인 실행만으론 부족하고 특정 위치로의 이동이 가능토록 해야한다.
함수 호출이 발생할 때, 그리고 호출된 함수에서 복귀할 때 특정 위치로의 이동이 필요하다.
32비트 명령어 기준으로 pc는 명령어를 실행할 때마다 4씩 증가한다.
이 pc에 함수 호출로 인해 이동해야 할 주소값을 저장해 두면 자연스럽게 실행의 위치는 이동하게 된다.
그런데 pc에 이동해야 할 주소값을 저장하기 전에 반드시 해줘야 할 일이 있다.
현재 pc값을 백업하는 일이다.
백업해 두지 않는다면 함수 호출이 완료된 이후에 돌아오는 길이 막연해진다.
스택을 사용하여 백업을 할 수 있고 함수 호출 시 스택에 저장해야 할 대상이 하나 더 늘어난 셈.
함수 호출이라는 것도 CPU입장에서는 순차적으로 명령어를 실행할 뿐이다.

함수의 호출과 반환과정은 두 가지 관점에서 볼 수 있다.
하나는 스택의 관리방법이고, 다른 하나는 프로그램 실행위치의 관리방법이다.
함수가 호출되면, 현재의 pc값은(함수 호출 완료 시 되돌아갈 주소값은) 레지스터에 저장하는 것이 일반적이다.
lr을 이러한 목적으로 사용하고자 했다.
fp레지스터에 저장된 정보는 함수 호출이 계속 이어지면 fp에 저장된 값을 스택에 옮겨놔야 한다.
lr에 저장된 정보도 함수 호출이 계속되면 스택에 옮겨놔야 한다.
그리고 호출된 함수가 반환하는 경우에 스택에 저장된 fp값이 fp레지스터에 복원되는 것과 동일한 방식으로 lr도 복원.
스택의 관리를 위해 fp가 있다면 프로그램 흐름의 관리를 위해 lr이 있다.

04 Calling Convention
함수 호출규약이란?
전달되는 순서대로(왼쪽 인자부터)인자가 스택에 쌓이는 구조를 부여주지만 반대로 전달되는 순서의 역순으로
(오른쪽 인자부터)스택에 쌓이는 구조도 존재할 수 있다.
전달인자의 스택을 쌓는 방법에 두 가지가 존재하듯이, 함수 호출과정에서 할당된 스택 프레임을 반환하는 방법에도
두가지가 존재하고, Hybrid방식이라는 것도 존재한다.
스택 프레임의 반환은 함수 호출이 완료된 이후의 동작(sp복원 등)을 의미하는데 이 주체는 Caller가 될 수도 있고,
호출이 된 함수(Function)이 될 수도 있다.
예를 들어 A함수가 B함수를 호출하는 프로그램 코드가 있을 때 A는 호출자가 된다.
이 코드를 컴파일하고 나면, 스택 프레임을 정리하는 명령어들이 A함수에 존재할 수도 있고, B함수에 존재할 수도 있다.
이렇게 스택 프레임을 정리하는 코드가 어디에 존재하느냐에 따라 방법이 나뉜다.
이처럼 함수 호출 시 인자를 전달하는 방식과 스택 프레임을 반환하는 방식을 약속해 놓은 것을 함수 호출규약.

__cdecl, __stdcall + a
__stdcall은 함수 호출 규약을 지정하는 것으로 STDCallFunction함수의 호출과 반환을 처리하라는 뜻이다.
int __stdcall STDCallFunction(int a, int b, int c);
WINAPI, APIENTRY, CALLBACK도
#define CALLBACK __stdcall
#define WINAPI __stdcall
Windows시스템 함수선언에서는 키워드 __stdcall를 직접 사용하지 않는다.
이보다는 CALLBACK이나 WINAPI라는 또 다른 이름을 부여해 그 함수의 특성 파악에 도움을 주도록 하고 있다.
int CALLBACK EventRoutin(void);
CALLBACK은 실제로 __stdcall로 정의되어 있으므로, __stdcall호출 규약을 따를 것이다.
또한 이 함수가 CALLBACK함수임을 더불어 알 수 있다.
모든 함수들은 함수 호출규약이 선언되어야 하는데 프로젝트 속성에서 디폴트 선언을 지정할 수 있고 디폴트선언을 따른다.

호출규약의 종류와 의미
Segment    Calling                   Parameter       Parameter order   Stack
word size  Convention                in registers    on stack          Cleanup by
32bit      __cdecl                                   C                 Faller
           __stdcall                                 C                 Function
		   __fastcall                ecx, edx        C                 Function
		   __thiscall                ecx             C                 Function
64 bit     Windows(MS, Intel)        rcx/xmm0        C                 Caller
                                     rdx/xmm1        C                 Caller
									 r8/xmm2         C                 Caller
									 r9/xmm3         C                 Caller
           Linux, BSD(GNU, Intel)    rdi, rsi,       C                 Caller
		                             rdx, rcx, r8    C                 Caller
									 r9, xmm0-7      C                 Caller
__cdecl은 C/C++의 디폴트 호출 규약으로 알려져 있다.
인자 전달방식은 C언어 스타일을 따르는데, C언어 스타일이라는 것은 오른쪽에 전달되는 인자가 먼저 스택에 쌓이는 방식.
반환 시에는 함수를 호출하는 호출자가 스택 프레임을 반환하도록 정의되어 있다.
__stdcall와 __cdecl의 차이점은 스택 프레임을 반환하는 주체이다.
__stdcall은 호출된 함수 내에서 스택 프레임을 반환하도록 정의되어 있다.
__fastcall은 함수 호출을 빠르게 처리하기 위한 호출규약이다.
"Parameters in register"부분은 전달되는 인자를 저장할 때 레지스터의 사용유무를 설명한다.
첫 번째 전달인자와 두 번째 전달인자는 레지스터 ecx와 edx를 통해 저장된다.
호출 규약에서 가장 주목할 부분은 레지스터를 사용하고 있다는 점이다.
이것이 함수 호출이 빨라지는 근거가 된다.
물론 두 개를 넘어서는 인자에 대해서는 스택을 활용하게 된다.
64비트 시스템에서는 함수 호출규약이 운영체제에 따라서 나뉘게 된다.
Windows기반에서는 총 8개의 레지스터를 활용해서 전달되는 인자를 저장하게 되는데, 실제로 레지스터에
저장되는 전달인자의 개수는 4개이다.
rcx/xmm0은 첫 번째 전달인자가 rcx나 xmm0레지스터에 저장된다는 것을 의미한다.
따라서 총 4개의 전달인자까지만 레지스터를 통해 처리하다.
반면에 Linux시스템에서는 훨씬 많은 수의 레지스터를 전달되는 인자에 할당하고 있고 최대 14개의 인자까지 레지스터를
통해 처리한다.

이것만은 알고 갑시다
1. 스택이 관리되는 방법
스택에는 단순히 지역변수만 쌓이는 것이 아니고 함수가 호출되는 과정에서도 많은 일이 일어나낟.
2. 함수 호출규약
다양한 함수 호출규약이 존재하며, 어떠한 호출규약을 따를 것인가를 선언하게 되어 있다.
명시하지 않으면 디폴트 선언으로 지정되어 있는 호출규약을 따르게 된다.
3. 전달인자와 레지스터
64비트 CPU는 32비트 CPU와 다른 레지스터 구조를 지닌다. 따라서 32비트 환경과는 다른 함수 호출 규약이 존재한다.
새로운 함수 호출규약에서는 성능의 향상을 위해서 레지스터를 더욱 많이 활용하고 있다.

CallBack함수란 Windows시스템에 의해 자동으로 호출되는 함수를 의미한다.
특정 상황에서 호출되어야 할 함수를 등록시키는 것이 가능한데, 이때 등록이 되는 함수를 가리켜 콜백함수라 한다.
보통 UI와 API의 이벤트 핸들링 관련된 내용에서 자주 접하게 된다.

*/