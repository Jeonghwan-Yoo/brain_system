/*
중요한 것은 작은 그림이 아니라 큰 그림이다.

01 시스템 프로그래밍의 이해와 접근
시스템 프로그래밍(System Programming)이란?
"컴퓨터 시스템을 동작시키는 프로그램"
동작이란 파일 복사나 파일 이동 등과 같이 기본적인 동작.
운영체제는 시스템 프로그램의 범주에 속하고, 운영체제 개발자들을 시스템 프로그래머.
시스템 프로그램이란 하드웨어를 사용할 수 있도록 도와주는 프로그램이 된다.
어셈블리 언어나 C언어를 이용해 하드웨어를 직접 컨트롤하는 개발자들도 시스템 프로그래머.
Windows나 Unix같은 운영체제에서 제공하는 라이브러리(운영체제의 기능을 활용할 수 있는 시스템 함수들의 집합)를
사용하여 프로그램을 개발하는 개발자들도 시스템 프로그래머.
보통 컴퓨터 시스템이라고 하면 하드웨어만을 뜻하는 것이 아니라 하드웨어가 실제 일을 하게끔 도와주는 운영체제를
포함하는 것이 보통이다.
따라서 Windows시스템 프로그래밍이란 Windows운영체제 기반의 컴퓨터에게 일을 시키기 위한 프로그램을 구현하는 것.
이러한 프로그램 작성을 위한 라이브러리는 Windows운영체제에 의해 제공된다.

MSDN을 뒤져서 각각의 함수가 제공하는 기능을 아주 정확히 이해하면 된다.
그렇지만 운영체제에 대한 최소한의 지식이 필요하고 컴퓨터 구조에 대한 기본적인 지식도 필요하다.
그래서 시스템 프로그래밍을 제대로 공부하려면 운영체제와 컴퓨터 구조를 잘 알아야 한다.

컴퓨터 시스템의 주요 구성요소(Main Components)
CPU <-----> Cache <-----> Main Memory <-----> Hard Disk
└────────────────┘        └───────────────────────────┘
Computer Architecture       Operating System
이해하게 되면, 언어의 문법적 요소만을 이해하고 바로 프로그래밍하는 프로그래머들보다 효율적인(속도를 높이고,
메모리를 효율적으로 사용하는) 프로그램을 구현하는 것이 가능해야진다.

02 컴퓨터 하드웨어의 구성
CPU(Central Processing Unit)
┌───────────────────────────────┐
│ ALU <----------> Register Set │
│                      ^        │
│                      │        │
│                      │        │
│                      v        │
│ Control Unit    Bus Interface │
│                       ↑       │
└───────────────────────────────┘ Main Memory
I/O BUS                 ↓             ↕
<────────────────────────────────────────────────>
      ↕           ↕           ↕           ↕
    키보드      모니터    네트워크 카드   하드디스크

CPU(Central Processing Unit)
CPU는 컴퓨터 프로그램의 실행에 있어서 핵심적인 역할을 담당.

Main Memory
RAM이라는 저장장치로 구성되는 메인 메모리는 컴파일이 완료된 프로그램 코드가 올라가서 실행되는 영역.
예를들어 게임 하나를 내려받으면 게임은 하드디스크에 저장된다.
그리고 저장된 디렉터리로 찾아 들어가서 더블클릭을하면 해당 프로그램은 메인 메모리로 올라가서 실행된다.
이렇듯 메인 메모리는 프로그램 실행을 위해 존재하는 메모리.

Input/Output Bus
컴퓨터를 구성하는 구성요소 사이에서 데이터를 주고 받기 위해 사용되는 경로이다.
데이터의 종류와 역할에 따라서 Address Bus, Data Bus, Control Bus.
하드디시크에 있는 데이터를 메인 메모리로, 메인 메모리에 있는 데이터를 하드디스크에 전송하는 것이 가능하고,
메인 메모리와 CPU사이에서의 데이터 입출력도 가능하다.
이러한 기능성을 제공하는 것이 버스 시스템이다.

03 CPU에 대한 이해
ALU(Arithmetic Logic Unit)
CPU내부에는 실제 연산을 담당하는 ALU라는 블록이 있다.
나머지 블록들은 연산을 하는데 도움을 주는 블록들.
ALU가 처리하는 기본적인 연산은 덧셈이나 뺄셈과 같은 산술 연산이고, AND나 OR같은 논리 연산이다.

Control Unit
프로그래머가 작성한 프로그램을 컴파일하면 실행파일이 생성된다. 
실행파일에는 CPU에게 일을 시키기 위한 명령어들이 저장되어 있다.
어떤 경로를 거치던 간에 이 명령어가 CPU내부로 흘러 들어가야 CPU에게 일을 시킬 수 있다.
CPU내부의 ALU로 명령어가 전송되었다고 가정하면 1과 0으로 구성된 32비트 명령어가 전송되었을 것이다.
그런데 ALU는 이해할 수 없다.
따라서 ALU를 대신해서 누군가가 이 명령어를 해석해 줘야 한다.
도움을 주는 구성요소가 컨트롤 유닛이고 CPU가 처리해야 할 명령어들을 해석하는 일을 한다.
컨트롤 유닛은 명령어를 해석하고, 그 해석된 결과에 따라 적절한 신호를 CPU의 다른 블록에 보내는 일을 한다.

CPU 내부에 존재하는 레지스터들(Register Set)
덧셈명렁어만 흘러간다고 덧셈이 되지 않고, 덧셈의 피연산자도 같이 흘러 들어갔다고 가정해보자.
명령어는 컨트롤 유닛으로, 피연산자 5와 9는 ALU로 보내면 된다.
그러나 ALU는 연산 중에고 컨트롤 유닛도 해석중이라면 불가능할 수도 있다.
그래서 필요로 하는 명렁어 및 데이터들을 어디엔가 저장해 두고 상황이 허락할 때 가져가도록 하면 좋을 것.
즉, CPU내부에도 임시적으로 데이터를 저장하기 위한 조그마한 메모리 공간이 필요한 것.
이러한 메모리가 CPU에 존재하고, 레지스터(Register)라는 아주 작은 메모리가 CPU내에 존재한다.
레지스터란 CPU내부에 존재하는 2진 데이터(Binary Data)저장을 위한 저장장치이다.
CPU에 따라서 16비트, 32비트, 64비트 정도의 데이터를 저장할 수 있는 크기로 구성된다.
이러한 레지스터들을 CPU내부에 여러 개가 존재하는데 CPU의 종류에 따라서 그 개수와 형태가 다양하다.
레지스터들은 각각의 용도가 정해져 있는 것이 일반적이며 CPU가 연산을 하기 위해 반드시 필요하다.

Bus Interface
명령어와 데이터들이 CPU안으로 잘 흘러들어간 것을 가능하게 한 것이 버스 인터페이스가 있기 때문.
컴퓨터 장치들은 서로 독립적으로 동작하는 것이 아니라 서로 데이터를 주고 받으면서 동작한다.
버스에 접근해서 데이터를 전송하기도 하고 입력 받기도 한다.
하지만 I/O버스의 통신방식을 이해하지 못하면 데이터를 보낼 수도 받을 수도 없다.
그래서 CPU내에는 I/O버스의 통신 방식을 이해하고 있는 무엇인가가 필요한데, Bus Interface이다.
버스 인터페이스 장치는 버스가 어떻게 데이터를 전송하는지, 그에 대한 프로토콜 혹은 통신 방식을 알고 있다.
따라서 CPU는 버스 인터페이스를 통해 CPU내부에 저장되어 있는 데이터를 (레지스터에 저장되어 있는 데이터를)
I/O버스에 실어 보내기도 하고, I/O버스를 통해 전송되어 오는 데이터들을 수신하기도 한다.
I/O버스에 연결되는 장치들은 각각 모두 인터페이스가 필요하다.
또한, 인터페이스는 연결되는 장치에 따라 Controller나 Adapter라고 불린다.

Clock Pulse
클럭 신호는 CPU를 구성하는 요소는 아니다.
하지만 CPU를 구성하는 구성 요소에 제공되어야 하는 신호로서 중요한 의미를 가진다.
클럭 신호는 Timing을 제공하기 위해 필요하다.
CPU는 매 클럭이 발생할 때마다 그 클럭에 맞춰서 일을 한다.
따라서 CPU의 클럭속도가 높으면 초당 처리하는 명령어의 개수가 많아지므로 전체적인 성능은 좋아진다.
다시말하면 클럭발생기에 의해 발생되는 Clcok Pulse는 CPU를 구성하는 요소 요소에 제공되며,
이 신호에 맞춰서 CPU가 일을 한다.
컴퓨터 시스템은 동기화를 필요로 하기 때문에 필요한 것.
input1,2 -> +연산장치 -> BUFFER -> 출력장치로만 구성된다고 생각해보자.
input1과 input2를 통해 계속해서 데이터가 들어오고 있으면 +연산장치는 '+'연산을 처리해야 하며, 출력장치는
BUFFER에 존재하는 데이터를 계속해서 가져다가 출력해야 한다.
문제는 +연산장치가 연산하는 속도와 출력장치가 데이터를 가져가는 속도가 일치하지 않는다.
데이터를 가져가는 속도가 더 빠르면 이미 가져가 데이터를 다시 가져가서 출력하는 문제점.
+연산장치가 더 빠르면 버퍼를 덮어쓰게 되어 연산결과의 일부가 출력되지 않을 것이다.
이것을 해결하려면 느린 장치의 장단에 맞추면 된다.
input1,2 -> +연산장치 -> BUFFER -> 출력장치
                ↑          ↑         ↑
                └──── Clock Pulse ───┘
+연산장치의 연산속도가 출력장치보다 느리다면 클럭신호 발생속도를 +연산장치의 연산속에 맞추고 신호에 맞춰서
데이터를 이동시키면 된다.

Embedded System에서 ARM이나 MIPS와 같은 코어들을 직접 다루는 개발자가 늘고있다.
이런 작업을 하면 코어들의 클럭을 프로그램 코드상에서 직접 조절하는 경험을 할 수 있다.
특정 범위 이상으로 높여버리면 시스템이 불안정하게 동작하기 시작한다.
오버 클러킹을 하면 CPU가 고장날 수도 있다.

04 프로그램의 실행과정
위대한 수학자 폰 노이만(J.von Neumann)
오늘날 우리가 사용하고 있는 컴퓨터의 기본 모델을 제시했다.
초창기 컴퓨터는 임의의 연산을 하고자 할 때마다 여러 명의 엔지니어가 달라 붙어 진공간 회로스위치를 변경했다.
폰노이만은 개선된 형태의 컴퓨터를 고민하게 되고 다음과 같은 구조의 컴퓨터를 생각한다.
CPU ↔ 메모리 <---- 프로그램
             Load
폰 노이만은 프로그램이 컴퓨터 내부에 저장되는 구조를 생각해 낸 것이다.
폰 노이만이 주장한 컴퓨터 구조는 "프로그램이라는 것이 존재하고, 이 프로그램은 컴퓨터 내부에 저장되어서 순차적으로
실행되어야 한다."
이런 컴퓨터 구조가 폰 노이만 아키텍쳐이고 이를 바탕으로 최초의 컴퓨터가 EDSAC으로 7년 후에 탄생했다.
폰 노이만 아키텍처는 Stored Program Concept이라고도 한다.

프로그램의 실행과정
실행파일의 생성단계
전처리기 -> 컴파일러 -> 어셈블리 -> 링커

단계1 : 전처리기에 의한 치환 작업
전처리기는 '#'으로 시작하는 지시자의 지시에 따라서 소스코드를 적절히 변경하는 작업.

단계2 : 컴파일러에 의한 번역
단계1에 의해 변경된 소스코드는 여전히 C언어로 구성되어 있다.
이 소스코드는 컴파일러에 의해 어셈블리 코드로 번역된다.
어셈블리 코드란 명령어를 조합해서 만들어진 프로그램 코드.
컴파일러가 없었다면 명령어 체계를 익혀서 프로그램을 작성했어야만 했다.

단계 3 : 어셈블리에 의한 바이너리 코드 생성
바이너리 코드는 1과 0으로만 구성되는 코드다.
컴파일러에 의해 번역된 어셈블리 코드는 컴퓨터에 의해 실행되기에 앞서서 바이너리 코드로 번역되어야 한다.
컴퓨터는 오로지 1과 0만을 이해하기 때문이다.
예를 들어
덧셈을 0011이라고하면 이렇게만 사용하면 불편하니 ADD이런식으로 표를 만들고 표를 참조하여 프로그램을 구현한다.
이런 방식의 프로그래밍이 어셈블리 프로그래밍이다.
테이블을 참조해서 어셈블리 코드를 CPU가 이해할 수 있는 바이어리 코드로 바꾸어 주는 프로그램이 어셈블러.

단계 4 : 링커에 의한 연결과 결합
링커는 프로그램 내에서 참조하는 함수나 라이브러리들을 하나로 묶는(연결시켜 주는)작업을 한다.
이 과정이 끝나면 실제로 실행 가능한 실행파일이 생성된다.
실행파일은 컴퓨터가 실행해야 하는 바이너리 코드로 구성된다.

프로그램의 실행과정을 봐보자
전처리기 -> 컴파일러 -> 어셈블리 -> 링커 -----> 실행파일 ---> 메모리에 Load          CPU
                                                          |명령어 A| --------> |명령어 A|─┐2.Decode   
														  |명령어 B| 1.fetch ┌─|덧셈 !  |<┘     
														  |명령어 C|         └>|덧셈실행|
														                3.Execution
실행파일은 링커에 의해서 최종적으로 만들어진 파일로서, 컴퓨터에게 일을 시키기 위한 명령어(바이너리코드)가 들어 있다.
이것이 메모리 공간에 올라가고 난 다음 CPU에 의해서 실행되기 시작한다.
메모리 공간에 올라간 명령어들은 CPU에 의해 순차적으로 실행된다.
메모리상에서 실행되는 것이 아니라 CPU내부로 하나씩 이동한 다음 실행하게 된다.
1.Fetch:메모리 상에 존자하는 명령어를 CPU로 가져오는 작업.
2.Decode:가져다 놓은 명령어를 CPU가 해석하는 단계.
3.Execution:해석된 명령어의 명령대로 CPU가 실행하는 단계.

05 하드웨어 구성의 재접근
폰 노이만의 컴퓨터 구조 vs 오늘날의 컴퓨터 구조
1. "명령어 실행을 위해서 제일 먼저 하는 일이 Fetch인데 어떤 이동 경로를 통해 명령어의 Fetch가 진행되는가?"
2. "명령어를 CPU 안에 가져다 놓을 때 어디에 저장하는 것인가?"
3. "CPU안에 가져다 놓은 명령어는 Decode단계에서 해석되는데, CPU안에 존재하는 누구에 의해 진행되는가?"
4. "마지막 Execution은 누구에 의해서 진행되는가?"
답을 내리다 보면 폰노이만의 구조와 오늘날의 구조가 일치한다는 것을 알 수 있다.
Execution은 데이터의 이동이 될 수도 있고, 산술 및 논리 연산이 될 수도 있는데, 산술 및 논리 연산이면 ALU이다.
Decode는 명령어의 해석이고, 이것을 진행하는 요소는 컨트롤 유닛이다.
이동된 명령어를 저장하기 위해 사용되는 것이 레지스터이고 그 중에서 IR(Instruction Register)에 저장된다.
┌────────────────────────────────┐  1.Fetch
│ ALU 3.Execution  ┌─|명령어 A|←──│────────── |명령어 A |
│  ^               │ |        |  │            |명령어 B |
│  │               │ |        |  │            |명령어 C |
│  │               │ |        |  │             ...
│  │               │             │             메모리
│ Control Unit <───┘             │
│   2.Decode                     │
└────────────────────────────────┘
               CPU


순차적으로 명령어를 가져오려면 어느 명령어까지 가져왔는지 기억하고 있어야만 한다.
PC(Program Counter)는 이러한 목적으로 사용되는 레지스터이다.
즉, 다음에 가져와야 할 명령어가 어디에 존재하는지 그 메모리의 주소를 기억하기 위한 용도.
따라서 명령어를 하나씩 가져올 때마다, PC에 저장되어 있는 값을 변경된다.

데이터 이동의 기반이 되는 BUS 시스템
데이터를 이동하는 데 있어서 사용되는 전송 경로를 가리켜 버스 시스템(Bus System)이라 한다.
데이터의 종류에 따라 Address Bus, Data Bus, Control Bus.
I/O버스는 여러 장치들이 데이터를 주고 받기 위한 통로의 역할.
CPU와 메인 메모리도 데이터를 주고 받기 위해 버스로 연결되어 있다.
Fetch말고도 역으로 CPU의 레지스터에 저장되어 있는 데이터(결과)를 메인 메모리에 저장하기도 한다.
    |<--    Data Bus -->|
CPU |<-- Address Bus -->| Memory
    |<-- Control Bus -->|

Data Bus:데이터를 이동하기 위해 필요한 버스. 데이터란 명령어가 될 수도 있고, Operand가 될 수도 있다.
Address Bus:주소값을 이동하기 위해 필요한 버스. CPU가 0x1024번지에 저장되어 있는 데이터 4바이트를 읽으려고 하면
메모리 영역에 주소값 0x1024를 먼저 전달해야 한다. 메모리는 단순 저장뿐아니라 주소가 전달되면 해당 주소의 데이터를
전송하는 컨트롤러가 포함되어 있다. 메모리는 0x1024번지에 존재하는 4바이트 데이터를 데이터 버스를 통해 전달받는다.
Control Bus:CPU가 원하는 바를 메모리에 전달할 때 사용. 쉽게 CPU와 메모리가 특별한 Sign을 주고받는 용도.

CPU는 메모리로부터 데이터를 가져오기도 하지만, 반대로 메모리에 데이터를 저장하기도 한다.
그럼 둘 사이에는 보낼 것인지 받을 것인지에 대한 적절한 사인이 오고가야 한다.
CPU는 하고자 하는 일이 무엇인지를 메모리에게 알려주는 데 이런 용도로 사용되는 버스가 컨트롤 버스다.
두번째로 주고 받은 데이터는 주소값이다.
데이터가 저장된 주소값을 알아야 적절히 송신 및 수신할 수 있고, 이를 위한 버스가 어드레스 버스.
하는 일도 확인되고 주소 정보도 받으면 실제로 데이터를 전송하면 되는데 이를 위한 버스가 데이터 버스.

정리해보면
┌──────────────────────────────────┐  
│ ALU 3.Execution  ┌─|명령어 A|     │        ┌─ |명령어 A |
│  ^               │ |        |    │        │   |명령어 B |
│  │               │ |        |    │        │   |명령어 C |
│  │               │ |        |    │        │    ...
│  │               │     ↑         │        │    메모리
│ Control Unit <───┘ Bus Interface │        │
│   2.Decode             ↑         │        │
└──────────────────────────────────┘        │
			   CPU       │                  ↓1.Fetch
<───────────────────────────────────────────────────────>
                       I/O BUS

사실 일반적으로는 대부분의 외부 디바이스(하드디스크, CD-ROM,..)는 하나의 버스를 통해서 데이터를 주고받지만,
내부 메모리에 해당하는 RAM의 경우 다른 경로의 버스 시스템을 통하여 CPU와 데이터를 주고 받는다.

이것만은 알고 갑시다
1. ALU와 컨트롤 유닛의 기능적 역할
명령어의 내용대로 연산을 하는 주 요소는 ALU이지만 명령어를 분석해서 해야할 일을 결정하는 요소는 컨트롤 유닛.
2. Register의 필요성
레지스터는 CPU내에 존재하는 저장장치.
3. Clock Pulse의 필요성
클럭은 동기화를 위해서 필요한 장치. CPU는 인가되는 클럭 펄스에 맞춰서 일을 한다.
4. Fetch, Decode, Execution
Stored program concept은 메인 메모리에 저장되어 있는 명령어를 CPU내부로 가져오고(Fetch), 컨트롤 유닛에 의해
분석된 다음(Decode), ALU에 의해 연산이 이뤄진다(Execution).
5. Bus Interface
CPU내부 및 외부에 있는 요소들은 서로 I/O BUS를 통해 데이터를 주고 받는다.
BUS를 통해 데이터를 주고 받기 위해서는 BUS의 통신방식에 맞게 데이터 입출력을 돕는 인터페이스 장치가 있어야 하며,
인터페이스 장치를 가리켜 컨트롤러 혹은 어댑터라고 부른다.

*/