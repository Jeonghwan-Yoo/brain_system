/*
메모리 관리(Virtual Memory, Heap, MMF)
운영체제에서 제공하는 메모리 관리 기법이라는 것이 아는 만큼 쓰는 것이다.
DLL은 API를 공부하거나 MFC를 공부하는 과정에서도 쉽게 접할 수 있는 내용.

01 가상 메모리(Virtual Memory) 컨트롤
Windows에서는 가상 메모리를 컨트롤할 수 있는 기능을 제공하는데 이는 메모리의 효율적인 사용을 위해 도움이 된다.

Reserve, Commit 그리고 Free
Reserve는 예약, Commit은 할당, Free는 할당되지 않았음을 의미한다.
Windows 시스템에서 부여할 수 있도록 정의한 페이지의 상태를 의미하는 것.
가상 메모리의 크기 / 페이지 하나당 크기 = 페이지의 개수
즉 페이지 개수는 가상 메모리의 크기에 비례하며, 모든 페이지는 Reserved, Commit 그리고 Free 이 세가지 중
하나의 상태를 지닌다.
	 페이지 테이블                            물리 메모리
  free|페이지15|null|              ┌------> |0 - 4K로 할당  |
commit|페이지14|    | --------------------->|56 - 60K로 할당|
  free|페이지13|null|       ┌------|------> |8 - 12K로 할당 |
  free|페이지12|null|       |      |     ┌> |16 - 20K로 할당|
          ...              |      |     |
commit|페이지4 |    | -------------|-----┘
  free|페이지3 |null|       |      |
commit|페이지2 |    | ------┘      |
  free|페이지1 |null|              |
commit|페이지0 |    | -------------┘

COMMIT으로 표시된 부분은 물리 메모리에 할당이 이뤄진 부분들.
물리 메모리란 RAM과 하드 디스크를 모두 포함한 것.
즉 해당 페이지가 물리 메모리에 할당된 상태를 가리켜 COMMIT 상태라 표현한다.
malloc 함수 호출을 통해 일부 메모리를 할당 받으면 해당 메모리의 페이지는 COMMIT 상태가 된다.
그리고 물리 메모리에 전혀 할당이 이뤄지지 않은 영역은 FREE로 표시되어 있다.
즉 물리 메모리 할당이 이뤄지지 않은 페이지를 가리켜 FREE 상태라 표현한다.
COMMIT과 FREE는 이미 알고 있는 페이지 상태에 이름을 붙여준 정도에 지나지 않는다.
그리고 Windows 시스템에서는 RESERVE라는 상태를 하나 더 두어 메모리 사용의 효율성을 높일 기회를 제공한다.

RESERVE 상태가 필요한 이유
FREE ┌─페이지9          FREE ┌─페이지9
     │ 페이지8               │ 페이지8
     │ 페이지7               │ 페이지7
     │ 페이지6               │ 페이지6
	 │ 페이지5  --->         └ 페이지5
	 │ 페이지4        COMMIT ┌─페이지4
	 │ 페이지3               │ 페이지3
	 │ 페이지2               │ 페이지2
	 │ 페이지1               │ 페이지1
	 └─페이지0               └─페이지0
모든페이지 테이블이 현재 FREE에 있고, 이중 일부를 COMMIT상태로 변경하였다고 하자.
COMMIT 상태로 변경하는 일은 어렵지 않다.
malloc 함수 호출을 통해 페이지 크기만큼 할당하면 된다.
크게 문제될 건 없지만 물리 메모리 효율성 관점에서는 문제가 된다.
만약 당장 필요한 메모리 공간은 하나의 페이지 분량인데 점진적으로 사용량이 늘어날 것으로 예상되어 100페이지
분량을 할당해서 1년 정도를 고려해 결정했다고 하자.
필요할 때마다 조금씩 추가로 할당해도 해결할 수 있지만 순차적으로 연결되어 있는 메모리를 사용해야 한다면 불가능.
배열을 예로 들어 길이가 10000인 배열이 필요할 때 조금씩 나눠서 할당할 수 없다.
시스템은 단순해 페이지를 COMMIT 상태로 만들어 버리면, 해당 페이지는 물리 메모리에 할당되어 버린다.
그 위치가 램이든 하드디스크이든.
이러한 상황을 고려해 등장한 것이 RESERVE이다.
FREE ┌─페이지9          FREE ┌─페이지9          FREE ┌─페이지9
	 │ 페이지8               │ 페이지8               │ 페이지8
	 │ 페이지7               │ 페이지7               │ 페이지7
	 │ 페이지6               │ 페이지6               │ 페이지6
	 │ 페이지5  --->         └─페이지5  --->         └─페이지5
	 │ 페이지4        RESEVE ┌─페이지4       RESERVE ┌─페이지4
	 │ 페이지3               │ 페이지3               │ 페이지3
	 │ 페이지2               │ 페이지2               └─페이지2
	 │ 페이지1               │ 페이지1        COMMIT ┌─페이지1
	 └─페이지0               └─페이지0               └─페이지0
FREE 상태에 있던 페이지 중에서 총 다섯 페이지를 RESERVE 상태로 변경시켰다.
RESERVE 상태는 FREE와 COMMIT의 중간 상태이다.
일부 페이지를 RESERVE 상태로 둠으로써 다른 메모리 할당 함수에 의해 해당 번지가 할당되지 못하도록 선언할 수 있다.
그러나 예약을 했을 뿐 할당이 완료된 상태가 아니므로 물리 메모리에 할당되지는 않는다.
그래서 물리 메모리의 소비는 발생하지 않는다.
RESERVE 상태에 있는 메모리 중에서 일부만 COMMIT 상태로 변경하는 것도 가능하다.
따라서 메모리의 사용량이 늘어남에 따라서 점진적으로 COMMIT 상태의 페이지 개수를 증가시킬 수 있다.
정말 필요한 만큼의 페이지만 물리 메모리에 할당하는 것이 가능하다.
코드상에서 RESERVE 상태의 특성을 활용하기 위해 동적으로 물리 메모리의 할당량이 증가하는 배열을 만든다.
배열 인덱스 연산이나 포인터 연산이 가능하도록 하나의 배열로 구성.

메모리 할당의 시작점과 단위 확인하기
메모리를 할당하기 전에 기본적으로 메모리 할당의 시작 주소, 할당할 메모리의 크기를 생각하자.
가상 메모리 시스템은 페이지 단위로 관리된다.
그래서 페이지의 중간 위치에서부터 할당을 시작할 수 없으며, 페이지 크기의 배수 단위로 할당을 해야만 한다.
페이지 크기가 4KB라면 Windows 시스템에서는 메모리가 지나치게 조각나는 것을 막기위해, 관리의 효율성을 이유로 하여
조금 더 넓은 범위의 값을 할당의 경계로 정의하고 있다.
메모리 할당의 시작 주소가 될 수 있는 기본 단위를 Allocation Granularity Boudary라 한다.
그러나 메모리 할당의 기본 단위는 페이지 하나의 크기가 할당의 기본 단위고, 배수 단위로 할당이 가능하다.
즉, Allocation Granularity Boundary와 페이지의 크기를 알아야만 합리적인 메모리 할당을 요구할 수 있다.
우리가 원하는 정보는 GetSystemInfo 함수를 통해 얻을 수 있다.
20_1.cpp SYSTEM_INFO.cpp
Allocation Granularity Boundary도 페이지 크기의 배수이다.

VirtualAlloc & VirtualFree 함수
먼저 두 가지 시스템 함수를 알아야 한다.
첫 번째 함수는 VirtualAlloc으로 페이지 상태를 RESERVE와 COMMIT 상태로 만드는 두 가지 역할을 한다.
LPVOID VirtualAlloc (
	LPVOID lpAddress, 1)
	SIZE_T dwSize, 2)
	DWORD flAllocationType, 3)
	DWORD flProtect 4)
);
If the function fails, the return value is NULL. 5)
1)lpAddress:예약 및 할당하고자 하는 메모리의 시작 주소를 지정한다. 일반적으로 NULL을 전달하게 되는데, NULL이
전달되면 할당하고자 하는 크기에 맞춰 메모리의 위치를 임의로 결정한다.
그러나 RESERVE 상태에 있는 페이지를 COMMIT 상태로 변경할 때에는 해당 페이지의 시작주소를 지정해야 한다.
예약을 할 때에는 Allocation Granularity Boundary를 기준으로 값이 조절되고, 할당을 할 때에는 페이지
크기 단위로 값이 조절된다(내부적으로 계산).
2)dwSize:할당하고자 하는 메모리의 크기를 바이트 단위로 지정한다. 메모리의 할당은 페이지 크기 단위로 결정된다.
페이지 크기가 4KB인 경우, 1KB를 할당하더라도 4KB의 배수에 해당하는 16KB가 할당된다.
3)flAllocationType:메모리 할당의 타입을 결정한다. 페이지를 RESERVE 상태로 두고자 하는 경우에는 MEM_RESERVE을
인자로 전달한다. 페이지를 COMMIT 상태로 변경하고자 하는 경우에는 MEM_COMMIT을 인자로 전달한다.
4)flProtect:페이지별 접근방식에 제한을 두는 용도로 사용한다. Windows 시스템 함수를 사용했을 때 얻게 되는 장점.
기본적으로 RESERVE 상태에 둘 때에는 접근을 허용하지 않는 PAGE_NOACCESS를, COMMIT 상태로 변경할 때에는 읽기
쓰기를 모두 허용하는 PAGE_READWRITE를 인자로 전달한다. 인자들의 개수가 10개가 넘으며 제한된 형태로 조합 가능.
그리고 메모리 보호에 관련된 추가적인 내용도 있다.
5)끝으로 함수 호출이 성공하면 할당이 이뤄진 메모리의 시작 번지를 반환한다.

두 번째로 알아야 할 함수는 VirtualAlloc에 반대되는 함수로 이 함수가 정해 놓은 상태를 되돌리는 역할을 한다.
malloc과 free 함수 관계.
BOOL VirtualFree (
	LPVOID lpAddress, 1)
	SIZE_T dwSize, 2)
	DWORD dwFreeType 3)
);
If the function fails, the return value is 0.
1)lpAddress:해제할 메모리 공간의 시작 주소를 지정한다.
2)dwSize:해제할 메모리 크기를 바이트 단위로 지정한다.
3)dwFreeType:MEM_DECOMMIT과 MEM_RELEASE 중 하나를 지정할 수 있다.
MEM_RELEASE를 지정할 경우 해당 페이지는 FREE 상태가 된다.
물리적 메모리가 할당되어 있다면 해당 메모리는 반환된다.
주의할 사항은 MEM_RELEASE 전달 시 두 번째 전달인자 dwSize는 반드시 0이어야 하고, lpAddress의 값은
VirtualAlloc 함수 호출을 통해 예약된 메모리의 시작 번지가 되어야 한다는 것.
그리고 예약이 이뤄진 메모리의 일부만 반환하는 것은 불가능하다.
MEM_DECOMMIT을 인자로 전달할 경우에는 해당 페이지의 상태를 RESERVE 상태로 되돌리게 된다.
이 경우에도 물리적 메모리가 할당되어 있다면 해당 메모리는 반환하게 된다.

Dynamic Array Design
일반적인 배열처럼 한순간에 배열 크기만큼 물리 메모리가 할당되는 것이 아닌 사용양의 증가에 따라 물리 메모리에
할당되는, 배열의 크기가 점진적으로 증가하는 배열을 디자인.
가상 메모리를 컨트롤하는 시나리오
1)시스템의 페이지 사이즈와 Allocation Granularity Boundary값을 얻어 온다. 할당하고자 하는 메모리의 위치에
직접적으로 관려하지 않겠다면, 페이지 사이즈만 얻어와도 된다.
2)메모리를 예약(RESERVE)한다. 예약을 할 때에는 필요하다고 예상되는 최대의 크기로 예약을 한다.
3)필요한 만큼의 메모리를 물리 메모리에 할당(COMMIT)한다. 필요에 따라 점진적으로 할당의 크기를 증가시킨다.
4)할당했던 메모리를 반환한다.
위 시나리오에 기반하여 Dynamic Array를 구현하는 방법으로 세 가지 정도 거론할 수 있다.
그러나 성능적인 부분이나 구현의 편리성을 종합해서 보면 가장 최고로 꼽히는 방법은 SEH를 활용하는 것이다.
20_2.cpp DynamicArray.cpp
메모리 공간을 예약하면 메모리 공간을 활용할 차례.
결국 배열 선언 이후로 배열 사용량이 증가함에 따라 한 페이지씩 물리 메모리로의 할당이 추가로 이뤄지게 된다.
한 페이지씩 할당할 것인지, 둘 이상의 페이지씩 할당할 것인지는 결정.
한 페이지씩 할당할 경우에는 너무 잦은 SEH 처리와 빈번한 함수 호출로 인해서 성능에 문제가 발생할 수도 있다.
그리고 마지막 단계에 모든 페이지를 반환하며 FREE 상태로 변경한다.
할당된 메모리에 값이 제대로 저장되어 있는지 확인하고 싶다면 주석을 해제.
배열의 이름 역할을 하는 포인터 타입을 변경하면 2차우너 배열도 쉽게 구현할 수 있다.

02 힙(Heap) 컨트롤
메모리 공간 힙.
Windows 시스템에서는 힙을 생성 및 소멸시킬 수 있는 방법을 제시하고 있는데, 힙을 컨트롤하는 것은 가상 메모리를
컨트롤하는 것보다 유용한 일.
가상 메모리 컨트롤은 개념적인 측면에서 매우 중요하고, 힙 컨트롤은 프로그램의 성능뿐 아니라, 구현의 용이성을
위해서도 중요하다.

힙 컨트롤에 대한 필자의 기억
리스트 자료구조의 특성상 각각의 리스트 정보는 동적 할당되어 힙에 저장된다.
따라서 메모리 반환의 과정을 거쳐야하고 리스트의 처음부터 끝까지 추적해가며 일일이 반환해야만 한다.
1)메모리 유출(삭제되지 않은 리스트 발생). 개발자의 실수로 메모리가 유출되면 그만큼 메모리 활용에 손해가 된다.
메모리 유출이 누적되면 프로그램이 종료되는 현상까지 발생.
2)성능. 일일이 돌아다니면서 삭제할 경우 연결된 리스트의 길이에 따라서 성능에 부담이 될 수도 있다.
Windows에서는 한번에 할당된 메모리를 해제할 수 있고, 두 문제점을 차단할 수 있게 해준다.

디폴트 힙(Default Heap) & Windows 시스템에서의 힙
프로젝트의 메모리 구성
        ┌───────────── Windows 디폴트 힙 ─────────────────┐
홍길동 ---> 슈퍼맨1 ---> 슈퍼맨2 ---> 슈퍼맨3 ---> THE WAR │
최대수 ---> 배트맨1 ---> 배트맨2 ---> 배트맨3 ---> CHU WAR │
        └────────────────────────────────────────────────┘
C언어를 사용할 경우 malloc 함수와 free 함수를, C++을 사용할 경우 new와 delete 연산자를 사용해 힙 영역에
메모리를 할당한다. 
이런 경우 프로세스를 생성할 때 더불어 생성되는 힙, 1MB크기의 디폴트 힙 영역에 메모리를 할당하게 된다.
디폴트 힙은 프로세스에 기본적으로 할당되는 힙이라 하여 프로세스 힙(Process Heap)이라고 부른다.

Windows 시스템에서의 힙 메모리
		┌───────────────────── 힙A ──────────────────────┐
홍길동 ---> 슈퍼맨1 ---> 슈퍼맨2 ---> 슈퍼맨3 ---> THE WAR │
        └────────────────────────────────────────────────┘
		┌───────────────────── 힙B ──────────────────────┐
최대수 ---> 배트맨1 ---> 배트맨2 ---> 배트맨3 ---> CHU WAR │
		└────────────────────────────────────────────────┘
각각 독립적인 추가적인 힙 생성이 가능하다.
가상 메모리 범위 내에서 프로세스 생성 시 만들어지는 디폴트 힙 이외에 필요로 하는 힙을 얼마든지 만들 수 있다.
그리고 홍길동을 위해 할당한 힙을 한방에 삭제해버리는 연산이 가능하다.
그러면 메모리가 유출될 일도 없고, 일일이 해제를 하면서 돌아다닐 필요도 없다.
디폴트 힙을 구성하는 페이지들의 상태는 RESERVE 상태이다.
그러나 성능 향상을 위해 일부 페이지 상태는 이미 COMMIT 상태에 놓여있을 수도 있다.
RESERVE 상태에 있는 힙의 페이지들이 malloc과 free 함수의 호출을 통해 페이지 크기의 정수배로 COMMIT과
RESERVE 상태를 오가는 것.

디폴트 힙 컨트롤
디폴트 힙의 기본 크기는 1MB이다.
그러나 링커(Linker)옵션을 통해 변경이 가능하다.
링커 옵션을 통해, RESERVE 상태에 놓이게 되는 힙의 전체 크기와 이중에서 초기에 COMMIT상태로 둘 메모리의 크기를
지정할 수 있다.
/HEAP:reserve, commit
/HEAP:0x200000, 0x10000
그럼 디폴트 힙의 크기는 2MB가되며, 이중 64KB가 COMMIT 상태에 있게 된다.
프로젝트의 속성창(Alt + F7)에서 Heap Reserve Size와 Heap Commit Size 설정을 통해 지정할 수 있다.
디폴트 힙의 크기 1MB는 힙이 생성된 직후의 초기 크기를 말하는 것이다.
필요에 따라서 그 크기는 Windows 시스템이 알아서 늘려준다.
번거롭게 힙 크기를 정해줄 필요는 없지만 필요한 크기만큼 여유 있는 디폴트 힙을 요청해두면 시간을 아낄 수 있다.
프로세스가 실행 중인 상태에서 새로운 메모리 영역을 할당하는 것은 시간이 제법 걸리기 때문.

힙(Dynamic Heap) 생성이 가져다 주는 또 다른 이점
디폴트 힙 이외에 Windows 시스템 함수 호출을 통해 생성되는 힙을 동적 힙이라 한다.
지금부터의 힙은 동적힙을 의미한다.
장점1)메모리 단편화의 최소화에 따른 성능 향상
A라는 기능을 위해 힙A를 생성하고, B라는 기능을 위해 힙B를 생성하고, C라는 기능을 위해 힙C를 생성하면
가상 메모리
|    |
|    |┐
|    |┘힙A
|    |
|    |┐
|    |│
|    |┘힙B
|    |
|    | 힙C
|    |
그러나 이것을 하나의 디폴트 힙에서 처리한다면
가상 메모리
|    |
|    |힙A
|    |힙B
|    |힙A
|    |힙C
|    |...
|    |
|    |
|    |
|    |
훨씬 복잡하게 단편화(Fragmentation)가 발생할 소지가 높다.
일단 A,B,C의 힙을 미리 선언하면 할당된 페이지가 RESERVE 상태에 놓이기 때문에 메모리 단편화가 발생하지 않는다.
반면에 디폴트 힙을 활용할 경우 프로그램 실행과정에서 무작위 메모리 할당 및 그에 따른 힙 크기의 증가에 의해
메모리 단편화가 심하게 발생한다.
단편화가 심하다는 것은 프로그램의 로컬리티 특성이 낮아진다는 것을 의미하며 성능에 많은 영향을 미치게 된다.
즉 필요에 맞게 추가적인 힙을 생성해서 활용한다면, 성능 향상도 기대할 수 있다.

메모리 단편화가 어떠한 상황에서 발생하고 무엇 때문에 성능이 저하되는가?
예를 들어 리스트와 트리를 둘 다 구성해야 한다고 가정.
만약 디폴트 힙을 활용하면
페이지1
|List    |Tree |List|Tree|List    |Tree  |...
페이지2
|List  |Tree     |List |Tree|List   |Tree|...
...
리스트와 트리 노드를 추가할 때마다 메모리 할당이 이뤄진다.
총 4개의 페이지에 걸쳐 메모리 할당이 이뤄졌다고 하면 리스트 노드와 트리 노드가 심하게 섞이게 된다.
이 상황에서 리스트를 구성하는 모든 노드값을 참조하려하면 4개의 페이지는 모두 메인 메모리에 올라와 있어야 한다.
4개의 페이지에 노드가 분산 저장되어 있기 때문.
그런데 메인 메모리에 여유가 없어 한 순간에 하나의 페이지만 메인 메모리에 둘 수 있다면, 최악의 경우는 노드를
참조할 때마다 하드디스크에 저장되어 있는 페이지를 메인 메모리로 옮겨 와야 한다.
해당 노드가 메인 메모리에 존재하지 않는 상황을 Page Fault라고 하는데, 발생하면 하드디스크에 저장되어 있는 페이지를
메인 메모리에 올려 놓는 수고를 해야만 한다.
만약 리스트를 위한 트리를 위한 힙을 독립해 생성하였다면
Tree 위한 페이지
|                                        |...
|                                        |...
List 위한 페이지
|                                        |...
|                                        |...
그러면 상대적으로 훨씬 적은 Page Fault가 발생하게 된다.
로컬리티가 훨씬 좋아졌다.

장점2)동기화 문제에서 자유로워짐으로 인한 성능 향상
멀티 쓰레드 프로그래밍을 할 때 쓰레드별로 사용할 힙을 별도로 할당해 주는 것은 의미 있는 일이다.
일반적으로 힙은 쓰레드가 공유하는 메모리 영역이다.
그래서 둘 이상의 쓰레드가 동시접근 할 때 문제가 발생할 소지가 있어 Windows 내부적으로 동기화 처리를 해주고 있다.
둘 이상의 쓰레드가 힙에 선언된 변수를 동시에 참조하는 상황은 세마포어나 뮤텍스를 선언해 해결하면 되고
여기서 동시접근이란 메모리의 할당과 해제이다.
같은 주소 번지에 둘 이상의 쓰레드가 동시에 메모리를 할당 및 해제하는 상황이 발생할 경우 메모리 오류가 발생한다.
때문에 디폴트 프로세스 힙은 쓰레드가 메모리를 할당하려고 하는 경우 내부적으로 동기화 처리를 하고 있다.
그런데 하나의 쓰레드당 독립된 하나의 힙을 할당할 경우 동기화 처리를 할 필요가 없고 이것으로 인한 성능 향상을
기대할 수 있게 된다.

쓰레드별로 독립된 힙을 할당하는 주목은 성능향상보다 프로그램 구현의 용이성 떄문에 독립된 힙을 할당한다.
쓰레드가 실행되는 동안에 할당한 메모리를 일일이 해제할 필요없이 힙 자체를 반환해 버릴 수 있기 때문.

힙의 생성과 그리고 할당
크게 두 가지를 고려해야 하는데 하나는 힙의 생성과 소멸이다.
그리고 또 하나는 힙 영역 안에서의 메모리 할당과 해제이다.
힙을 만들고 그 안에다가 메모리를 할당하고 해제한는 것이 목표.
HANDLE HeapCreate (
	DWORD flOptions, 1)
	SIZE_T dwInitialSize, 2)
	SIZE_T dwMaximumSize 3)
);
If the fucntion fails, the return value is NULL. 4)
1)flOptions:생성되는 힙의 특성을 부여하는 데 사용된다. 0을 전달할 경우 가장 일반적인 힙이 생성된다.
HEAP_GENERATE_EXCEPTIONS을 전달할 경우 오류 발생 시 NULL을 반환하는 것이 아니라 예외를 발생시킨다.
HEAP_NO_SERIALIZE을 지정할 경우 생성된 힙에 메모리를 할당 및 해제할 때 동기화 처리를 하지 않게 된다.(동기화
문제에서 자유로워짐으로 인한 성능 향상). 쓰레드별 독립된 힙을 생성할 경우에는 HEAP_NO_SERIALIZE을 인자로 지정해서
성능을 향상시키는 것이 좋다. 둘 이상의 속성을 비트 단위 OR연산자(|)로 동시 지정 가능하다.
3)dwMaximumSize:마지막 전달인자는 생성되는 힙의 크기를 결정한다. 지정하는 크기에 해당하는 페이지의 수만큼
RESERVE 상태가 된다. 0이 값으로 전달되면, 힙은 증가 가능한 메모리(Growable Heap)가 된다. 따라서 0이 전달될 경우
메모리가 허락하는 한도 내에서 힙의 크기는 증가한다.
2)dwInitialSize:dwMaximumSize에서 지정한 메모리 중에서 초기에 할당할 물리 메모리 크기를 지정한다.
여기서 지정한 크기에 해당하는 페이지의 수만큼 힙이 생성되자마자 COMMIT 상태가 된다.
4)위 함수는 오류가 발생하지 않는다면, 생성된 힙을 컨트롤하는 데 사용되는 힙의 핸들을 반환한다.

RESERVE 상태에 놓여있던 페이지를(COMMIT 상태에 있던 페이지 포함해서) FREE상태로 되돌리는 함수
BOOL HeapDestroy (
	HANDLE hHeap 1)
);
If the function fails, the return value is zero.
1)hHeap:반환하고자 하는 힙의 핸들을 인자로 전달한다.

힙을 생성하였다면 힙에 메모리를 할당하고 해제할 차례다.
요청 크기에 해당하는 페이지 수만큼 COMMIT 상태로 변경시킨다.
LPVOID HeapAlloc (
	HANDLE hHeap, 1)
	DWORD dwFlags, 2)
	SIZE_T dwBytes 3)
);
If the function fails, the return value is NULL.
1)hHeap:메모리 할당이 이뤄질 힙의 핸들을 지정한다.
2)dwFlags:HEAP_GENERATE_EXCEPTIONS가 인자로 올 경우, 오류 발생 시 NULL을 반환하지 않고 예외를 발생시킨다.
HEAP_NO_SERIALIZE를 인자로 전달할 경우 함수 호출은 동기화 처리되지 않는다. HeapCreate 함수 호출 과정에서
이미 HEAP_NO_SERIALIZE을 전달하였다면 이 전달인자를 통해 중복 지정할 필요가 없다. 그리고 HEAP_ZERO_MEMORY가
전달되면 할당된 메모리는 0으로 초기화된다. 둘 이상의 속성을 비트 단위 OR 연산자로 동시 지정 가능하다.
3)dwBytes:할당하고자 하는 메모리의 크기를 지정한다. 참고로 힙이 증가 가능한 힙이 아니라면, 즉 힙 생성 시
HeapCreate 함수 호출의 마지막 전달인자가 0이 아니었다면, 할당의 최대 크기는 0x7FFF8로 제한된다.

힙에 할당된 메모리를 해제하는 데 사용하는 함수이다. 
메모리가 해제되는 과정에서 페이지는 다시 RESERVE 상태가 될 수 있다.
BOOL HeapFree (
	HANDLE hHeap, 1)
	DWORD dwFlags, 2)
	LPVOID lpMem 3)
);
If the fucntion fails, the return value is zero.
1)hHeap:해제할 메모리를 담고 있는 힙을 지정한다.
2)dwFlags:HEAP_NO_SERIALIZE가 인자로 올 수 있다. HeapCreate 함수 호출 과정에서 이미 HEAP_NO_SERIALIZE을 전달
하였다면 이 전달인자를 통해 중복 지정할 필요는 없다.
3)lpMem:해제할 메모리의 시작 주소를 지정한다.

ANSI 표준의 realloc 함수와 유사한 HeapReAlloc 함수가 존재한다.

Heap & Linked List 예제
20_3.cpp DynamicHeap.cpp

리스트 자료구조에 동적 힙의 개념을 도입하면 메모리 유출의 방지와 프로그램 구현의 용이성.
이번에는 MBCS 기반으로 코드 작성.
그리고 디폴트 힙을 활용하는 경우의 코드와 동적 힙을 활용하는 경우를 비교.
LINKED_HEAP.cpp

03 MMF(Memory Mapped File)
만약 사람의 기본 정보(이름, 전화번호)를 저장할 수 있는 프로그램을 작성한다고 하자.
기본 정보를 표현할 수 있는 구조체를 정의하고, 데이터가 채워진 구조체 변수를 저장하기 위한 배열을 선언한다.
그리고 프로그램이 종료되면 배열에 저장되어 있는 정보를 파일에 저장하고, 프로그램이 시작되면 저장된 파일의 데이터를
읽어 들인다.
또한 프로그램 실행 중간 중간에 파일 입출력을 위한 코드를 삽입하고 파일에 저장될 때 정렬까지 해야 된다.

MMF의 이해
File을 Memory에 Mapping(연결)시킨다는 의미를 지니고 있다.
파일의 일부 영역을 가상 메모리 일부에 연결시키는 메커니즘.
파일
|   |  ...    |                 |
          ↘ 매핑
|      |    ...        |                   |
프로세스의 가상 메모리

MMF의 데이터 저장 관계
           파일
          |     |    |...|      |            |
                       ↑반영
|               |    |...|      |                |
프로세스의 가상 메모리   ↑저장
                    |데이터|
가상 메모리 중 파일에 연결되어 있는 영역에 데이터를 저장한다.
이렇게 메모리에 저장된 데이터는 실제 파일에도 효과를 미친다.
즉 메모리에만 데이터가 저장되는 것이 아닌 메모리에 연결된 파일에 실제 데이터가 저장되는 것.

장점1)프로그래밍하기 편리하다
대부분은 파일에 저장된 데이터를 조작하는 것보다 메모리상에 저장된 데이터 조각을 훨씬 좋아한다.
파일 안에 저장되어 있는 데이터를 조작하려면 일단 메모리로 읽어 들여야 한다.
그리고 조작 후에 다시 파일에 저장하는 과정을 거쳐야 한다.
파일에 저장된 데이터를 조작하는 일은 메모리상에 저장된 데이터 조작에 비해서 많이 불편하다.
그런데 MMF를 사용하면 메모리상에 저장된 데이터를 조작하는 방식으로 파일 내 데이터를 조작할 수 있다.
장점2)성능이 향상된다.
일반적으로 성능은 향상된다.
              |         |
프            |         |          | ...     |
로   ───────→ | ...     | ───────↗ | ...     |
그		write | ...     | 반영     | ...     |
램			  | ...     |          | ...     |
	 ←─────── | ...     | ───────↗ |         |
실		 read |         |          |         |
행			  |         |              파일
			  |         |
     		     메모리
←─────────────────→←────────────────────→ 
     빈번한 I/O       주기적, 상황적 I/O
메모리는 중간에서 파일 데이터의 캐쉬 역할을 한다고 이해하면 된다.
캐쉬가 존재하게 되므로 직접 파일에 접근하는 것보다 효율적인 접근이 이뤄진다.
메모리에 저장되어 있는 데이터는 주기적으로 또는 특정 상황에 놓이게 될 때 파일에 저장된다.
캐쉬의 로컬리티 특성만 만족한다면 아주 높은 성능 향상도 기대할 수 있다.
메모리에 저장된 데이터가 변경될 때마다 파일에 바로 반영하고자 할 때도 가능하다.
그러면 구현의 용이성만 얻게 되고 성능 향상은 기대하기 어렵다.

MMF의 구현과정
하나의 함수 호출로 MMF가 완성되는 것이 아니라 구현의 흐름을 이해해야 한다.
[1단계:파일 개방]
MMF는 파일의 일부를 메모리에 연결시키는 것이므로 파일이 존재해야 한다.
즉 파일 핸들이 필요하다.
MMF는 연결 대상이 되는 파일을 이름을 통해서 찾지 않는다.
반드시 CreateFile 함수 호출을 통해 파일을 열고 해당 파일의 핸들을 얻어야만 한다.
[2단계:파일 연결 오브젝트 생성]
파일 연결 오브젝트 혹은 파일 매핑 오브젝트라 불리는데, 메모리에 연결할 파일 정보를 담고 있는 커널 오브젝트를 생성.
CreateFileMapping 함수 호출을 통해 만들어진다.
MMF의 1단계에서 생성한 파일 핸들을 가지고 만들게 되는데, 파일 핸들이 파일을 읽고 쓰기 위해 필요하다면,
파일 연결 오브젝트는 메모리에 매핑시키기 위해 필요하다.
[3단계:가상 메모리에 파일 연결]
마지막 단계로서 실제로 가상 메모리에 파일을 연결한다.
MapViewOfFile 함수 호출을 통해 완성되는데, 이때 반환되는 포인터를 가지고 메모리에 접근한다.
이렇게 접근해서 메모리에 데이터를 저장하거나 변경하면, 그 결과가 연결된 파일에 반영된다.

MMF의 구현 함수
HANDLE CreateFileMapping (
	HANLDE hFile, 1)
	LPSECURITY_ATTRIBUTES lpAttributes, 2)
	DWORD flProtect, 3)
	DWORD dwMaximumSizeHigh, 4)
	DWORD dwMaximumSizeLow, 5)
	LPCTSTR lpName 6)
);
If the function fails, the return value is NULL.
1)hFile:메모리에 연결할 파일의 핸들을 지정한다.
2)lpAttributes:커널 오브젝트를 생성하는 다른 함수들과 마찬가지로 보안 속성을 지정한다.
3)flProtect:파일과 연결된 메모리의 접근권한을 지정한다. PAGE_READONLY를 지정하면 읽기만 가능하다.
PAGE_READWRITE로 지정되면 읽기와 쓰기가 모두 가능하다. 그 이외의 Copy-on-write을 위한 PAGE_WRITECOPY 지정이
가능하다. 이 밖에도 비트 단위 OR연산으로 묶어 함께 설정 가능한 'SEC_'로 시작하는 이름의 특성들이 있다.
대표적으로 SEC_COMMIT과 SEC_RESERVE가 있다.
4)dwMaximumSizeHigh:연결할 메모리 최대 크기의 상위 4바이트를 지정한다. 대용량 파일이 아니라면 0으로 충분.
5)dwMaximumSizeLow:연결할 메모리 최대 크기의 하위 4바이트를 지정한다. 0이 전달되면, 첫 번째 인자로 전달된
핸들의 파일 크기로 지정된다.
6)lpName:파일 연결 오브젝트의 이름을 지정한다. NULL을 전달할 수 있다.

위 함수 호출 성공 시 파일 연결 오브젝트의 핸들을 반환한다.
이 핸들을 이용해 다음 함수를 호출하면 실제 메모리로의 연결이 완성된다.
LPVOID MapViewOfFile (
	HANDLE hFileMappingObject, 1)
	DWORD dwDesiredAccess, 2)
	DWORD dwFileOffsetHigh, 3)
	DWORD dwFileOffsetLow, 4)
	SIZE_T dwNumberOfBytesToMap 5)
);
If the function fails, the return value is NULL.
1)hFileMappingObject:CreateFileMapping 함수 호출을 통해 얻은 커널 오브젝트의 핸들을 인자로 전달한다.
메모리에 연결할 파일 정보와 연결에 필요한 특성 정보를 제공하는 것이다.
2)dwDesiredAccess:연결된 메모리의 접근권한을 지정한다. 첫 번째 인자로 전달된 핸들의 접근 권한(flProtect)이
PAGE_READWRITE라면, 읽기와 쓰기 권한 중에서 하나만 혹은 둘 다 지정할 수 있다. 반면에 PAGE_READ라면 오로지
읽기 권한만 줄 수 있다. 즉 첫 번째 인자로 전달된 핸들의 접근 권한 범위 내에서 실제적인 권한을 지정하게 된다.
읽기 권한 지정 시 FILE_MAP_READ를, 쓰기 권한 지정 시 FILE_MAP_WRITE를 전달하게 되며, 읽기/쓰기 권한 동시
지정 시에는 FILE_MAP_READ | FILE_MAP_WRITE을 전달한다.
3)dwFileOffsetHigh:지정한 파일 전부를 메모리에 연결해야 하는 것은 아니다. 파일의 일부 영역만 선택해서 연결하는
것도 가능하다. 메모리에 연결할 파일의 오프셋(시작 번지)을 지정한다. 오프셋의 상위 4바이트를 지정한다.
4)dwFileOffsetLow:메모리에 연결할 파일의 오프셋을 지정한다. 오프셋의 하위 4바이트를 지정한다.
5)dwNumberOfBytesToMap:메모리에 연결할 실제 크기를 바이트 단위로 지정한다. 오프셋을 기준으로 지정된 바이트만큼
메모리에 연결된다. 0을 전달하게 되면 지정된 오프셋에서부터 파일의 끝까지 메모리에 연결된다.

위 함수 호출 성공 시 void형 포인터가 반환된다.
이 포인터를 용도에 맞게 형변환하여 사용하면 된다.
malloc 함수 호출 시 얻게 되는 포인터를 사용하는 방법과 동일.
파일과 연결된 메모리는 작업이 끝나고 나면 연결 해제 과정을 거쳐야 한다.
BOOL UnmapViewOfFile (
	LPCVOID lpBaseAddress 1)
);
If the function fails, the return value is zero.
1)lpBaseAddress:연결 해제할 메모리의 시작 주소를 지정한다. MapViewOfFile 함수 호출 시 반환되었던 주소값을
전달하면 된다.

MMF의 구성 예제 1
20_4.cpp MemoryMappedFileRead.cpp

읽고 쓰기 위한 MMF
이번에는 파일에 데이터를 저장하고, 저장된 데이터를 정렬.
20_5.cpp MemoryMappedFileSort.cpp
가장 큰 차이점은 파일이 비어 있는 상태에서 MMF를 구성한다는 점.
20_4에서는 파일을 생성하고 문자열을 하나 저장하였다.
그리고 그 문자열을 읽기 위해서 MMF를 구성하였다.
그러나 이번에는 MMF를 구성한 다음에 데이터를 저장하고자 한다.
파일 연결 오브젝트를 생성할 때 파일과 메모리를 연결할 수 있는 최대 크기를 지정하도록 되어 있다.
CreateFileMapping 함수의 4,5번째 전달인자를 통해 지정한다.
각각 상위 4바이트 정보와 하위 4바이트 정보를 전달하도록 되어있는데, 모두 0이 전달된다면 연결하고자 하는 파일의
크기로 그 값이 결정된다.
일반 편집기가 아닌 헥사코드 형태로 보여주는 바이너리 편집기를 활용해야 확인이 가능.
더 확인할 것은 파일의 크기이다.
실제로 저장한 데이터는 수십 바이트가 되지 않는데, 파일의 크기는 10KB이다.
MMF의 최대 메모리 크기를 10KB로 지정하였기 때문에.
파일의 크기가 10KB보다 작으면, 10KB의 파일과 메모리의 연결에 대한 요청을 처리할 수 없다.
때문에 MMK의 최대 메모리 크기만큼 파일 크기도 증가한다.
10KB 크기의 파일이 생성되는 시점은 CreateFileMapping 함수 호출이 완료된 직후.

MMF 기반으로 데이터를 저장할 경우, 메모리에 캐쉬된 다음 ㅈ두기적으로나 특정 조건하에서 파일로 저장된다.
그런데 때로는 메모리에 캐쉬된 데이터를 파일에 저장할 것을 명령하고 싶을 때 마치 fflush 함수처럼.
BOOL FlushViewOfFile (
	LPCVOID lpBaseAddress, 1)
	SIZE_T dwNumberOfBytesToFlush 2)
);
If the function fails, the return value is zero.
1)lpBaseAddress:파일에 저장할 메모리의 시작 주소를 지정한다.
2)dwNumberOfBytesToFlush:파일에 저장할 데이터 크기를 바이트 단위로 지정한다. 만약에 두번째 전달인자로 0을
전달할 경우 연결된 메모리 영역의 끝까지 파일로 저장된다.

Copy-On-Write(COW)
Write 할 때 copy하라.
MMF처럼 시스템 함수 수준에서 제공되거나, OS와 같은 고급 소프트웨어를 구현할 때에 내부적으로 적용하는
최적화 기술이다.
만약 멀티 쓰레드 기반 프로그램에서 쓰레드가 생성될 때마다 각각의 쓰레드가 참조할 테이블 형태의 데이터가
제공된다고 가정해본다.
기본 테이블   쓰레드A     쓰레드B    쓰레드C
키 값         키 값       키 값      키 값
A  1.04       A  1.04    A  1.04    A  1.04     
B  1.72       B  1.72    B  1.72    B  1.72
C  1.98       C  1.98    C  1.98    C  1.98
기본 테이블에 채워진 데이터는 각각의 쓰레드들에 의해 일부 변경될 수 있다.
때문에 모든 쓰레드는 자신만의 테이블을 별도로 지녀야 한다.
즉 쓰레드 생성 시 기본 테이블의 복사가 발생하는 것.
하지만 대부분의 쓰레드가 기본 테이블 정보를 참조만해서 변경하기도 하지만 드물게 일어난다.
드물게 일어나는 데이터 변경 때문에 모든 쓰레드들이 독립된 테이블 정보를 지니도록 하면 큰 메모리 손실.
이러한 문제가 발생하였을 때 COW 기법을 도입하면 보다 효율적인 구조가 된다.
                     기본 테이블
		    참조	     키 값
쓰레드A ────────────> A  1.04
쓰레드B ────────────> B  1.72
쓰레드C ------------> C  1.98
키 값    참조관계소멸    │
A  1.04 <───────────────┘             
B  1.72    테이블 복사 후 변경
C  2.02
   (데이터 변경 시도)
쓰레드를 생성할 때마다 기본 테이블을 복사해서 할당하지 않고, 모든 쓰레드들이 하나의 기본테이블을 공유하도록
프로그램이 디자인되었다.
다만 테이블의 데이터를 변경하고자 하는 쓰레드가 등장하면, 기본 테이블을 복사해서 해당 쓰레드에게 할당한 다음,
복사본을 변경하게 한다.
물론 그 이후부터는 복사본에 해당하는 테이블을 참조한다.
메모리를 최대한 절약할 수 있는 구조가 COW 최적화 기법.
OS에서는 가상 메모리를 관리하는 데 사용되는 기술 중 하나.
CreateFileMapping 함수의 세 번째 전달 인자로 PAGE_WRITECOPY을 지정하면 COW 기반으로 동작한다.
20_6.cpp MemoryMappedFile_CopyOnWrite.cpp
개방한 파일에는 0부터 8까지의 숫자가 순차적으로 저장되어 있다.
그런데 이 데이터를 0부터 8까지의 숫자를 정렬되지 않은 순서로 덮어쓰고 있다.
COW최적화 방식으로 동작시키려면 GENERIC_READ|GENERIC_WRITE, RAGE_WRITECOPY, FILE_MAP_COPY로 설정.
정렬된 데이터를 변경하였지만 실제 파일에는 반영되지 않은 것으로 COW기반으로 동작한 것을 확인.
MMF 기반에서 데이터를 변경하려는 순간에 파일의 복사본을 만들어서 작업했기 때문에 원본은 그대로 보존된 것.

이것만은 알고 갑시다
1. 가상 메모리의 페이지 상태
Reserve, Commit, Free의 의미와 용도 그리고 활용방법에 대해 설명.
2. 동적 힙 생성
동적 힙 생성이 가져다 주는 이점을 메모리 단편화 관점에서, 프로그램 구현 관점에서 각각 설명.
3. MMF(Memory Mapped File)
MMF는 파일의 일부 영역을 가상 메모리 일부에 연결시키는 메커니즘을 MMF라 한다.
그리고 COW에 대해서도 설명.

*/