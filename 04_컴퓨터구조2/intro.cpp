/*
01 컴퓨터 구조의 접근방법
이후에 공부하게 될 프로세스와 쓰레드를 이해하는 데도 큰 도움이 된다.

컴퓨터를 디자인하자
CPU를 구성하는 기본적인 요소는 ALU, 컨트롤 유닛 그리고 레지스터였다.
ALU와 컨트롤 유닛은 이미 존재한다고 가정하고 레지스터만을 디자인 해보자.
시스템프로그래머 입장에선 CPU를 보는 관점 대부분이 레지스터에 집중된다.

레지스터를 디자인하자
1)레지스터를 몇 비트로 구성할 것인가?
2)몇 개 정도로 레지스터를 구성할 것인가?
3)레지스터 각각을 무슨 용도로 사용할 것인가?
일단 16비트로 디자인하고, 개수도 8개로 제한해보자. r0 ~ r7
|r0   |
|r1   |
|r2   |
|r3   |
|r4 ir| ir = instruction register
|r5 sp| sp = stack pointer
|r6 lr| lr = link register
|r7 pc| pc = program counter
r4, r5, r6, r7은 각각 ir, sp, lr, pc라는 다른 이름을 지니도록 했는데, 특수한 목적으로 사용하기 위함.

위의 레지스터 구조는 ARM코어를 참조한 것이다.
이는 다른 어느 CPU보다 하드웨어 구성과 명령어 구조가 간단하다.
간단한 만큼 전력 소비가 아주 적어 핸드폰에 매우 적합한 코어이다.

명령어 구조 및 명령어를 디자인하자
"레지스터를 디자인하였으니, 이를 바탕으로 명령어를 디자인할 차례이다."
주목할 것은 레지스터와 명령어의 상관 관계이다.
CPU가 달라지면 이에 따른 명령어 구조가 달라지기 때문에, 어셈블리 언어로 구현된 프로그램은 구조가 다른
CPU로 이식이 불가능하다.
레지스터 크기를 16비트라고 결정했기 때문에 명령어 길이도 16비트로 구성하는 것이 좋다.
다음은 16비트의 활용방안인데 2의 16승에 해당하는 65536개가 될 것이다.
하지만 C/C++언어도 연산자를 포함하는 키워드 개수가 100개를 넘지않고 어느 CPU도 명령어가 세자리이상을 넘지 않는다.
CPU에게 일을 시킬 때는 "레지스터 r1에 있는 값과 숫자 7을 더해서 레지스터 r2에 저장하라" 같은 형태로.
이 모두를 16비트짜리 명령어 하나에 담을 수 있다면 아주 효율적일 수 있다.
<예약><연산자><저장소><피연산자1><피연산자2>
|    |  ADD  |  r2  |   r1     |    7    |
  2      3       3        4         4
저장소:레지스터
피연산자1,2:레지스터 or 숫자
레지스터가 총 8개이므로 3비트면 충분하므로 연산결과를 저장할 저장소는 레지스터만 오게 해서 3비트.
일반적인 ALU는 연산결과를 레지스터에 저장하기 때문이다.
피연산자에 레지스터 정보가 온다면, 레지스터 안에 저장된 데이터를 참조하는 것.
우리가 만들 수 있는 연산자 개수는 총 8개를 넘지 못한다.
덧셈, 뺄셈, 곱셈 그리고 나눗셈을 정의하고 어셈블리 프로그래밍을 할 때 사용되는 심볼도 결정.
  덧셈 ADD 001
  뺄셈 SUB 010
  곱셈 MUL 011
나눗셈 DIV 100
|  |001| r2| r1 |  7 |
각각의 레지스터는
r0    000
r1    001
r2    010
r3    011
r4,ir 100
r5,sp 101
r6,lr 110
r7,pc 111
|  |001|010| r1 |  7 |
피연산자는 숫자가 될수도 있고 레지스터가 될수도 있기 때문에 구분할 수 있어야 한다.
이를 위해 4비트 중 가장 첫 번째 비트가 1이면 레지스터 정보를 담고, 0이면 숫자정보를 담은 것으로 약속하자.
예약 부분은 별다른 정보를 나타내지 않는 관계로 0을 채워두자.
|00|001|010|1001|0111|
대신 피연산자가 표현할 수 있는 숫자가 8개 밖에 되지 않는 제약사항이 있다.
현존하는 대부분의 CPU에도 유사한 형태의 제약사항은 실제로 존재한다.
값을 표현하는 데 있어서 한계가 있기 때문.
우선 심볼을 기반으로 프로그램을 구현한다.
어셈블리 언어 기반의 프로그램 구현:ADD r2, r1, 7
이를 CPU가 인식할 수 있도록 하나의 2진 명령어 형태로 변환한다.
어셈블러에 의한 바이너리 코드 생성:0000 1010 1001 0111
이 명령어가 컨트롤 유닛으로 전달되어 그 의미가 해석되면, 컨트롤 유닛은 CPU의 각 모듈에 명령을 내린다.
그리고 CPU 각 모듈은 이 명령에 따라 적절한 연산을 진행한다.
ADD r2, r1, 7 ──────────> |00|001|010|1001|0111| ───┐
              1.Assemble                            │2.메모리 로드(Load)
┌──────────────────────────────────┐                v
│ ALU 5.Execution    |r0      |    │        ┌───|0...0111|
│  ^                 |r1      |    │        │   |        |
│  │                 |r2      |    │        │   |        |
│  │                 |r3      |    │        │    ...
│  │               ┌─|r4 ir   |<───│─┐      │    메모리
│ Control Unit <───┘  ...          │ │      │
│   4.Decode                       │ │      │
└──────────────────────────────────┘ │      │
			   CPU                   │      ↓3.Fetch
<───────────────────────────────────────────────────────>
					   I/O BUS       0...0111
명령어가 ir에 저장되는데 ir은 다음 번에 실행하게 될 명령어를 미리 가져다 놓는 용도로 사용.

CPU를 기반으로 어셈블리 프로그래밍을 한다면 sp, pc와 같은 레지스터들의 존재를 언어 레벨에서 확인할 수 있다.
하지만 ir의 존재에 대해서는 확인하지 못하는 경우가 대부분이다.
프로그래머 입장에서는 어차피 ir를 직접 컨트롤할 일이 없기 때문에 프로그래머에게 노출되지 않는다.

우리가 지금 구성하는 명령어의 형태에 따라서 컨트롤 유닛의 구조가 결정된다.
컨트롤 유닛은 명령어를 해석하는 일을 맡고 있다.
따라서 명령어 구성 및 해석방법을 정확히 알고 있어야만 해석이 가능하다.
그러므로 명령어의 형태에 따라서 컨트롤 유닛의 논리회로가 디자인되는 것이다.

"첫 번째 피연산자 위치에는 레지스터 이름이 와야 한다."
이 뜻은 연산결과는 일단 레지스터에 저장되어야 한다는 제약사항이 있음을 말해준다.
ARM이나 x86계열도 제약사항들이 존재한다.
물론 메모리 주소가 오게끔 디자인할 수도 있다.
그러나 명령어 구조가 복잡해지고, 이에 따라 하드웨어 구성도 더불어 복잡해진다.
뿐만아니라 명령어를 처리하는 데 걸리는 시간도 명령어 종류에 따라 다양해질 수 있다.
명령어 종류에 따라 처리되는 시간이 다양해지는 것은 단점이다.
"이러한 제약사항들은 CPU의 종합적 측면(성능, 비용 등등)이 고려되는 가운데서 등장하게 된다.
그러기 떄문에 우리는 이러한 제약사항을 지켜야 한다."
생각보다 직관적인 언어가 어셈블리 언어이기 때문에 개인에 따라서 모든 내용이 아죽 합리적일 수도 있다.

RISC vs CISC
모든 CPU가 명령어 구성에 제약사항을 따르진 않는다.
명령어 좋류가 많고, 다양한 조합이 가능한 CPU도 있다.
수백 개의 명령어 구성이 가능한 CPU도 있다.
명령어 종류가 많다는 것은 프로그램을 구현하는 데 있어서 편리함을 가져다 준다.
필요에 따라서 명령어 길이도 유동적이기 때문에 메모리를 효율적으로 사용할 수 있다는 장점도 지닌다.
이것은 CISC(Complex Instruction Set Computer)구조 CPU특징으로 복잡한 명령어 체계를 가지는 컴퓨터이다.
인텔의 16비트 CPU까지는 CISC구조였다.
반면에 CPU는 복잡해지고 성능 향상에 제한이 따른다.
보다 높은 성능의 CPU를 디자인하기 위해서는 보다 단순한 CPU구조가 필요하다.
이러한 요구사항을 충족시키는 것이 RISC구조이다.
CISC명령어의 10%정도 밖에 되지 않고 어쩌다 한번씩 사용하는 나머지 명령어를 위해 복잡하게 디자인하는 것은 
비효율적이라고 생각했다.
그래서 명령어 수를 대폭 줄이고, 명령어 길이를 일정하게 디자인해서 RISC구조를 탄생시킨다.
높은 성능을 낼 수 있고, 인텔의 32비트, 64비트뿐아니라 임베디드 환경에서 대부분 RISC구조이다.
초당 클럭 수를 높이는 것도 성능을 향상시키는 일이지만, 더 중요한 것은 클럭당 처리할 수 있는 명령어의 개수다.
RISC는 명령어 길이가 동일하고 명령어를 처리하는 과정이 일정해 클럭당 둘 이상의 명령어 처리가 가능(Pipelining).
바로 이점이 성능 향상에 있어서 RISC구조가 지니는 가장 큰 장점이 된다.

02 LOAD & STORE 명령어 디자인
이번에는 메인 메모리로부터 데이터를 읽어 오거나(Load) 저장(Store)하는 기능과 관련된 명령어를 디자인하면서
레지스터 필요성에 포커스를 맞춰보자.

LOAD & STORE 명령어의 필요성
명령어를 디자인하는 과정에서 "연산결과를 레지스터에만 저장할 수 있도록 하겠다"라는 제약사항이 있었다.
이 의미는 피연산자에는 메인 메모리의 주소값이 올 수 없다는 의미이다.
피연산자로 올 수 있는 것은 숫자와 레지스터로 제한했기 때문.
int a = 10; //0x10번지 할당
int b = 20; //0x20번지 할당
int c = 30; //0x30번지 할당
c = a + b;
"0x10번지(a)에 저장된 값과, 0x20번지(b)에 저장된 값을 더해서 0x30번지(c)에 저장해라"를 실행할 수 없다.
메인 메모리 주소 정보를 사칙연산의 피연산자로 올 수 있도록 구조를 설계하지 않았기 때문에 위와 같은 명령어는
만들어내지 못한다.(범용적으로 사용되는 RISC의 특징이다)
따라서 메인 메모리에 저장된 데이터를 레지스터로 일단 옮겨다 놓은 다음에, 덧셈을 진행해야 한다.
레지스터와 메인 메모리 사이에서 데이터를 전송할 수 있는 명령어가 필요한 상황.
         STORE
레지스터 셋 → 메인 메모리
           ←
          LOAD
메인 메모리에 저장된 데이터를 레지스터로 이동시키기 위한 LOAD명령어와 레지스터에 저장된 데이터를 메인 메모리로
이동시키기 위한 STORE 명령어가 필요하다.

LOAD & STORE 명령어의 디자인
메인 메모리에 존재하는 데이터를 레지스터로 이동시키는 명령어에 대해 LOAD라는 심볼을 붙여주자.
이전에 디자인한 사칙연산 명령어에 비해서 피연산자가  두 개(메인 메모리 정보, 레지스터 정보)면 된다.
<예약><LOAD><destination><source>
|    |  110|            |       |
  2     3        3          8
destination:데이터를 저장할 레지스터 정보
source:데이터를 읽어올 메모리의 주소 정보
LOAD는 이진 코드 110으로 정의하였으며, 목적지 정보와 데이터가 존재하는 위치 정보를 담을 수 있게 디자인했다.
목적지에는 메모리 주소 정보가 올 수 있도록 정의하였고, 데이터가 존재하는 위치에는 레지스터 정보를 담을 수 있게.
LOAD r3, 0x07
"0x07번지에 존재하는 데이터를 레지스터 r3에 저장하라."
|00|110|011|00000111|
컨트롤 유닛이 LOAD임을 판단하고 나면, 그 뒤에 오는 피연산자는 세 개가 아닌 두 개임을 알고, 그에 맞게
정보를 해석하는 과정을 거칠 것이다.
즉, 명령어 형태에 따라서 컨트롤 유닛이 디자인된다.
이번에는 레지스터에 존재하는 데이터를 메인 메모리로 이동시키는 명령어에 대해 STORE라는 심볼을 붙이고, 디자인.
<예약><STORE><source><destination>
|    |  111 |       |            |
  2     3       3         8
source:데이터를 읽어올 메모리의 주소 정보
destination:데이터를 저장할 레지스터 정보
STORE는 이진 코드 111로 정의하였으며 목적지와 데이터가 존재하는 위치정보를 담을 수 있도록 디자인.
다만 LOAD와 비교해 정반대이기 때문에 레지스터 정보가 source, 메모리 주소 정보가 destination.
STORE r2, 0x08
"레지스터 r2에 존재하는 데이터를 메인 메모리 0x08번지에 저장하라."
|00|111|010|00001000|

c = a + b를 실행하려면
|10| 0x10
|  |
|20| 0x20
|  |
| 0| 0x30
LOAD r1, 0x10 //0x10번지에 저장된 데이터를 r1로 이동
LOAD r2, 0x20 //0x20번지에 저장된 데이터를 r2로 이동
ADD r3, r1, r2 //r1, r2에 저장된 값을 더해서 r3에 결과 저장
STORE r3, 0x30 //r3에 저장된 값을 0x30번지에 저장
즉 피연산자가 레지스터가 되게끔 하기위해서 메모리에 저장된 값을 레지스터에 옮겨다 놓은 후 덧셈 연산.
┌──────────────────────────────────┐            1    
│                    |r0      |    │         ┌───|  10 | 0x10
│  ALU(ADD)<─────────|r1    10|<───│───┐     │  2| ... |
│  │       <─────────|r2    20|<───│──┐│     │┌──|  20 | 0x20
│  └────────────────>|r3    30|────│─┐││     ││ 3| ... |
│                    |r4 ir   |    │ │││     ││┌>|0->30| 0x30
│                     ...          │ │││     │││ | ... |
│                                  │ │││     │││  메모리
└──────────────────────────────────┘ │││     │││
			   CPU                   ↓││     ↓↓│
<───────────────────────────────────────────────────────>
					   I/O BUS     302010   102030

03 Direct 모드와 Indirect 모드(Direct Addressing, Indirect Addressing)
Direct모드의 문제점과 Indirect모드의 제안
하나의 명령어에 여러 정보를 담다 보니 표현하는 데이터 크기에 제한이 따른다는 문제점이 등장.
메인 메모리의 주소값을 나타내는 source부분에서 총 8개의 비트가 할당되어서 0x0000~0x00ff가 전부이기 때문.
지금까지 우리가 언급한 메모리 접근방법을 가리켜 Direct모드라 하는데, 모든 영역에 대한 접근이 불가능하다.
할당된 비트 수 안에서 표현 가능한 범위의 메모리 영역만 접근이 가능하기 때문.

Indirect 모드의 이해
Indirect모드의 등장은 메모리 접근방법에 다양성을 부여한다.
LOAD명령어에서는 레지스터에 저장할 데이터가 존재하는 주소를 직접적으로 표현하는데, 반대로 Indirect모드에선
명령어에서 지정하는 버지에 저장된 값을 주소값으로 참조하게 된다.
LOAD r1, 0x10(Direct)
|r0     |         | ...|
|r1     |<────────| 10 | 0x10
|r2     |         | ...| 
|r3     |         | ...| 0x20
|r4 ir  |         | ...|
|r5 sp  |         | ...| 0x30
|r6 lr  |         메모리
|r7 pc  |
LOAD r1, [0x10](Indirect)
0x10번지에서 값을 읽어오는 것이 아니라 0x10번지에 저장된 값을 주소값으로 참조해서 값을 읽어오고 있다.
|r0     |         | ...|
|r1     |<┐       |0x30|─┐ 0x10
|r2     | │       | ...| │
|r3     | │       | ...| │ 0x20
|r4 ir  | │       | ...| │
|r5 sp  | └───────| 10 |<┘ 0x30
|r6 lr  |         메모리
|r7 pc  |
0x10을 []기호로 감싸고 있다.
이는 Indirect모드로 메모리를 참조하는 명령어 구성을 위해서 정의해 놓은 기호.

문제는 source에 저장된 주소값이 Direct모드를 의미하는지, Indirect모드를 의미하는지 구분할 수 없다.
첫 두 비트의 용도를 결정하지 않았으므로, 이 영역을 활용하면 될 것같다.
STORE명령어에도 동일하게 적용된다.
STORE r1, [0x10]
|r0     |         | ...|
|r1     |─┐       |0x30|─┐ 0x10
|r2     | │       | ...| │
|r3     | │       | ...| │ 0x20
|r4 ir  | │       | ...| │
|r5 sp  | └──────>| 10 |<┘ 0x30
|r6 lr  |         메모리
|r7 pc  |

Indirect 모드 활용 예제
int a = 10; //0x0010번지 할당
int b = 20; //0x0100번지 할당
int c = 0;  //0x0020번지 할당
c = a + b;
| ...|
| 10 | 0x0010(a)
| ...|
|  0 | 0x0020(c)
| ...|
| 20 | 0x0100(b)
c = a + b;에서 기존에 다음과 같은 순서로 진행했다.
1)0x0010(a)번지와 0x0100(b)번지에 저장되어 있는 값을 각각 레지스터 r1, r2로 이동한다.
2)레지스터 r1과 r2에 있는 값을 더해서 레지스터 r3에 저장한다.
3)레지스터 r3에 저장된 값을 0x0020(c)번지에 저장한다.
LOAD r1, 0x0010 //0x0010번지에 저장된 데이터를 r1로 이동
LOAD r2, 0x0100 //0x0100번지에 저장된 데이터를 r2로 이동
문제는 8비트로 0x0000~0x00ff까지가 전부여서 0x100을 표현할 수 없다.
이 문제는 Indirect모드를 도입하면 해결 가능하다.
LOAD r2, 0x0100를 대신할 명령어들을 조합해보자.
0x0100은 256이니 이 숫자를 만들어 내는 것이 가장 최우선.
MUL r0, 4, 4 //r1에는 데이터 0x0010이 저장되어 있으므로 r0에 연산결과 저장
MUL r2, 4, 4
MUL r3, r0, r2
사칙연산 명령어 구조를 보면 피연산자로 상수가 올 때 범위가 0~7까지이다. 
이 숫자를 가지고 256을 조합해 내야만 한다.
r0에 일단 MUL명령어를 사용해 만들어낸 값 16을 저장하고, r2에도 16을 만들어서 저장한다.
그리고 마지막에 두 레지스터에 저장된 값을 곱해서 결과를 r3에 저장한다.
이제 r3에 저장된 주소값을 참조하여 메모리로부터 값을 읽어다가 레지스터 r2로 저장하면 된다.
LOAD r2, r3
r3의 위치에는 메모리의 주소 정보가 와야 한다.
LOAD명령어의 두 번째 피연산자도 레지스터 정보가 올 수 있도록 디자인하면 주소값이 직접 오는 경우와
레지스터 정보가 오는 경우를 구분하기 위해서 또 하나의 비트 수를 희생시켜야만 한다.
이제 Indirect모드의 메모리 참조방식이 어떻게 문제 해결의 키가 되는지 명령어를 조합해보자.
r3에 저장된 주소값을 참조하여 메모리로부터 값을 읽어다가 레지스터에 r2에 저장하는 것.
일단 레지스터 r3에 저장된 주소 데이터를 다시 메인 메모리로 옮겨다 놓는다.
STORE명령어로 표현할 수 있는 범위를 선택해야 한다.
STORE r3, 0x0030
그리고 메인 메모리를 Indirect모드로 참조해서 값을 읽어오도록 LOAD명령어를 구성한다.
LOAD r2, [0x0030]
드디어 0x0100번지에 저장된 데이터를 레지스터 r2에 저장하였다.
c = a + b에 해당하는 명령어 조합을 정리해보면
LOAD r1, 0x0010
MUL r0, 4, 4
MUL r2, 4, 4
MUL r3, r0, r2
STORE r3, 0x0030
LOAD r2, [0x0030]
ADD r3, r1, r2

이것만은 알고 갑시다
1. 명령어!
CPU의 디자인 과정에서 CPU에게 일을 시키기 위한 명령어가 만들어진다.
연산자에 대한 정보뿐만 아니라, 피 연산자에 대한 정보도 함께 들어감을 기억하자.
명령어의 종류에 따라서 정보를 담고 있는 방식도 다르다.
2. CPU의 내부 연산과 레지스터
3. Direct vs Indirect
메모리에 접근하는 방식은 크기 direct모드와 indirect모드.
direct모드는 명령어에서 지정하는 위치의 메모리를 참조하는 방식이고, indirect모드는 명령어에서 지정하는
위치에 저장된 값을 주소값으로 하여 메모리를 참조하는 방식이다.
indirect모드는 direct모드가 지니는 한계를 극복하는 데 도움을 준다.

*/