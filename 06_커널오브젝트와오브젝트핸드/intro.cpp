/*
01 커널 오브젝트에 대한 이해
Windows와 같은 운영체제는 기본적인 요소 이외에도 아주 다양한 기능적 요소들을 가지고 있다.
인터넷 익스플로러, 그림판, 계산기 등등.
하지만 커널이란, 컴퓨터를 운영하는 데 있어서 중심이 되는 운영체제 핵심부분을 뜻한다.
일반적으로는 커널과 운영체제는 같은의미로 사용되기도 한다.
하지만 커널 오브젝트가 맞지 운영체제 오브젝트는 아니다.
"커널에서 관리하는 중요한 정보를 담아둔 데이터 블록을 가리켜 커널 오브젝트라 한다."

커널 오브젝트의 이해
CreateProcess 함수 호출을 통해서 프로세스 생성을 요구했고, Windows운영체제가 요구에 맞게 생성했다.
따라서 프로세스를 생성하는 실질적인 주체는 운영체제가 된다.
생성된 프로세스를 관리하는 것도 운영체제가 한다.
여기서 관리는 프로세스 생성과 소멸, 그 사이에 일어나는 모든일들이 포함된다.
이렇게 동시에 여러 개의 프로세스를 관리하자면, 운영체제 입장에서 고정적으로 저장하고 갱신해야 할 정보들이 있다.
예를 들면 프로세스 상태정보(Running, Blocked ..)와 우선순위 정보가 될 수 있다.
이 두 가지 정보는 운영체제 내부에 저장되어야 한다.
그리고 프로세스 상태 정보와 프로세스 우선순위 정보가 변경될 때마다 갱신되어야 한다.
그래야 프로세스 스케줄러가 이 정보를 바탕으로 프로세스를 관리할 수 있다.
운영체제가 프로세스를 관리하기 위해서는 프로세스에 관련된 정보를 저장할 수 있어야 하고, 참조 및 변경도 가능해야.
이를 위해 구조체 하나를 만들었고 프로세스 상태 정보를 저장하기 위해 정의한 것.
프로세스가 생성될 때마다 '프로세스 관리 구조체'변수가 하나씩 생성되고, 새롭게 생성된 프로젝트 정보들로
초기화되는데, 이것이 커널 오브젝트(Kernel Object)의 정체이다.
이것을 이해해야 Windows에서 제공하는 많은 시스템 함수들을 완벽하게 이해할 수 있다.
CreateProcess 함수 호출           프로세스 관리 구조체(struct  _PObject{...})
         ↓프로세스 생성 요청                ↓프로세스 관리 구조체 변수        
     Windows OS ─── 생성 및 관리 ───> 커널 오브젝트
	     ↓생성                             ↑
	  Process ───── 프로세스 정보로 채워짐 ─┘
프로세스 커널 오브젝트의 기반이 되는 구조체 이름을 _PObject로 표시하고 있다.
구조체 이름이 무엇이고 멤버들 구성을 문서화한 것은 없다.
공부를 해나가면 대략 어떠한 정보를 저장하기 위한 멤버들로 구성되어 있는지는 짐작할 수 있다.
프로세스의 커널 오브젝트는 프로그래머가 직접 생성하거나 조작할 수 없기 때문.

그 이외의 커널 오브젝트들
프로세스가 생성될 때에만 커널 오브젝트가 생성되는 것은 아니다.
프로세스 내에서 프로그램 흐름을 구성하는 쓰레드를 생성할 때도, IPC(Inter Process Communication)를 위해
사용되는 파이프나 메일슬롯을 생성할 때에도 커널 오브젝트를 생성해 필요한 정보들을 채워야만 한다.
그래야 운영체제가 관리할 수 있다.
또 Windows에서는 파일을 생성할 때에도 커널 오브젝트가 생성된다.
파일 조차도 Windows 커널에 의한 관리 대상이기 때문.
커널 오브젝트의 종류에 따라서 서로 다른 구조체를 기반으로 생성된다.
대상에 따라서 관리되어야할 사항이 다르기 때문에 커널 오브젝트 형태도 다르다.
예를 들어 파일이 생성될 때, 더불어 생성되는 파일 커널 오브젝트 안에는 파일 속성(Read or Write...)의 정보.
그래서 Read모드로 개방된 파일에 데이터를 저장하는 경우, Windows에 의해 접근이 허용되지 않는다.
반면 프로세스 커널 오브젝트는 파일 속성정보 대신 우선순위를 저장하기 위한 멤버가 필요하다.
Windows커널에 의한 프로세스 스케줄링을 위해서.
"Windows운영체제는 프로세스, 쓰레드 혹은 파일과 같은 리소스들을 원활히 관리하기 위해 필요한 정보를 저장해야
한다. 이때 데이터를 저장하는 메모리 블록을 가리켜 커널 오브젝트라 한다."
혼동을 최소화하기 위해 데이터 블록을 "커널 오브젝트"라 하고, 프로세스나 파일을 "리소스"라 표현하겠다.
Windows커널에 의해서 관리되는 리소스 수만큼 커널 오브젝트도 생성된다.
Kernel Object                   Resource
파이프 커널 오브젝트 <────────>   파이프
프로세스 커널 오브젝트 <──────>   프로세스
쓰레드 커널 오브젝트 <────────>   쓰레드

오브젝트 핸들(Handle)을 이용한 커널 오브젝트의 조작
프로그래머가 직접 커널 오브젝트를 조작할 수는 없지만 함수 호출에 의한 간접적인 조작은 가능.
Windows에서 관리하는 리소스 특성을 변경시키기 위해서는(우선순위 변경같은) 해당 리소스의 커널 오브젝트를
조작해야 하는데 직접적인 조작은 불가능하지만 MS에서 제공해주는 시스템 함수를 이용하면 간접적으로 가능.

프로세스의 우선순위(Priority)변경
BOOL SetPriorityClass(
	HANDLE hProcess, 1)
	DWORD dwPriorityClass 2)
);
If the function fails, the return value is zero.
1)hProcess:우선순위를 변경할 프로세스의 핸들을 전달한다.
2)dwPriorityClass:새롭게 적용할 우선순위 정보를 전달한다.
핸들이란 커널 오브젝트에 할당되는 숫자에 지나지 않는다.
"hProcess가 가리키는 프로세스의 우선순위를 dwPriorityClass로 변경시킨다."

커널 오브젝트에 할당되는 숫자! 핸들(Handle)
우선 순위는 프로세스 커널 오브젝트에 존재한다.
여기에 저장되어 있는 우선순위 정보를 변경해야만 실제 프로세스에 반영될 것이다.
SetPriorityClass함수를 통해 요구를 해야한다.
"저기 있는 저 커널 오브젝트에 저장된 우선순위 정보를 높여 주세요"
특정 커널 오브젝트를 가리키는 것이 문제다.
Windows가 커널 오브젝트를 생성할 때마다 핸들이라는 정수값을 하나씩 부여하기 때문에 정수값만 알 수 있다면, 쉽다.
Handle                Kernel Object                   Resource
파이프 핸들 <────────> 파이프 커널 오브젝트  <────────>  파이프
프로세스 핸들 <──────> 프로세스 커널 오브젝트  <──────>  프로세스
쓰레드 핸들 <────────> 쓰레드 커널 오브젝트  <────────>  쓰레드
SetPriorityClass의 첫 번째 인자는 프로세스의 커널 오브젝트를 가리키는 핸들을 전달하는 것.

핸들 정보는 어디서?
핸들 정보를 얻는 방법은 커널 오브젝트의 종류에 따라서 다양하기 때문에 하나씩 알아가면 된다.
6_1.cpp Operation1.cpp
6_2.cpp Operation2.cpp
GetCurrentProcess함수는 현재 실행되고 있는 프로세스(호출한 프로세스)의 핸들을 얻을 때 사용되는 함수.
반환값을 통해 핸들을 얻게 된다.
HANDLE GetCurrentProcess(VOID);
Operation1.exe를 실행하면 Operation2.exe를 실행시키는데 Operation2.exe는 자신의 우선순위를 높인다.
듀얼코어 이상의 CPU를 사용한다면 결과는 달라진다.
원래 출력은 "Operation2.exe"가 무수히 출력되다가 한번씩 "Operation1.exe"가 출력될 것이다.
HIGH_PRIORITY_CLASS는 일반적인 프로세스들보다 실행에 있어서 긴급을 요하는 경우에 사용되는 우선순위.
예제를 실행시킨 상태에서 다른 프로그램들을 실행해보면 다른 프로그램들에게도 영향을 미치고 있다.
하지만 Operation1.exe가 한꺼번에 출력되지 않고, 부분적으로 이어서 출력되고 있을 것이다.
그것은 함수 호출이 완료되기도 전에 다른 프로세스에게 CPU할당 시간을 넘겨주기 때문에 발생한 것.
Operation1.cpp의 _fputts함수 호출이 완료되기도 전에 다른 프로세스에게 CPU할당 시간을 넘겨주었기 때문에.
"함수가 호출되어 실행되는 중간에도 할당시간을 다른 프로세스에게 넘겨줄 수 있다."

02 커널 오브젝트와 핸들의 종속 관계
커널 오브젝트의 종속 관계
"커널 오브젝트는 Windows운영체제에 종속적이다."
종속적이라는 것은 '독립적이지 못하다'는 뜻.
도서는 도서관에 종속적인 것처럼.
1)커널 오브젝트는 프로세스에 종속적인 것이 아니라 운영체제에 종속적인 관계로 커널 오브젝트의 소멸시점은
운영체제에 의해서 결정된다.
2)커널 오브젝트는 프로세스에 종속적인 것이 아니라 운영체제에 종속적인 관계로 여러 프로세스에 의해서 접근 가능.

핸들의 종속 관계
커널 오브젝트는 프로세스에 종속적이지 않고 운영체제에 종속적이지만 반대로 핸들(핸들 테이블)은 운영체제에
종속적이지 않고 프로세스에 종속적이다.

예제를 통한 종속 관계의 이해
커널 오브젝트의 공유 예제
커널 오브젝트는 여러 프로세스에 의해 접근 가능하다.
"A프로세스가 B프로세스를 생성한다. 그러자 B프로세스는 자신의 우선순위를 높인다. 잠시 후 열받은 A프로세스는
B프로세스의 우선순위를 원래대로 돌려 놓는다."
A프로세스가 B프로세스 우선순위를 변경시킨다는 것은 B프로세스의 커널 오브젝트에 A프로세스가 접근가능하다는 뜻.
이는 하나의 커널 오브젝트에 둘 이상의 프로세스가 접근 가능하다는 의미
6_3.cpp KerObjShare.cpp
Operation2.cpp는 실행과 동시에 자신의 우선순위를 높이도록 구현되어 있다.
우선 순위를 높이기 위해서는 핸들을 이용해서 커널 오브젝트에 접근해야만 한다.
Operation2.exe에서 접근한 커널 오브젝트는 자기 자신의 정보를 담고 있는 커널 오브젝트였다.
typedef strut _PROCESS_INFORMATION
{
	HANDLE hProcess; //프로세스의 핸들
	HANDLE hThread; //쓰레드 핸들
	DWORD dwProcessId; //프로세스의 ID
	DWORD dwThreadId; //쓰레드 ID
} PROCESS_INFORMATION;
즉, 프로세스 생성 시 얻은 프로세스의 핸들을 통해서 Operation2.exe의 커널 오브젝트에 접근하고 있는 상황.
결과적으로 두 개의 프로세스가 하나의 커널 오브젝트에 순서대로 접근하였다.
다시 말하면 커널 오브젝트가 공유되었다.
Operation2.cpp와 KerObjShare.cpp에서 접근하는 커널 오브젝트는 동일하지만, 핸들을 얻는 방법에는 차이가 있다.
이렇게 핸들을 얻는 방법은 커널 오브젝트의 종류와 상황에 따라서 다양하다.
SetPriorityClass함수 호출을 통해 우선순위를 같게 맞춰도 실행시간의 배분에는 약간의 차이가 있을 수 있다.
이것은 스케줄링 알고리즘에 의존적인 부분이다.
나름대로 운영체제의 특성을 관찰하는 자세도 필요하다.
"커널 오브젝트는 프로세스에 종속적인 것이 아니라 운영체제에 종속적인 관계로 여러 프로세스에 의해 접근(공유)가능"

PROCESS_INFORMATION 구조체
typedef strut _PROCESS_INFORMATION
{
	HANDLE hProcess; //프로세스의 핸들
	HANDLE hThread; //쓰레드 핸들
	DWORD dwProcessId; //프로세스의 ID
	DWORD dwThreadId; //쓰레드 ID
} PROCESS_INFORMATION;
운영체제는 프로세스를 생성할 때마다 프로세스들을 구분짓기 위한 ID(식별자)를 할당한다.
구조체의 dwProcessId는 새로 생성되는 프로세스 ID정보로 채워지게 된다.
"프로세스 핸들은 프로세스의 커널 오브젝트를 가리키기(구분짓기) 위한 것이고, 프로세스 ID는 커널 오브젝트가 아니라
프로세스 자체를 구분짓기 위한 것"
Windows운영체제는 프로세스를 생성하면, 내부적으로 쓰레드라는 개념의 '가벼운 프로세스'를 생성해서 이를 통해
main함수가 호출되게끔 디자인되어 있다.
CreateProcess함수를 통해서 프로세스를 생성하면 쓰레드라는 시스템 리소스도 더불어 생성되는 것.

03 커널 오브젝트와 Usage Count
"커널 오브젝트는 프로세스에 종속적인 것이 아니라, 운영체제에 종속적인 관계로 커널 오브젝트 소멸시기는
운영체제에 의해서 결정된다."
CreateProcess함수호출은 커널 오브젝트 생성의 원인이긴 하지만 프로세스 생성에 대한 요청이며, 요청 과정에서
운영체제가 관리의 용이성을 위해서 커널 오브젝트를 생성한 것.
즉 커널 오브젝트 생성 주체는 운영체제이다.

CloseHandle 함수에 대한 정확한 이해
A라는 이름의 프로세스가 생성되면 A프로세스를 위한 커널 오브젝트가 생성된다.
커널 오브젝트는 완전히 프로세스를 대표하게 된다.
역은 성립하지 않아 프로세스가 소멸된다고 해서 오브젝트가 소멸된다고 말할 수 없다.
소멸될 수도 있지만 소멸되지 않을 수 있다.
운영체제가 결정할 일이기 때문이다.

CloseHandle함수와 프로세스 소멸
6_4.cpp CloseHandleProb1.cpp
BOOL CloseHandle(
	HANDLE hObject
);
If the function succeeds, the return value is nonzero.
CloseHandle은 핸들을 닫는 기능을 지니고 있다.
핸들을 반환한다고 표현하기도 한다.
CloseHandle은 프로세스 핸들뿐만 아니라 다른 종류의 핸들을 반환할 때에도 사용되는 함수이다.
6_5.cpp CloseHandleProb2.cpp
KernelObjProb1 실행시 생성되는 프로세스는 실행과정에서 KernelObjProb2실행시 생성되는 프로세스를 생성한다.
그리고 2프로세스의 핸들을 이용해서 CloseHandle함수를 호출한다.
"2프로세스에 대해서 더 이상 내가 관여할 바 아니니, 2프로세스 핸들을 반환해라."

실행결과를 통한 분석
1프로세스가 종료됨에도 불구하고 2프로세스에 의한 출력은 계속되고 있다.
실행결과를 통해서 CloseHandle함수 호출에 의해서 2프로세스는 소멸되지 않았음을 확인할 수 있다.

CloseHandle 함수와 프로세스 종료코드
프로세스 종료 시 해당 커널 오브젝트를 소멸시키면 문제가 발생할 수 있다.
자식 프로세스의 정상적인 실행 완료 여부를 궁금해 하는 부모 프로세스를 만들어보자.
자식 프로세스는 문제가 발생하면 -1을, 정상적으로 실행이 완료되었다면 +1을 부모 프로세스에게 반환.
6_6.cpp OperationStateParent.cpp
6_7.cpp OperationStateChild.cpp
두 개의 실수를 입력받아서 나눗셈을 하는 프로그램으로 두 번째 입력된 숫자가 0이되면 오류 상황.
그래서 0인 경우 "exit(-1)"이고 잘 진행되면 "return 1"
return문에 의해 반환되는 값과 exit함수 호출 시 전달되는 인자값들은 종료 상황을 알리기 위해 사용한다.
일반적으로 종료코드 -1이나 0은 비정상적 종료를 알리고자 하는 경우에 많이 사용된다.

커널 오브젝트와 Usage Count
자식 프로세스의 종료코드는 자식 프로세스의 커널 오브젝트에 저장된다.
자식 프로세스가 종료될 때 커널 오브젝트도 동시에 소멸된다면 부모 프로세스는 종료코드를 얻을 수 없다.
때문에 프로세스가 종료되었다고 해서 커널 오브젝트까지 동시에 소멸시키지는 않는다.
커널 오브젝트를 참조하는 대상이 하나도 없을 때 소멸시키는 것이 가장 이상적이고, 이것이 Windows가 커널
오브젝트 소멸시기를 결정하는 방식이다.
다시 말하면 커널 오브젝트를 참조하는 프로세스가 하나라도 있을 시에는 커널 오브젝트는 소멸되지 않는다.
Windows는 이러한 정책을 기반으로 커널 오브젝트 소멸시기를 결정짓기 위해 Usage Count(참조 횟수)를 관리.
Usage Count가 0이 되는 순간, 해당 커널 오브젝트는 소멸된다.
부모 프로세스 ────────── 생성 ──────────> 자식 프로세스(자신의 커널 오브젝트 소유)
(자식 프로세스                                 ^
핸들을 소유)                                   |
     ↑                                        |
	 │										  v
	 └────────── 핸들 반환 ────────────── 자식 프로세스 커널 오브젝트
									          (둘 다 접근 가능)
프로세스는 생성과 동시에 커널 오브젝트의 Usage Count가 1이 된다.
만약 생성과 동시에 0으로 초기화된다면, 생성과 동시에 소멸된다.
이를 막기위해 자식 프로세스는 생성과 동시에 Usage Count가 1이 된다.
초기화된 이후부터는 커널 오브젝트에 접근 가능한 대상이 늘어날 때마다 Usage Count가 하나씩 증가한다.
접근 가능 대상이 늘어난다는 것은 커널 오브젝트에 접근 간으한 핸들 개수의 증가를 의미한다.
그러면 자식 프로세스의 Usage Count는 1이 아닌 2가 된다.
부모 프로세스가 CreateProcess함수 호출 과정에서 자식 프로세스의 핸들을 얻기 때문이다(pi를 통해서)
자식 프로세스 생성이 완료되면 Usage Count는 2가 된다.
자식 프로세스는 GetCurrentProcess함수 호출을 통해 언제든 자신의 커널 오브젝트 참조를 위한 핸들을 얻을 수 있다.
Usage Count는 커널 오브젝트의 멤버로 존재한다.

Usage Count와 CloseHandle
만약 자식 프로세스가 Busy Waiting상태에서 종료된다고 가정하면
                                 종료코드 저장
부모 프로세스 ─────> Usage count = 1 <──x── 자식 프로세스 종료
             참조     커널 오브젝트    단절
자식 프로세스가 종료되니 커널 오브젝트에 접근하는 대상이 하나 줄어든다.
비록 자식 프로세스 정보를 담고 있는 커널 오브젝트이지만, Usage Count가 1인 관계로 소멸되지 않는다.
CloseHandle함수를 호출하면 전달되는 인자가 자식 프로세스 핸들이므로, 자식 프로세스의 커널 오브젝트에 더 이상
접근하지 않겠다는 의미이다.
따라서 Usage Count가 하나 더 감소한다.
								 종료코드 저장
부모 프로세스 ──x──> Usage count = 0 <──x── 자식 프로세스 종료
			 단절   커널 오브젝트 소멸  단절
CloseHandle함수는 핸들을 반환하면서 커널 오브젝트의 Usage Count를 하나 감소시키는 기능을 지닌다.
한 가지 더 기억할 것은 프로세스(쓰레드)의 경우에는 프로세스가 종료되는 시점에서도 Usage Count가 하나 감소.

GetExitCodeProcess함수 호출 이전에 CloseHandle함수가 호출되면 정상적인 결과를 기대할 수 없다.
CloseHandle함수가 호출되고 나면 핸들은 더 이상 의미를 지니지 않는다.
의미가 없는 핸들을 통해서 커널 오브젝트에 접근 불가능하다.
불가능하니 종료코드를 얻을 수 없다.

프로세스 강제 종료
CloseHandle 함수와 프로세스 종료는 별개의 문제이다.
프로세스 종료를 요청하는 데 사용되는 함수는 별도로 존재한다.
TerminateProcess는 프로세스 종료를 요청하는데 문제는 강제 종료 요청이다.
대상이 되는 프로세스 상태는 상관없이 무조건 종료시켜 달라는 요청이다.
그러나 부모 프로세스라 하더라도 자식 프로세스를 강제 종료시키는 것은 좋지 못한 방법이다.
강제 종료하면 일반적인 종료와는 달리 문제점이 생기기 때문이다.
프로세스가 자신의 일을 끝마치고 마지막으로 return문을 통해 종료하는 것이 가장 안정적.
TerminateProcess는 종료하고픈 프로세스의 핸들을 인자로 전달하면 된다.
악성코드를 막기 위한 것이 아니라면 쓸 상황은 거의 없을 것이다.

Calculator.cpp의 문제점 그리고 해결책
6_8.cpp Calculator2.cpp
계산기 커널 오브젝트의 Usage Count값은 자식 프로세스로 생성되었기 때문에 2이다.
프로세스가 종료되면 Usage Count가 하나 감소하고 1이 된다.
Usage Count가 0이 아닌 관계로 커널 오브젝트는 소멸되지 않고 남아 있게 된다.
비록 계산기는 종료되었더라도 말이다.
사용자가 계속해서 ELSE에 해당하는 숫자 5를 입력하면 커널 오브젝트가 소멸되지는 않은 채 누적될 수 있다.
해결하기 위해서 계산기 실행 시마다 얻게 되는 프로세스 핸들을 인자로 CloseHandle함수를 호출하면 된다.
자식 프로세스를 생성하자마자 CloseHandle함수를 호출하면 자식 프로세스의 커널 오브젝트 Usage Count는 1이된다.
따라서 자식 프로세스 종료 시 Usage Count는 0이 되어 커널 오브젝트도 함께 소멸된다.
하지만 쓰레드 커널 오브젝트와 관련된 문제가 아직 남아있다.
쓰레드라는 리소스도 생성과정에서 커널 오브젝트의 생성을 동반하기 때문에 동일한 문제가 있다.
따라서 쓰레드도 CloseHandle해주면 된다.
자식 프로세스 생성과 동시에 핸들을 반환하는 것이 일반적이나, 핸들의 반환시점을 뒤로 미뤄야 하는 경우도 있다.
예를 들어 종료코드를 얻기 위해서는 CloseHandle 함수의 호출을 뒤로 미룰 수 밖에 없다.

문제의 정답은?
바탕화면에 있는 아이콘을 더블클릭해서 프로세스를 생성할 경우, 이 프로세스의 Usage Count는?
바탕화면도 일종의 프로세스이기 때문에 Usage Count는 2이다.
바탕화면도 독립적으로 실행 중에 있는 프로세스이고, 더블클릭이라는 이벤트를 통해 바탕화면 프로세스에게
프로세스 생성을 요청하는 것이다.
작업 관리자를 띄워 Explorer.exe를 프로세스 끝내기를 누르면 경고가 나오고 바탕화면의 아이콘들이 사라진다.
프로그램을 실행시키는 바탕화면 관리자 프로세스가 종료됐기 때문이다.
명령 프롬프트상에서 explorer.exe를 입력하고 실행하면 다시 돌아온다.
결론적으로 바탕화면에서 프로세스를 실행시키건, 탐색기를 띄워서 실행시키건 부모 프로세스를 기반으로 자식
프로세스를 생성하는 것이 되어서 프로세스는 생성과 동시에 Usage Count는 2가 된다.
다행히도 바탕화면 프로세스는 자식 프로세스 생성과정에서 얻게되는 핸들을 즉시 반환해서 문제는 없다.

이것만은 알고 갑시다
1. 커널 오브젝트와 핸들
2. 운영체제에 종속적인 커널 오브젝트
3. Usage Count
4. CloseHandle 함수
5. 프로세스의 Usage Count
프로세스는 생성과 동시에 Usage Count가 2가 된다.
6. 종료코드
7. 부모 프로세스가 자식 프로세스 핸들을 곧바로 반환하는 이유




*/