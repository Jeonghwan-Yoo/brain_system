/*
중요한 것은 쓰레드간에 발생할 문제의 소지를 미연에 차단하는 것.
동기화 문제만 잘처리해도 멀티 쓰레드 프로그래밍에서 발생하는 문제의 80~90%는 미리 막을 수 있다.
동기화에 관련된 문제는 컴파일타임에 발생하는 오류가 아니라, 런타임에 발생하는 오류다.
런타임에 발생 가능한 오류를 미리 예측하고 막을 수 있어야 한다.

01 쓰레드 동기화란 무엇인가?
두 가지 관점에서의 쓰레드 동기화
동기화는 일치한다는 의미에서의 동기화가 아니라 순서에 있어서 질서가 지켜지고 있음을 의미하는 동기화.

실행순서의 동기화
쓰레드의 실행순서가 중요한 경우가 있다.
A쓰레드가 계산한 결과를 B쓰레드가 받아서 출력하는 경우, 반드시 A쓰레드를 먼저 실행해야 한다.
즉 쓰레드의 실행순서를 정의하고, 이 순서에 반드시 따르도록 하는 것이 쓰레드 동기화이다.

메모리 접근에 대한 동기화
한 순간에 하나의 쓰레드만 접근해야 하는 메모리 영역이 존재한다.
대표적으로 데이터 영역과 힙이다.
데이터 영역에 할당된 변수를 둘 이상의 쓰레드가 동시에 접근할 때에는 문제가 발생하고 만다.
이렇게 메모리 접근에 있어서 동시접근을 막는 것 또한 쓰레드의 동기화에 해당한다.

두 가지 모두 실행에 있어서 순서를 중요시하지만 차이가 나는 부분은 상황이다.
"실행순서의 동기화"의 상황은 실행, 혹은 접근의 순서가 이미 정해져 있는 상황이다.
"메모리 접근의 동기화"는 실행의 순서보단 한 순간에 하나의 쓰레드만 접근하면 되는 상황이다.
메모리에 동시접근하는 문제점만 발생하지 않으면 된다.
실행순서를 동기화한다는 것은 쓰레드의 메모리 접근순서를 동기화하기 위한 경우가 대부분이다.
그래서 "실행순서의 동기화"도 메모리 접근과 관련이 있다.

쓰레드 동기화에 있어서의 두 가지 방법
Windows에서는 다양한 동기화 기법을 제공한다.
상황에 따라 어울리는 동기화 기법은 존재한다.
Windows에서 제공하는 동기화 기법은 제공하는 주체에 따라 하나는 User Mode Synchronize기법이고 다른 하나는
Kernel Mode Synchronize기법이다.

유저 모드 동기화
동기화가 진행되는 과정에서 커널의 힘을 빌리지 않는(커널 코드가 실행되지 않는)동기화 기법이다.
따라서 동기화를 위해서 커널 모드로의 전환이 불필요하기 때문에 성능상에 이점이 있다.
다만 그만큼 기능상의 제한도 있다.

커널 모드 동기화
커널에서 제공하는 동기화 기능을 활용하는 방법이다.
따라서 동기화에 관련된 함수가 호출될 때마다 커널 모드로의 변경이 필요하고, 이는 성능의 저하로 이어지게 된다.
하지만 그만큼 유저 모드 동기화에서 제공하지 못하는 기능을 제공 받을 수 있다.

02 Critical Section 접근 동기화
"메모리 접근의 동기화"관점이고 한 순간에 하나의 쓰레드만 접근해야 하는 상황이다.
메모리 영역의 접근을 동기화한다는 것은 "임계 영역의 접근을 동기화"하겠다는 뜻.
임계영역이 메모리를 의미하지는 않는다.

임계 영역에 대한 이해
13_1.cpp CriticalSection.cpp
각 입구마다 총 1000명의 사람이 입장했다고 가정하고 증가시키고 있다.
하지만 연산을 둘 이상의 쓰레드가 동시에 실행할 경우 문제가 발생한다.
이러한 문제를 일으키는 코드 블록을 가리켜 Critical Section이라고 한다.
문제의 원인이 될 수 있는 코드의 블록을 가리켜 임계영역이라고 하고 메모리 공간이 아니다.
즉 Critical Section이란 배타적접근(한 순간에 하나의 쓰레드만 접근)이 요구되는 공유 리소스(전역변수)에 접근하는
코드 블록을 의미한다.
문제점의 해결책은 임계 영역의 동시접근을 막는 것이다.
즉 동기화 기법을 통해 임계영역은 한 순간에 하나의 쓰레드만 실행될 수 있도록 제한하면 된다.

Windows는 아주 다양한 동기화 기법을 제공한다.
유저 모드 동기화
1)Critical Section 기반의 동기화(메모리 접근 동기화에 사용)
2)Interlocked Family Of Function 기반의 동기화(메모리 접근 동기화에 사용)
커널 모드 동기화
3)Mutex 기반의 동기화(메모리 접근 동기화에 사용)
4)Semaphore 기반의 동기화(메모리 접근 동기화에 사용)
5)Named Mutex 기반의 프로세스 동기화(프로세스간 동기화에 사용)
6)Event 기반의 동기화(실행순서 동기화에 사용)
목적에 적합한 동기화 기법을 사용하면 간결하고 정확한 코드가 나온다.

03 유저 모드의 동기화
유저 모드 동기화 기법을 적용하면 커널 모드로의 전환이 불필요하기 때문에 성능상의 이점을 얻을 수 있다.
그리고 커널 모드 동기화에 비해 활용하는 방법도 단순하다.
따라서 이 기법으로도 문제해결이 가능하면 굳이 커널 모드 동기화 기법을 사용할 필요는 없다.

Critical Section은 원래 임계 영역을 뜻하는 용어지만 여러 동기화 기법 중 하나를 지칭하는 용도로도 사용한다.

Critical Section 기반의 동기화
크리티컬 섹션 기반의 동기화를 사용하려면 크리티컬 섹션 오브젝트라는 것을 만들고 초기화해야 한다.
크리티컬 섹션 오브젝트는 자료형 CRITICAL_SECTION의 변수를 말한다.
CRITICAL_SECTION gCriticalSection; //critical section object
크리티컬 섹션 오브젝트를 선언한 다음에는 다음 함수를 통해 반드시 초기화해야 한다.
초기화 과정을 통해 크리티컬 섹션 오브젝트는 사용 가능한 상태가 된다.
void InitializeCritialSection(
	LPCRITICAL_SECTION lpCriticalSection 1)
);
1)lpCriticalSection:초기화하고자 하는 크리티컬 섹션 오브젝트의 주소값을 인자로 전달한다.
정리해보면
CRITICAL_SECTION gCriticalSection; //critical section object
int _tmain(int argc, TCHAR* argv[])
{
	InitializeCriticalSection(&gCriticalSection); //initialize object
	...
}
화장실 열쇠를 걸어놓았으니 화장실에 들어가기 위해서는 열쇠를 사용해야 한다.
따라서 화장실에 들어가기 위해서 열쇠를 획득하는 행위가 필요하고, 화장실에서 나온 후 제자리에 걸어두는 행위가 필요.
void EnterCriticalSection(
	LPCRITICAL_SECTION lpCriticalSection 1)
);
1)lpCriticalSection:임계 영역에 진입하기 위해 필요한 크리티컬 섹션 오브젝트의 주소값을 인자로 전달한다.
이미 호출된 상태라면, 호출된 함수는 블로킹되고 반환되면 블로킹 상태에 있던 함수는 빠져나온다.
함수호출이 성공하고 임계 영역에 들어가면 쓰레드가 크리티컬 섹션 오브젝트를 획득한 것이다.
void LeaveCriticalSection(
	LPCRITICAL_SECTION lpCriticalSection 1)
);
1)lpCriticalSection:임계 영역을 빠져 나오고 나서 호출하는 함수이다.
만약 블로킹 상태에 놓은 쓰레드가 있었다면 이 함수 호출로 인해 블로킹 상태에서 빠져나와 임계 영역으로 진입한다.
이 함수호출이 완료되면 호출한 쓰레드가 크리티컬 섹션 오브젝트를 반환한 것이다.
정리해보면
//임계 영역 진입을 위해 크리티컬 섹션 오브젝트 획득
EnterCriticalSection(&CriticalSection);
...
//크리티컬 섹션 오브젝트 반환
LeaveCriticalSection(&CriticalSection);
임계 영역이 결정되면 이 영역은 한 순간에 하나의 쓰레드만 실행할 수 있도록 구성하는 것이 핵심.
끝으로 초기화 함수가 호출되는 과정에서 할당된 리소스들이 존재하는데 반환해야 한다.
void DeleteCriticalSection(
	LPCRITICAL_SECTION lpCriticalSection 1)
);
1)lpCriticalSection:반환하고자 하는 크리티컬 섹션 오브젝트의 주소값을 인자로 전달한다.
13_2.cpp CriticalSectionSync.cpp

운영체제에서는 임계 영역 접근 동기화를 "상호 배제 동기화(Mutual-Exclusion Synchronization)".

인터락 함수 기반의 동기화
전역으로 선언된 변수 하나의 접근방식을 동기화하는 데 사용.
인터락 함수는 함수 내부적으로 한 순간에 하나의 쓰레드에 의해서만 실행되도록 동기화되어 있다.
LONG InterlockedIncrement(
	LONG volatile* Addend 1)
);
The function returns the resulting incremented value.
1)Addend:값을 하나 증가시킬 32비트 변수의 주소값을 전달한다. 둘 이상의 쓰레드가 공유하는 메모리에 저장된 값을
이 함수를 통해 증가시키면 동기화된 상태에서 접근하는 것과 동일한 안정성.
LONG InterlockedDecrement(
	LONG volatile* Addend 1)
);
The function returns the resulting decremented value.
1)Addend:값을 하나 감소시킬 32비트 변수의 주소값을 전달한다. 둘 이상의 쓰레드가 공유하는 메모리에 저장된 값을
이 함수를 통해 감소시키면 동기화된 상태에서 접근하는 것과 동일한 안정성.
위의 함수들은 원자적 접근, 즉 한 순간에 하나의 쓰레드만 접근하는 것을 보장해 주는 함수이다.
따라서 모든 쓰레드가 이 함수들을 통해 값을 증가시키거나 감소시키면 동시에 둘 이상의 쓰레드 접근은 발생하지 않음.
크리티컬 섹션 동기화 기법도 내부적으로는 인터락 함수를 기반으로 구현되어 있다.
인터락 함수들도 유저 모드 기반으로 동작하기 때문에 속도가 상당히 빠르다.
13_2_2.cpp
한줄로 쓰레드 동기화를 완료시킬 수 있다.
MS에서는 보다 다양한 인터락 함수들을 제공해서 원하는 만큼 증가 감소 시키는 함수도 있다.

탐구생활
EnterCriticalSection함수의 호출도 동일하게 동기화가 되어야 되고 이 함수를 둘 이상의 쓰레드가 동시에 호출하게
되면 문제가 발생하는데 문제를 막기 위해 다양한 방법이 사용된다. 인터럽트 Enable/Disable과 관련이 있다.
인터럽트가 Disable되면 클럭 신호가 전달되지 않으므로 쓰레드간 컨텍스트 스위칭이 일어나지 않는다.

volatile이라는 키워드는 C,C++언어의 ANSI 표준 키워드.
volatile은 크게 두 가지 의미를 갖는다.
1)"최적화를 수행하지 마라."
컴파일러는 프로그래머가 프로그래밍해 놓은 코드를 컴파일하는 과정에서 코드의 최적화를 수행한다.
컴파일 과정에서 프로그램의 실행결과가 동일하다는 관점에서 최적화가 이뤄질 수도 있다.
(int a = 10;a = 30; -> int a = 30;)
하지만 최적화가 문제가 되는 상황이 존재한다.
임베디드 시스템을 구성할 때에는 Memory Map디자인과정을 거치는데 이 과정에서 출력을 위해 사용되는 LCD나
소리를 위해 사용되는 오디오 칩과 같은 하드웨어 장치에도 주소를 할당하게 된다.
즉 메모리 주소가 RAM과 같은 저장장치뿐 아니라, 하드웨어 장치에도 할당된다.
int function(void)
{
	int* pSound = 0x30000; //오디오 장치의 주소 값 지정
	*pSound = 1; //오디오 장치에 '도' 음을 내기 위해 1 전송
	*pSound = 2; //오디오 장치에 '미' 음을 내기 위해 2 전송
	*pSound = 3; //오디오 장치에 '솔' 음을 내기 위해 3 전송
	*pSound = 1; //'도'음을 내기 위해 다시 1 전송
}
컴파일러가 최적화를 수행해버리면
int function(void)
{
	int* pSound = 0x30000;
	*pSound = 1;
}
그 사이에서 벌어지는 일들을 모두 생략해 버린다.
컴파일러에게 "최적화를 수행하지 말아주세요"라고 부탁해야 한다.
int function(void)
{
	int volatile* pSound = 0x30000;
	...
}
pSound를 volatile로 선언하면 컴파일러는 이 포인터를 기반으로 하는 모든 연산에 대해 최적화를 고려하지 않는다.
2)"메모리에 직접 연산하라!"
int function(void)
{
	int* pSound = 0x30000;
	SleepUntil(3, 35, 12); //3시 35분 12초까지 프로그램 실행을 멈춘다. 가상의 함수
	*pSound = 2;
	...
}
pSound가 가리키는 주소 0x30000에 데이터 2가 입력되면서 '미'음이 발생해야 한다.
그런데 성능 향상을 위해 동작 중인 캐쉬 매니저가 값을 메모리에 저장한 것이 아니라 캐쉬 메모리에 저장한 것.
언젠가는 캐쉬에 저장된 데이터가 메모리에 저장되므로 '미'음이 발생하겠지만, 원하는 시점에서 들을 수 없다.
이런 문제를 막기 위해 volatile키워드를 선언하면 해당 데이터는 절대로 캐쉬되지 않는다.
해당 포인터가 가리키는 메모리 공간으로 전송되는 데이터는 절대로 캐쉬되지 않는다.
그래서 숫자 2를 0x30000번지에 저장하는 순간 오디오 칩으로의 데이터 전송이 바로 이뤄진다.
인터락의 volatile은 전달되는 포인터를 이용해 함수 내부적으로 최적화를 수행하지 않고, 해당 포인터가 가리키는
메모리 영역을 캐쉬하지 않겠다는 것.
따라서 변수를 직접 volatile로 선언하고, 선언된 변수의 주소값을 인자로 전달할 필요는 없다.

04 커널 모드 동기화
유저 모드 동기화에 비해 느리다.
유저모드에서 커널모드로, 그리고 다시 커널 모드에서 유저 모드로의 전환이 필요하기 때문.
그러나 Windows커널 레벨에서 제공해주는 동기화기법이기 때문에 유저모드 동기화가 제공해주지 못하는 기능을 받는다.

Mutex기반의 동기화
뮤텍스 기반 동기화 기법의 경우에는 열쇠에 비유하는 것이 뮤텍스 오브젝트이고 함수를 통해 만들어진다.
HANDLE CreateMutex(
	LPSECURITY_ATTRIBUTES lpMutexAttributes, 1)
	BOOL bInitialOwner, 2)
	LPCTSTR lpName 3)
);
If the function fails, the return value is NULL. 4)
1)lpMutexAttributes:프로세스도 커널 오브젝트이고 뮤텍스도 커널 오브젝트여서 프로세스와 마찬가지로 보안속성지정.
새로운 프로세스 생성시 핸들을 상속해 줄 것인지 말지를 결정하는데 활용하였다.
2)bInitialOwner:뮤텍스 오브젝트를 생성하는 쓰레드에게 기회를 먼저 줄 수 있다. 크리티컬 섹션처럼 먼저 차지하는
사람이 임자가 되게 할 수도 있고(FALSE) 뮤텍스를 생성하는 쓰레드가 먼저 기회를 얻을 수도 있다(TRUE)
3)lpName:뮤텍스에 이름을 붙여주기 위해 사용한다. 이름은 NULL문자로 끝나는 문자열로 지정하면 된다.
이름을 주었을 때 생성되는 뮤텍스를 가리켜 Named Mutex라 표현한다.
4)반환 타입이 HANDLE이라는 것은 뮤텍스가 커널 오브젝트임을 말하는 것이다.

뮤텍스가 커널 오브젝트인 저만 보아도, 뮤텍스는 커널 레벨 동기화 기법임을 알 수 있다.
뮤텍스는 크리티컬 섹션 오브젝트와 달리 초기화함수의 호출이 필요없다.
이미 함수를 호출하는 과정에서 필요한 모든 초기화가 이뤄지기 때문.
"커널 오브젝트는 Signaled나 Non-Signaled상태를 지니고 보통 커널 오브젝트는 Non-Signaled상태에 놓였다가,
특정 상황이 되면 Signaled상태가 된다. 이 특정 상황은 커널 오브젝트에 의존적이다."
"쓰레드나 프로세스의 정보를 담고 있는 커널 오브젝트의 경우에는 해당 쓰레드나 프로세스가 종료되었을 때
비로소 Signaled 상태가 된다."
"뮤텍스는 누군가에 의해 획득이 가능할 때 Signaled 상태에 놓인다."
뮤텍스는 커널 오브젝트이고 누군가에 의해 획득이 가능할 때 Signaled 상태에 놓인다.
따라서 WaitForSingleObject함수를 임계영역 진입을 위한 뮤텍스 획득의 용도로 사용 가능하다.
반면에 뮤텍스를 반환할 때에는 다음 함수를 이용해서 반환하게 하고 Non-Signaled 상태가 된다.
BOOL ReleaseMutex(
	HANDLE hMutex 1)
);
If the function fails, the return value is zero.
1)hMutex:반환할 뮤텍스의 핸들을 인자로 전달한다. Non-Signaled상태에 있는 뮤텍스는 Signaled가 된다.
WaitForSingleObject는 인자로 전달된 핸들의 커널 오브젝트가 Signaled 상태가 되어서 반환하는 경우,
해당 커널 오브젝트를 Non-Signaled 상태로 변경해 버린다.

쓰레드 -> (입구) 임계 영역 (출구) -> 쓰레드
  ↑                                  │
  └─────────────── Mutex ←───────────┘
WaitForSingleObject(획득)  ReleaseMutex(반납)

쓰레드는 임계 영역에 들어가기에 앞서 뮤텍스를 획득해야 한다.
따라서 뮤텍스 핸들을 인자로 전달하면서 WaitForSingleObject함수를 호출한다.
획득 가능한 상태라면 Signaled상태이고, 뮤텍스를 획득하면서 임계 영역에 진입하게 된다.
WaitForSingleObject함수는 커널 오브젝트가 Signaled상태가 되어 반환할 경우, 해당 커널 오브젝트의 상태를
Non-Signaled상태로 변경하므로, 다른 쓰레드들은 임계 영역으로의 진입이 제한된다.
임계 영역에서 일을 마친 쓰레드가 임계 영역을 빠져나오면서 ReleaseMutex함수를 호출한다.
이 함수가 호출되면, 뮤텍스는 다른 누군가에게 획득이 가능한 상태, 즉 Signaled상태가 되어서 다른 쓰레드의
진입을 허용한다.
뮤텍스는 커널 오브젝트이므로 CloseHandle함수를 호출하면서 핸들을 반환하면 된다.
소멸은 운영체제가 알아서 해준다.
13_3.cpp CriticalSectionSyncMutex.cpp
WaitForSingleObject함수는 다양한 용도로 사용되니 Wrapping해서 사용하는 방법을 추천한다.
그러면 코드의 의미를 보다 명확히 할 수 있다.
DWORD AcquireMutex(HANDLE mutex)
{
	return WaitForSingleObject(mutex, INFINITE);
}
컴파일러가 대부분 최적화 과정에서 함수의 호출 문장을 함수의 몸체 부분으로 대치시켜버리므로 성능의 저하는 없다.

Semaphore 기반의 동기화
세마포어 중에서 단순화된 세마포어를 가리켜 뮤텍스라 할 수 있다.
세마포어는 카운트 기능이 존재하지만, 뮤텍스에는 존재하지 않는다.
뮤텍스에는 임계 영역에 접근 가능한 쓰레드 개수를 조절하는 기능이 없지만 세마포어는 가지고 있다.
임계 영역의 접근 허용 쓰레드 개수를 하나로 제한하기 위해 사용되는 세마포어를 가리켜 바이너리 세마포어라 하는데
뮤텍스와 동일한 기능을 제공하게 된다.

세마포어 오브젝트를 생성하는 함수
HANDLE CreateSemaphore(
	LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, 1)
	LONG lInitialCount, 2)
	LONG lMaximumCount, 3)
	LPCTSTR lpName 4)
);
If the function fails, the return value is NULL.
1)lpSemaphoreAttributes:보안 속성을 지정하기 위한 매개변수.
2)lInitialCount:세마포어에서 가장 중요한 전달인자로서 세마포어는 값을 지니는데 값을 기반으로 임계 영역에
접근 가능한 쓰레드의 개수를 제한한다. 전달인자 값이 10이면 총 10개의 쓰레드가 임계 영역에 접근 가능.
3)lMaximumCount:세마포어가 지닐 수 있는 값의 최대 크기를 지정한다. 값이 1이면 뮤텍스와 동일한 기능을 하는
바이너리 세마포어가 구성된다. 기본적으로 lIniticalCount로 전달되는 값보다 커야 한다.
4)lpName:세마포어에 이름을 붙이기 위해 사용한다.
세마포어가 생성될 때 전달인자 lInitialCount에 의해 초기 카운트가 결정된다.
카운트가 0인 경우 Non-Signaled상태에 놓이게 되며, 1이상인 경우 Signaled상태에 있게 된다.
그리고 세마포어의 핸들을 인자로 전달하면서 WaitForSigleObject함수를 호출하면 값이 하나씩 감소하며 함수를 반환.
따라서 초기 카운트가 10인 경우 WaitForSingleObject가 10번 호출될 때까지 하나씩 감소하면서 함수를 반환한다.
그리고 11번째 호출 시 세마포어 카운트가 0인 관계로 불로킹 상태가 된다.

쓰레드1,2,... -> (입구) 임계 영역 (출구) -> 쓰레드1,2,...
  ↑                                        │
  └────────────────── Semaphore ←──────────┘
WaitForSingleObject(감소)  ReleaseSemaphore(증가)

임계 영역을 빠져 나온 쓰레드는 ReleaseSemaphore함수를 호출해야 한다.
이 함수는 세마포어 카운트를 증가시키는 역할.
BOOL ReleaseSemaphore(
	HANDLE hSemaphore, 1)
	LONG lReleaseCount, 2)
	LPLONG lpPreviousCount 3)
);
If the function fails, the return value is zero.
1)hSemaphore:반환하고자 하는 세마포어의 핸들을 인자로 전달한다.
2)lReleaseCount:반환한다는 것은 세마포어 카운트의 증가를 의미한다. 이 인자를 통해 증가시킬 값의 크기를 결정할 수
있다. 2를 전달하면 카운트는 2가 증가하는데 아주 특별한 경우가 아니라면 1을 전달. 만약에 세마포어 생성 시
결정한 최대 카운트 값을 넘겨 증가시킬 것을 요구하는 경우에는 카운트는 변경되지 않고 FALSE만 반환한다.
3)lpPreviousCount:변경되기 전 세마포어 카운트 값을 저장할 변수를 지정하고 필요없다면 NULL을 전달.
13_4.cpp MyongDongKyoJa.cpp
WaitForMultipleObjects함수가 관찰할 수 있는 최대 커널 오브젝트의 수는 MAXIMUM_WAIT_OBJECTS(64)로 제한되어
64개를 초과하여 쓰레드를 생성하면 문제가 될 수 있다.

이름있는 뮤텍스 기반의 프로세스 동기화
뮤텍스에 이름을 붙여 생성하면 Named Mutex, 세마포어에 이름을 붙여 생성하면 Named Semaphore.
뮤텍스는 커널 즉 운영체제 소유이다.
서로 다른 프로세스 영역에 존재하는 쓰레드가 뮤텍스를 이용해 동기화할 수 있다.
프로세스 A의 요청에 의해 생성되었다고 해서 프로세스 A의 영역에 존재하는 것이 아니다.
커널이 관리(생성 및 소멸 시기 결정)하는 오브젝트이므로, 프로세스 B도 접근가능하다.
다만 핸들의 유효성 문제점이 있다.
핸들 테이블은 커널 오브젝트와 이를 지칭하는 핸들값에 대한 정보를 담고 있는 테이블인데, 이는 각각의 
프로세스별로 독립적이다.
만약 프로세스 A가 뮤텍스를 생성했다고 가정하고 테이블에 핸들값은 204라고 하자.
그러면 프로세스 B는 프로세스 A가 생성한 뮤텍스에 접근이 불가능하다.
프로세스 A를 통해 만들어진 커널 오브젝트인 관계로 프로세스 B의 핸들 테이블에는 이에 대한 정보가 없기 때문.
핸들값만 B에 넘겨주어도 안된다.
그래서 뮤텍스에 이름을 붙여주기로 결정한 것.
이 이름은 Windows라는 운영체제 내에서 유일한 이름이다.
이 이름을 통해 Windows가 관리하고 있는 커널 오브젝트에 접근 가능한 핸들 정보를 얻을 수 있다.
13_5.cpp NamedMutex.cpp
확인해야 할 것은 서로 다른 프로세스에 속해 있는 두 개의 쓰레드 동기화가 가능하다는 사실.
if값을 1로 설정한 다음 빌드해서 실행파일을 만든다음 이름을 "CreateMutex.exe".
0으로 설정한 다음 실행파일을 'OpenMutex.exe'.
CreateMutex.exe를 먼저 실행해 뮤텍스를 생성한 다음, 문자열 Thread Running을 출력한다.
출력이 완료되기 전에 바로 이어서 OpenMutex.exe를 실행한다.
함수 호출을 통해 앞서 실행된 프로세스가 소유하고 있는 뮤텍스의 핸들을 얻게 된다.
그리고 이 뮤텍스를 소윻려 든다.
그러나 이미 뮤텍스가 소유된 상태이기 때문에, CreateMutex.exe가 뮤텍스를 반환할 때까지 실행이 멈춘다.
뮤텍스가 반환되면, OpenMutex.exe가 이어서 실행을 시작한다.
HANDLE OpenMutex (
	DWORD dwDesiredAccess, 1)
	BOOL bInheritHandle, 2)
	LPCTSTR lpName 3)
);
1)dwDesiredAccess:이름있는 뮤텍스로의 접근권한을 지정하는 것. 전달인자로 MUTEX_ALL_ACCESS을 전달해서
접근할 수 있는 권한을 요청해야 한다.
2)hInheritHandle:핸들의 상속 유무를 결정하기 위한 전달인자이다.
3)lpName:얻고자 하는 핸들 정보의 커널 오브젝트 이름을 전달한다. 여기로 전달하는 이름과 일치하는 이름을 지니는
뮤텍스가 존재한다면, 이 뮤텍스의 핸들이 반환된다. 물론 핸들 테이블에 이에 대한 정보도 추가된다.

뮤텍스의 소유와 WAIT_ABANDONED
A와 B 쓰레드가 있고, 세마포어 오브젝트 C가 있다고하고 A쓰레드가 세마포어 C의 카운트를 하나 감소시켰다고 하자.
그러면 다시 카운트를 증가시키는 쓰레드는 A가 되야 한다.
이것이 일반적인 멀티 쓰레드 동기화 구조이다.
그러나 이러한 제약사항을 반드시 지켜줘야 하는 것은 뮤텍스뿐이다.
세마포어의 경우 세마포어를 획득하는 쓰레드와 반환하는 쓰레드가 달라도 문제가 되지 않는다.
그러나 뮤텍스는 문제가 된다.
세마포어에는 소유의 개념이 존재하지 않는다고 말할 수 있다.
그러나 전통적인 운영체제 관점에서 본다면 동기화라는 주제 자체가 소유라는 개념에서 시작한다.
세마포어도 소유라는 개념으로 이야기가 전개된다.
"뮤텍스는 획득한 쓰레드가 직접 반환하는 것이 원칙이다. 본인만이 반환할 수 있다. 그러나 세마포어와 그 이외의
동기화 오브젝트는 마치 대여점처럼 대신 다른 쓰레드가 반환해 줘도 문제가 되지 않는다."
WAIT_ABANDONED가 반환되는 상황은 두 개의 쓰레드 A,B와 동기화 오브젝트인 뮤텍스 C가 있다고 할 때,
쓰레드 A가 뮤텍스 C를 획득하고, 쓰레드 B는 쓰레드 A가 뮤텍스를 반환하기를 기다린다.
그런데 갑자기 예상치 못하게 쓰레드 A가 종료되어 버렸다.
뮤텍스를 반환하지도 않고 사라져버린 것.
이제 Windows는 이런 상황을 파악한다.
Windows는 쓰레드의 상태와 뮤텍스의 상태를 예의주시하기 때문에 문제를 인식한다.
그리고 더 이상 정상적인 방법으로 반환이 불가능한 뮤텍스를 대신 반환해 주고, 다음 대기자인 쓰레드 B가 뮤텍스를
소유할 수 있도록 도와준다.
이때 쓰레드 B는 WAIT_ABANDONED 값을 반환받게 된다.
13_6.cpp MUTEX_WAIT_ABANDONED.cpp
결과값이 2인데 정상이다.
프로그램 흐름에 있어서 WAIT_ABANDONED의 반환 자체는 오류가 아니다.
Windows가 뮤텍스 소유 관련하여 문제가 발생했음을 알고 적절히 처리해주는것.
반환값 WAIT_ABANDONED을 얻은 쓰레드가 결국에는 뮤텍스를 소유하게 됨.
흐름은 괜찮지만 프로그램 코드에는 문제가 있을 수 있는 것.
이 반환값은 디버깅에 관련해서 삽입하는 경우가 대부분.

이것만은 알고 갑시다.
1. 유저 모드 동기화와 커널 모드 동기화의 차이점 그리고 장단점
유저 모드 동기화는 커널의 힘을 빌리지 않는 단순한 라이브러리 기반의 동기화이다. 따라서 커널 모드로의
전환이 불필요하기 때문에 성능상에 큰 이점이 있다. 하지만 기능상의 제한도 있다. 반면 커널 모드 동기화는
커널에 의해 이뤄지는 동기화이다. 라이브러리 형태로 제공되는 함수를 호출하지만 실제로 동기화라는 일을 하는 대상은
커널이다. 따라서 유저 모드 동기화에서 제공하지 못하는 기능을 제공받을 수 있다.
2. 임계 영역의 의미
임계 영역은 메모리를 의미하는 것이 아니라 둘 이상의 쓰레드가 동시에 실행하면 문제가 발생하는 프로그램상의
코드 일부를 의미하는 것.
3. 뮤텍스와 세마포어의 차이점 및 유사점
뮤텍스는 세마포어의 일종이다. 세마포어는 카운트를 지닐 수 있다. 카운트를 지닐 수 있다는 것은 임계 영역에 진입할
수 있는 쓰레드의 개수를 늘리거나 줄일 수 있다는 뜻. 임계 영역에 진입할 수 있는 쓰레드를 하나로 제한할 경우
세마포어의 카운트를 1로 둬야 하는데, 1로 두면 뮤텍스라 할 수 있다.
4. volatile 키워드
최적화를 수행하지 마라. 메모리에 직접 연산하라. 즉 캐쉬하지 마라.

*/
